<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AmysCVAssembler - Z80 Assembler for ColecoVision</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/material-darker.min.css">
    <!-- JSZip for handling .zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- pako for handling .gz files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/mode/simple.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .CodeMirror {
            border-radius: 0.5rem;
            height: 100%;
            font-size: 14px;
        }
        .file-tree-item {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .file-tree-item:hover {
            background-color: #374151;
        }
        .file-tree-item.active {
            background-color: #4f46e5;
            color: white;
        }
        .cm-s-material-darker.CodeMirror {
            background-color: #1f2937;
        }
        #drop-zone {
            border: 2px dashed #4b5563;
            transition: border-color 0.2s, background-color 0.2s;
        }
        #drop-zone.drag-over {
            border-color: #4f46e5;
            background-color: #374151;
        }
        .tab-button {
            cursor: pointer;
            transition: all 0.2s;
        }
        .tab-button.active {
            background-color: #4f46e5;
            color: white;
        }
        .tab-button:not(.active) {
            color: #9ca3af;
        }
        .tab-button:not(.active):hover {
            background-color: #374151;
            color: white;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Fira+Code&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col h-screen">

    <header class="bg-gray-800 p-4 shadow-md flex justify-between items-center">
        <h1 class="text-2xl font-bold text-white">AmysCVAssembler <span class="text-sm text-gray-400">(ColecoVision)</span></h1>
        <div class="flex items-center gap-4">
            <!-- Platform selector hidden - hardcoded to ColecoVision -->
            <select id="target-platform" class="hidden" title="Target Platform">
                <option value="coleco" selected>ColecoVision</option>
            </select>
            <div id="test-buttons-container" class="flex items-center gap-2 hidden">
                <button id="test-cv-screen" class="bg-purple-600 hover:bg-purple-700 text-white text-xs py-1 px-2 rounded transition-colors">
                    Test CV Screen
                </button>
                <button id="test-dina-screen" class="bg-green-600 hover:bg-green-700 text-white text-xs py-1 px-2 rounded transition-colors">
                    Test DINA Screen
                </button>
            </div>
            <button id="compile-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed">
                Compile
            </button>
            <button id="download-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors hidden ml-2">
                Download Binary
            </button>
            <button id="export-symbols-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors hidden ml-2">
                Export Symbols
            </button>
        </div>
    </header>

    <main class="flex-grow flex p-4 gap-4 overflow-hidden">
        <!-- Left Panel: File Tree and Drop Zone -->
        <div class="w-1/4 flex flex-col bg-gray-800 p-4 rounded-lg shadow-lg">
            <h2 class="text-lg font-semibold mb-2 border-b border-gray-700 pb-2">Project Files</h2>
            <div id="file-tree" class="flex-grow overflow-y-auto mb-4">
                <p class="text-gray-400 text-sm">Drop files or a zip/gz archive below.</p>
            </div>
            <div id="drop-zone" class="p-6 text-center rounded-lg">
                <p class="text-gray-400">Drag & Drop Files Here</p>
            </div>
        </div>

        <!-- Middle Panel: Code Editor -->
        <div class="w-1/2 flex flex-col bg-gray-800 rounded-lg shadow-lg overflow-hidden min-h-0">
            <div id="editor-container" class="flex-grow relative min-h-0">
                 <textarea id="code-editor"></textarea>
            </div>
        </div>

        <!-- Right Panel: Console Output and Symbol Table -->
        <div class="w-1/4 flex flex-col bg-gray-800 p-4 rounded-lg shadow-lg">
            <div class="flex mb-2 border-b border-gray-700 pb-2">
                <button id="console-tab" class="tab-button active text-lg font-semibold px-3 py-1 rounded mr-2">Console</button>
                <button id="symbols-tab" class="tab-button text-lg font-semibold px-3 py-1 rounded">Symbols</button>
            </div>
            <pre id="console-output" class="flex-grow bg-gray-900 rounded-md p-2 text-sm overflow-y-auto whitespace-pre-wrap font-mono"></pre>
            <pre id="symbols-output" class="flex-grow bg-gray-900 rounded-md p-2 text-sm overflow-y-auto whitespace-pre-wrap font-mono hidden"></pre>
        </div>
    </main>

    <script>
        // Enhanced CodeMirror setup with better Z80 syntax highlighting
        CodeMirror.defineSimpleMode("z80", {
            start: [
                {regex: /;.*$/, token: "comment"},
                {regex: /([a-zA-Z_][a-zA-Z0-9_.]*):/, token: "tag"},
                {regex: /\$\$[a-zA-Z_][a-zA-Z0-9_]*/, token: "variable-3"}, // Named temporary symbols
                {regex: /\.[a-zA-Z_][a-zA-Z0-9_]*/, token: "variable-2"}, // Composed temporary symbols
                {regex: /[+-\/](?=\s*:)/, token: "variable-3"}, // Nameless temporary symbols
                {regex: /\.?(cpu|fname|equ|set|eval|constant|org|dw|ds|db|defb|defw|defs|defm|include|incbin|macro|endm|rept|endr|if|endif|else|elif|cond|endc|section|endsection|radix|intsyntax|relaxed|padding)\b/i, token: "keyword"},
                {regex: /\b(a|b|c|d|e|h|l|i|r|af|bc|de|hl|sp|ix|iy|af'|ixh|ixl|iyh|iyl|nz|z|nc|c|po|pe|p|m)\b/i, token: "atom"},
                {regex: /\b(add|adc|sub|sbc|and|or|xor|cp|inc|dec|ld|push|pop|ex|exx|jp|jr|call|ret|reti|retn|rst|djnz|nop|halt|di|ei|im|neg|cpl|scf|ccf|daa|rla|rra|rlca|rrca|rld|rrd|ldi|ldir|ldd|lddr|cpi|cpir|cpd|cpdr|in|out|ini|ind|outi|outd|rlc|rrc|rl|rr|sla|sra|sll|srl|bit|res|set)\b/i, token: "builtin"},
                {regex: /(\$|0x)[0-9a-fA-F]+|[0-9]+[hH]?|[01]+[bB]?|@[0-7]+|%[01]+/, token: "number"},
                {regex: /"[^"]*"/, token: "string"},
                {regex: /'[^\']'/, token: "string-2"},
                {regex: /[a-zA-Z_][a-zA-Z0-9_.]*/, token: "variable"},
            ],
            meta: {
                dontIndentStates: ["comment"],
                lineComment: ";"
            }
        });

        const editor = CodeMirror.fromTextArea(document.getElementById('code-editor'), {
            lineNumbers: true,
            theme: 'material-darker',
            mode: 'z80',
            indentUnit: 4,
            tabSize: 4,
        });

        // --- Global State ---
        let projectFiles = {};
        let currentFile = null;
        let compiledBinary = null;
        let assemblerInstance = null;
        let outputFilename = 'output.bin';

        // Target platform configurations
        const PLATFORM_CONFIGS = {
            'coleco': {
                packager: null,  // No padding - output minimal ROM like zmac
                validateHeader: 'coleco',
                description: 'ColecoVision ROM (minimal size, also compatible with DINA 2-in-1)'
            }
        };

        // Get current platform configuration
        function getPlatformConfig() {
            // Always return ColecoVision config
            return PLATFORM_CONFIGS['coleco'];
        }

        // ColecoVision header validation and title screen emulation
        function validateColecoHeader(binary, showEmulation = true) {
            const testButtonsContainer = document.getElementById('test-buttons-container');

            if (binary.length < 2) {
                log('Warning: Binary too small for ColecoVision header', 'warn');
                return { valid: false, usesDefaultScreen: false };
            }
            
            const header = (binary[1] << 8) | binary[0];
            let valid = false;
            let usesDefaultScreen = false;
            
            if (header === 0x55AA) {
                valid = true;
                usesDefaultScreen = true;
                log('ColecoVision header detected: $55AA (uses default ColecoVision title screen)', 'success');
            } else if (header === 0xAA55) {
                valid = true;
                usesDefaultScreen = false;
                log('ColecoVision header detected: $AA55 (bypasses default title screen - test cartridge)', 'success');
            } else {
                log(`Warning: Invalid ColecoVision header: ${header.toString(16).padStart(4, '0').toUpperCase()}. Expected $AA55 or $55AA`, 'warn');
            }

            if (header === 0x55AA || header === 0xAA55) {
                valid = true;
                testButtonsContainer.classList.remove('hidden');
            } else {
                testButtonsContainer.classList.add('hidden');
            }
            
            return { valid, usesDefaultScreen, header };
        }

        // Parse ColecoVision game title from header
        function parseGameTitle(binary) {
            const titleOffset = 0x8024 - 0x8000; // Title starts at $8024
            if (binary.length <= titleOffset) {
                return { line2: "UNKNOWN GAME", line3: "NO TITLE DATA", year: "1982" };
            }
            
            // Read title string from binary
            let titleString = '';
            for (let i = titleOffset; i < binary.length && binary[i] !== 0; i++) {
                if (binary[i] >= 32 && binary[i] <= 126) { // Printable ASCII
                    titleString += String.fromCharCode(binary[i]);
                } else {
                    break; // Stop at first non-printable character
                }
            }
            
            // Parse format: "LINE3/LINE2/YEAR"
            const parts = titleString.split('/');
            const line3 = parts[0] || "UNKNOWN GAME";
            const line2 = parts[1] || "NO PUBLISHER";
            const year = parts[2] || "1982";
            
            log(`Parsed game title: "${line2}" / "${line3}" / "${year}"`, 'info');
            return { line2, line3, year };
        }

        // === TMS9918A Emulation Components ===
        const TMS_PALETTE = [
            "#00000000", "#000000", "#21C842", "#5EDC78", "#5455ED", "#7D76FC", "#D4524D", "#42EBF5",
            "#FC5554", "#FF7978", "#D4C154", "#E5CE80", "#21B03B", "#C95AA9", "#CCCCCC", "#FFFFFF"
        ];

        // ColecoVision logo data (2x24 tiles)
        const CV_LOGO_2x24 = [
            0x60,0x61,0x68,0x69,0x70,0x71,0x78,0x79,0x80,0x81,0x88,0x89,0x64,0x65,0x6C,0x74,0x75,0x7C,0x84,0x85,0x8C,0x8D,0x1E,0x1F,
            0x62,0x63,0x6A,0x6B,0x72,0x73,0x7A,0x7B,0x82,0x83,0x8A,0x8B,0x66,0x67,0x6D,0x76,0x77,0x7D,0x86,0x87,0x8E,0x8F,0x00,0x00
        ];

        // DINA logo data (4x12 tiles)
        const DINA_LOGO_4x12 = [
            0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
            0xA0,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0xA0,
            0xA0,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0xA0,
            0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
        ];

        // Pattern data (hex encoded)
        const CV_PATTERN_DATA = `00 00 00 00 00 00 00 00 7e 81 bd a1 a1 bd 81 7e 1f 04 04 04 00 00 00 00 44 6c 54 54 00 00 00 00 00 00 00 00 00 00 00 00 20 20 20 20 20 00 20 00 50 50 50 00 00 00 00 00 50 50 f8 50 f8 50 50 00 20 78 a0 70 28 f0 20 00 c0 c8 10 20 40 98 18 00 40 a0 a0 40 a8 90 68 00 20 20 20 00 00 00 00 00 20 40 80 80 80 40 20 00 20 10 08 08 08 10 20 00 20 a8 70 20 70 a8 20 00 00 20 20 f8 20 20 00 00 00 00 00 00 20 20 40 00 00 00 00 f8 00 00 00 00 00 00 00 00 00 00 20 00 00 08 10 20 40 80 00 00 70 88 98 a8 c8 88 70 00 20 60 20 20 20 20 70 00 70 88 08 30 40 80 f8 00 f8 08 10 30 08 88 70 00 10 30 50 90 f8 10 10 00 f8 80 f0 08 08 88 70 00 38 40 80 f0 88 88 70 00 f8 08 10 20 40 40 40 00 70 88 88 70 88 88 70 00 70 88 88 78 08 10 e0 00 00 00 20 00 20 00 00 00 00 00 20 00 20 20 40 00 10 20 40 80 40 20 10 00 00 00 f8 00 f8 00 00 00 40 20 10 08 10 20 40 00 70 88 10 20 20 00 20 00 70 88 a8 b8 b0 80 78 00 20 50 88 88 f8 88 88 00 f0 88 88 f0 88 88 f0 00 70 88 80 80 80 88 70 00 f0 88 88 88 88 88 f0 00 f8 80 80 f0 80 80 f8 00 f8 80 80 f0 80 80 80 00 78 80 80 80 98 88 78 00 88 88 88 f8 88 88 88 00 70 20 20 20 20 20 70 00 08 08 08 08 08 88 70 00 88 90 a0 c0 a0 90 88 00 80 80 80 80 80 80 f8 00 88 d8 a8 a8 88 88 88 00 88 88 c8 a8 98 88 88 00 70 88 88 88 88 88 70 00 f0 88 88 f0 80 80 80 00 70 88 88 88 a8 90 68 00 f0 88 88 f0 a0 90 88 00 70 88 80 70 08 88 70 00 f8 20 20 20 20 20 20 00 88 88 88 88 88 88 70 00 88 88 88 88 88 50 20 00 88 88 88 a8 a8 d8 88 00 88 88 50 20 50 88 88 00 88 88 50 20 20 20 20 00 f8 08 10 20 40 80 f8 00 f8 c0 c0 c0 c0 c0 f8 00 00 80 40 20 10 08 00 00 f8 18 18 18 18 18 f8 00 00 00 20 50 88 00 00 00 00 00 00 00 00 00 00 f8 3f 7f ff ff f3 f3 f0 f0 00 80 c0 c0 c0 c0 00 00 f3 f3 ff ff 7f 3f 00 00 c0 c0 c0 c0 80 00 00 00 f1 f1 f1 7b 7b 7b 3f 3f e0 e0 e0 c0 c0 c0 80 80 3f 1f 1f 1f 0e 0e 00 00 80 00 00 00 00 00 00 00 3f 7f ff ff f3 f3 f3 f3 00 80 c0 c0 c0 c0 c0 c0 f3 f3 ff ff 7f 3f 00 00 c0 c0 c0 c0 80 00 00 00 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 00 00 00 00 f0 f0 ff ff ff ff 00 00 00 00 c0 c0 c0 c0 00 00 1f 3f 7f 79 78 7f 7f 3f 80 c0 e0 e0 00 80 c0 e0 1f 01 79 7f 3f 1f 00 00 e0 e0 e0 e0 c0 80 00 00 ff ff ff f0 f0 ff ff ff c0 c0 c0 00 00 00 00 00 f0 f0 ff ff ff ff 00 00 00 00 c0 c0 c0 c0 00 00 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 3f 7f ff ff f3 f3 f0 f0 00 80 c0 c0 c0 c0 00 00 f3 f3 ff ff 7f 3f 00 00 c0 c0 c0 c0 80 00 00 00 3f 7f ff ff f3 f3 f3 f3 00 80 c0 c0 c0 c0 c0 c0 f3 f3 ff ff 7f 3f 00 00 c0 c0 c0 c0 80 00 00 00 3f 7f ff ff f3 f3 f3 f3 00 80 c0 c0 c0 c0 c0 c0 f3 f3 ff ff 7f 3f 00 00 c0 c0 c0 c0 80 00 00 00 f3 f3 fb fb fb ff ff ff c0 c0 c0 c0 c0 c0 c0 c0 ff f7 f7 f7 f3 f3 00 00 c0 c0 c0 c0 c0 c0 00 00`;
        const CV_COLOR_DATA = `00 00 00 f0 f0 f0 f0 f0 f0 f0 f0 f0 d0 80 90 b0 30 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00`;

        const DINA_PATTERN_DATA = `00 00 00 00 00 00 00 00 7e 81 bd a1 a1 bd 81 7e 1f 04 04 04 00 00 00 00 44 6c 54 54 00 00 00 00 00 00 00 00 00 00 00 00 00 20 20 20 20 20 00 20 00 50 50 50 00 00 00 00 00 50 50 f8 50 f8 50 50 00 20 78 a0 70 28 f0 20 00 c0 c8 10 20 40 98 18 00 40 a0 a0 40 a8 90 68 00 10 10 10 20 00 00 00 00 20 40 80 80 80 40 20 00 20 10 08 08 08 10 20 00 20 a8 70 20 70 a8 20 00 00 20 20 f8 20 20 00 00 00 00 00 18 18 08 10 00 00 00 00 f8 00 00 00 00 00 00 00 00 00 60 60 00 00 08 10 20 40 80 00 00 70 88 98 a8 c8 88 70 00 20 60 20 20 20 20 70 00 70 88 08 30 40 80 f8 00 f8 08 10 30 08 88 70 00 10 30 50 90 f8 10 10 00 f8 80 f0 08 08 88 70 00 30 40 80 f0 88 88 70 00 f8 08 10 20 40 40 40 00 70 88 88 70 88 88 70 00 70 88 88 78 08 10 e0 00 00 30 30 00 30 30 00 00 18 18 00 18 18 08 10 00 10 20 40 80 40 20 10 00 00 00 f8 00 f8 00 00 00 80 40 20 10 20 40 80 00 70 88 10 20 20 00 20 00 70 88 88 b8 b8 80 78 00 20 50 88 88 f8 88 88 00 f0 88 88 f0 88 88 f0 00 70 88 80 80 80 88 70 00 f0 88 88 88 88 88 f0 00 f8 80 80 f0 80 80 f8 00 f8 80 80 f0 80 80 80 00 78 80 80 b8 88 88 78 00 88 88 88 f8 88 88 88 00 70 20 20 20 20 20 70 00 08 08 08 08 08 88 70 00 88 90 a0 c0 a0 90 88 00 80 80 80 80 80 80 f8 00 88 d8 a8 88 88 88 88 00 88 88 c8 a8 98 88 88 00 70 88 88 88 88 88 70 00 f0 88 88 f0 80 80 80 00 70 88 88 88 a8 90 68 00 f0 88 88 f0 a0 90 88 00 70 88 80 70 08 88 70 00 f8 20 20 20 20 20 20 00 88 88 88 88 88 88 70 00 88 88 88 88 88 50 20 00 88 88 88 a8 a8 d8 88 00 88 88 50 20 50 88 88 00 88 88 50 20 20 20 20 00 f8 08 10 20 40 80 f8 00 f8 80 80 80 80 80 f8 00 00 80 40 20 10 08 00 00 f8 08 08 08 08 08 f8 00 00 00 20 50 88 00 00 00 00 00 00 00 00 00 f8 00 60 60 40 20 00 00 00 00 00 00 68 98 88 98 68 00 80 80 b0 c8 88 c8 b0 00 00 00 78 80 80 80 78 00 08 08 68 98 88 98 68 00 00 00 70 88 f8 80 70 00 10 28 20 f8 20 20 20 00 68 98 98 68 08 08 70 00 80 80 b0 c8 88 88 88 00 20 00 60 20 20 20 70 00 10 00 10 10 10 10 60 00 00 80 90 a0 c0 a0 90 00 60 20 20 20 20 20 70 00 00 00 d0 a8 a8 a8 a8 00 00 00 f0 88 88 88 88 00 00 00 70 88 88 88 70 00 00 b0 c8 c8 b0 80 80 00 00 68 98 98 68 08 08 00 00 00 90 a0 c0 80 80 00 00 00 78 80 70 08 f0 00 20 20 70 20 20 20 30 00 00 00 88 88 88 88 78 00 00 00 88 88 88 50 20 00 00 00 88 88 a8 a8 50 00 00 00 88 50 20 50 88 00 00 00 90 90 f0 10 f0 00 00 00 f8 10 20 40 f8 00 20 40 40 80 40 40 20 00 20 20 20 00 20 20 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 1f 70 01 1f 18 30 3f 20 f8 0e 80 fc 0d 19 fb 33 0c cc cc d9 98 98 31 31 73 e3 07 cc c0 df 80 9f 0c 18 ff 30 60 ff 00 ff 00 00 8f 00 00 1f 03 06 18 30 ff 30 60 ff 00 03 00 00 f1 01 03 e3 03 87 00 00 ff 80 00 00 f8 fc 00 00 f0 00 00 00 7e ff 60 ff e0 7f 60 c0 ff 00 66 e6 0c ec 61 c1 8f 00 63 63 c3 c6 86 87 0d 00 30 30 60 7f 00 00 ff 00 06 06 0c fc 00 00 fc 00 1f 78 30 3f 60 60 ff 00 ff 00 00 ff 01 03 fe 00 e0 c0 c0 84 84 07 03 00 0f 07 07 07 0f fc f8 00 83 83 83 83 83 fe 7c 00`;
        const DINA_COLOR_DATA = `00 00 00 f0 f0 f0 f0 f0 f0 f0 f0 f0 40 70 c0 a0 91 91 91 91 11 00 00 00 00 00 00 00 00 00 00 00`;

        function hexToBytes(src) {
            const cleaned = src.replace(/[^0-9A-Fa-f]/g, ' ').trim();
            if (!cleaned) return new Uint8Array();
            const parts = cleaned.split(/\s+/);
            return new Uint8Array(parts.map(p => parseInt(p, 16) & 0xFF));
        }

        function createTMSOverlay(scale = 3) {
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;z-index:100';
            const canvas = document.createElement('canvas');
            canvas.width = 256 * scale;
            canvas.height = 192 * scale;
            canvas.style.imageRendering = 'pixelated';
            overlay.appendChild(canvas);
            document.body.appendChild(overlay);
            
            const close = () => {
                if (document.body.contains(overlay)) document.body.removeChild(overlay);
                document.removeEventListener('keydown', close);
                document.removeEventListener('click', close);
            };
            
            setTimeout(() => {
                document.addEventListener('keydown', close);
                document.addEventListener('click', close);
            }, 0);
            
            return { ctx: canvas.getContext('2d'), scale, close };
        }

        function blankName() {
            const a = new Uint8Array(768); // 32x24
            a.fill(0x20);
            return a;
        }

        function pasteRect(name, row, col, w, h, flat) {
            for (let r = 0; r < h; r++) {
                for (let c = 0; c < w; c++) {
                    name[(row + r) * 32 + (col + c)] = flat[r * w + c] & 0xFF;
                }
            }
        }

        function putAsciiCenteredCeil(name, row, text = "") {
            const s = text.toUpperCase();
            const start = Math.max(0, Math.ceil((32 - s.length) / 2));
            for (let i = 0; i < s.length && start + i < 32; i++) {
                name[row * 32 + start + i] = s.charCodeAt(i) & 0xFF;
            }
        }

        function putAsciiAt(name, row, col, text = "") {
            const s = text.toUpperCase();
            for (let i = 0; i < s.length && col + i < 32; i++) {
                name[row * 32 + col + i] = s.charCodeAt(i) & 0xFF;
            }
        }

        function colorsFor(tileIndex, colorBytes, defFG = 15, defBG = 1) {
            let FG = defFG, BG = defBG;
            const idx = tileIndex >>> 3;
            if (idx < colorBytes.length) {
                const b = colorBytes[idx] >>> 0;
                FG = (b >>> 4) & 0xF;
                BG = b & 0xF;
                if (FG === 0) FG = defBG;
                if (BG === 0) BG = defBG;
            }
            return [FG, BG];
        }

        function drawTile8(ctx, pat, tileIndex, fg = 15, bg = 1, dx = 0, dy = 0, scale = 3) {
            const baseTile = 0x00E0 >>> 3;
            const local = (tileIndex - baseTile) * 8;
            if (local < 0 || local + 7 >= pat.length) {
                ctx.fillStyle = TMS_PALETTE[bg];
                ctx.fillRect(dx, dy, 8 * scale, 8 * scale);
                return;
            }
            for (let row = 0; row < 8; row++) {
                const b = pat[local + row] >>> 0;
                for (let bit = 7; bit >= 0; bit--) {
                    ctx.fillStyle = ((b >> bit) & 1) ? TMS_PALETTE[fg] : TMS_PALETTE[bg];
                    ctx.fillRect(dx + (7 - bit) * scale, dy + row * scale, scale, scale);
                }
            }
        }

        function drawScreenTo(ctx, scale, name, pat, color, defBG) {
            ctx.fillStyle = TMS_PALETTE[1];
            ctx.fillRect(0, 0, 256 * scale, 192 * scale);
            for (let r = 0; r < 24; r++) {
                for (let c = 0; c < 32; c++) {
                    const v = name[r * 32 + c];
                    const [fg, bg] = colorsFor(v, color, 15, defBG);
                    drawTile8(ctx, pat, v, fg, bg, c * 8 * scale, r * 8 * scale, scale);
                }
            }
        }

        function buildColecoName(title, publisher, year = "1982") {
            const name = blankName();
            pasteRect(name, 4, 5, 24, 2, CV_LOGO_2x24);
            
            if (publisher && title) {
                putAsciiCenteredCeil(name, 14, publisher);
                putAsciiCenteredCeil(name, 16, title);
            } else {
                putAsciiCenteredCeil(name, 13, "TURN GAME OFF");
                putAsciiCenteredCeil(name, 15, "BEFORE INSERTING CARTRIDGE");
                putAsciiCenteredCeil(name, 17, "OR EXPANSION MODULE.");
            }
            
            const base = 21 * 32 + 10;
            name[base + 0] = 0x1D; // Â© glyph
            name[base + 1] = 0x20; // space
            const y = String(year).replace(/\D+/g, "").padStart(4,' ').slice(-4);
            for (let i = 0; i < 4; i++) name[base + 2 + i] = y.charCodeAt(i) & 0xFF;
            putAsciiAt(name, 21, 16, " COLECO");
            return name;
        }

        function buildDinaName(title, publisher) {
            const name = blankName();
            pasteRect(name, 3, 9, 12, 4, DINA_LOGO_4x12);
            putAsciiAt(name, 9, 6, "BIT CORPORATION 1986");
            putAsciiCenteredCeil(name, 14, publisher || "PRESENTS");
            putAsciiCenteredCeil(name, 16, title || "GAME TITLE");
            return name;
        }

        // Authentic ColecoVision boot screen emulation with proper TMS9918A rendering
        function emulateColecoBootScreen(gameInfo) {
            const pat = hexToBytes(CV_PATTERN_DATA);
            const color = hexToBytes(CV_COLOR_DATA);
            const name = buildColecoName(gameInfo.line3, gameInfo.line2, gameInfo.year);
            
            const { ctx, scale, close } = createTMSOverlay(3);
            drawScreenTo(ctx, scale, name, pat, color, 1);
            
            // Auto-close after 8 seconds (authentic timing) or on user input
            setTimeout(close, 8000);
            
            log(`Emulated authentic ColecoVision boot screen for "${gameInfo.line2}" (8 seconds)`, 'info');
        }

        // DINA 2-in-1 boot screen emulation with proper TMS9918A rendering
        function emulateDinaBoot(gameInfo) {
            const pat = hexToBytes(DINA_PATTERN_DATA);
            const color = hexToBytes(DINA_COLOR_DATA);
            const name = buildDinaName(gameInfo.line3, gameInfo.line2);
            
            const { ctx, scale, close } = createTMSOverlay(3);
            drawScreenTo(ctx, scale, name, pat, color, 2);
            
            // Auto-close after 4 seconds or on user input
            setTimeout(close, 4000);
            
            log('Emulated authentic DINA 2-in-1 boot screen (4 seconds)', 'info');
        }
        // --- DOM Elements ---
        const dropZone = document.getElementById('drop-zone');
        const fileTree = document.getElementById('file-tree');
        const consoleOutput = document.getElementById('console-output');
        const symbolsOutput = document.getElementById('symbols-output');
        const compileBtn = document.getElementById('compile-btn');
        const downloadBtn = document.getElementById('download-btn');
        const exportSymbolsBtn = document.getElementById('export-symbols-btn');
        const consoleTab = document.getElementById('console-tab');
        const symbolsTab = document.getElementById('symbols-tab');

        // --- Logging Utility ---
        const log = (message, type = 'info') => {
            const time = new Date().toLocaleTimeString();
            const color = {
                info: 'text-gray-400',
                success: 'text-green-400',
                error: 'text-red-400',
                warn: 'text-yellow-400'
            }[type];
            consoleOutput.innerHTML += `<span class="text-gray-600">[${time}]</span> <span class="${color}">${message}</span>\n`;
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        };

        // --- Tab Management ---
        let activeTab = 'console';
        
        const switchTab = (tabName) => {
            activeTab = tabName;
            if (tabName === 'console') {
                consoleTab.classList.add('active');
                symbolsTab.classList.remove('active');
                consoleOutput.classList.remove('hidden');
                symbolsOutput.classList.add('hidden');
            } else {
                symbolsTab.classList.add('active');
                consoleTab.classList.remove('active');
                consoleOutput.classList.add('hidden');
                symbolsOutput.classList.remove('hidden');
            }
        };

        consoleTab.addEventListener('click', () => switchTab('console'));
        symbolsTab.addEventListener('click', () => switchTab('symbols'));

        // --- File Handling ---
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
            handleFiles(e.dataTransfer.files);
        });

        async function handleFiles(files) {
            projectFiles = {};
            log('Processing dropped files...');
            for (const file of files) {
                const filename = file.name;
                if (filename.toLowerCase().endsWith('.zip')) {
                    await handleZipFile(file);
                } else if (filename.toLowerCase().endsWith('.gz')) {
                    await handleGzFile(file);
                } else {
                    await handleSingleFile(file);
                }
            }
            renderFileTree();
            // Automatically open the first .asm or .z80 file found
            const firstAsm = Object.keys(projectFiles).find(f => {
                const lower = f.toLowerCase();
                return lower.endsWith('.asm') || lower.endsWith('.z80');
            });
            if (firstAsm) {
                openFile(firstAsm);
            }
        }

        async function handleZipFile(file) {
            const zip = await JSZip.loadAsync(file);
            for (const [relativePath, zipEntry] of Object.entries(zip.files)) {
                if (!zipEntry.dir) {
                    const content = await zipEntry.async('uint8array');
                    projectFiles[relativePath] = content;
                     log(`Unzipped: ${relativePath}`);
                }
            }
        }

        async function handleGzFile(file) {
            const buffer = await file.arrayBuffer();
            const decompressed = pako.inflate(new Uint8Array(buffer));
            const originalName = file.name.replace(/\.gz$/i, '');
            projectFiles[originalName] = decompressed;
            log(`Decompressed: ${originalName}`);
        }

        async function handleSingleFile(file) {
            const content = await file.arrayBuffer().then(b => new Uint8Array(b));
            projectFiles[file.name] = content;
            log(`Loaded: ${file.name}`);
        }
        
        function renderFileTree() {
            fileTree.innerHTML = '';
            const sortedFiles = Object.keys(projectFiles).sort();
            if (sortedFiles.length === 0) {
                 fileTree.innerHTML = '<p class="text-gray-400 text-sm">No files in project.</p>';
                 return;
            }
            sortedFiles.forEach(filename => {
                const item = document.createElement('div');
                const itemContainer = document.createElement('div');
                itemContainer.style.display = 'flex';
                itemContainer.style.alignItems = 'center';
                itemContainer.style.justifyContent = 'space-between';
                itemContainer.style.width = '100%';

                const fileLabel = document.createElement('span');
                fileLabel.textContent = filename;
                fileLabel.style.flex = '1';
                fileLabel.style.cursor = 'pointer';
                fileLabel.onclick = () => openFile(filename);

                // Add download button
                const downloadIcon = document.createElement('span');
                downloadIcon.innerHTML = 'ðŸ’¾';
                downloadIcon.style.cursor = 'pointer';
                downloadIcon.style.marginLeft = '8px';
                downloadIcon.style.fontSize = '16px';
                downloadIcon.style.padding = '4px 6px';
                downloadIcon.style.borderRadius = '4px';
                downloadIcon.style.transition = 'all 0.2s ease';
                downloadIcon.title = 'Download file';
                downloadIcon.onmouseenter = () => {
                    downloadIcon.style.background = '#3b82f6';
                    downloadIcon.style.transform = 'scale(1.2)';
                };
                downloadIcon.onmouseleave = () => {
                    downloadIcon.style.background = 'transparent';
                    downloadIcon.style.transform = 'scale(1)';
                };
                downloadIcon.onclick = (e) => {
                    e.stopPropagation();
                    downloadProjectFile(filename);
                };

                // Add delete button
                const deleteIcon = document.createElement('span');
                deleteIcon.innerHTML = 'ðŸ—‘ï¸';
                deleteIcon.style.cursor = 'pointer';
                deleteIcon.style.marginLeft = '4px';
                deleteIcon.style.fontSize = '16px';
                deleteIcon.style.padding = '4px 6px';
                deleteIcon.style.borderRadius = '4px';
                deleteIcon.style.transition = 'all 0.2s ease';
                deleteIcon.title = 'Delete file from project';
                deleteIcon.onmouseenter = () => {
                    deleteIcon.style.background = '#ef4444';
                    deleteIcon.style.transform = 'scale(1.2)';
                };
                deleteIcon.onmouseleave = () => {
                    deleteIcon.style.background = 'transparent';
                    deleteIcon.style.transform = 'scale(1)';
                };
                deleteIcon.onclick = (e) => {
                    e.stopPropagation();
                    deleteProjectFile(filename);
                };

                itemContainer.appendChild(fileLabel);
                itemContainer.appendChild(downloadIcon);
                itemContainer.appendChild(deleteIcon);

                item.className = 'file-tree-item';
                if (filename === currentFile) {
                    item.classList.add('active');
                }
                item.appendChild(itemContainer);
                fileTree.appendChild(item);
            });
            updateCompileButtonState();
        }

        function openFile(filename) {
            if (!projectFiles[filename]) {
                log(`File not found: ${filename}`, 'error');
                return;
            }
            
            currentFile = filename;
            const content = projectFiles[filename];

            // Check if file is assembly source by extension (.asm, .z80, .s)
            const lowerFilename = filename.toLowerCase();
            const isAssemblyFile = lowerFilename.endsWith('.asm') ||
                                   lowerFilename.endsWith('.z80') ||
                                   lowerFilename.endsWith('.s');

            // Assembly files are always treated as text, even if they contain binary data (like ROM headers)
            if (isAssemblyFile) {
                try {
                    const decoder = new TextDecoder('utf-8', { fatal: false }); // Allow malformed sequences
                    const textContent = decoder.decode(content);
                    editor.setValue(textContent);
                    log(`Opened assembly file: ${filename}`);
                } catch (e) {
                    // Fallback for truly malformed content
                    const decoder = new TextDecoder('utf-8', { fatal: false });
                    const textContent = decoder.decode(content);
                    editor.setValue(textContent);
                    log(`Opened assembly file (with encoding issues): ${filename}`, 'warn');
                }
            } else {
                // For non-assembly files, attempt to decode as text
                try {
                    const decoder = new TextDecoder('utf-8', { fatal: true });
                    const textContent = decoder.decode(content);
                    editor.setValue(textContent);
                    log(`Opened text file: ${filename}`);
                } catch (e) {
                    editor.setValue(`--- BINARY FILE: ${filename} ---\n\nCannot display content.`);
                    log(`Opened binary file: ${filename}`);
                }
            }

            renderFileTree();
        }

        editor.on("change", () => {
            if (currentFile) {
                const textEncoder = new TextEncoder();
                projectFiles[currentFile] = textEncoder.encode(editor.getValue());
            }
            updateCompileButtonState();
        });

        function updateCompileButtonState() {
            const hasAsmFile = Object.keys(projectFiles).some(f => {
                const lower = f.toLowerCase();
                return lower.endsWith('.asm') || lower.endsWith('.z80');
            });
            const editorContent = editor.getValue();
            // A very basic check for Z80 code
            const seemsLikeZ80 = /ld|jp|call|ret/i.test(editorContent);
            compileBtn.disabled = !(hasAsmFile || (editorContent.trim() && seemsLikeZ80));
        }

        // --- Parser Classes ---
        class Instruction {
            constructor(label, mnemonic, operands, lineNumber = 0) { 
                this.label = label; 
                this.mnemonic = mnemonic; 
                this.operands = operands; 
                this.lineNumber = lineNumber;
            }
        }

        class Directive {
            constructor(label, name, operands, lineNumber = 0) { 
                this.label = label; 
                this.name = name; 
                this.operands = operands; 
                this.lineNumber = lineNumber;
            }
        }

        class Operand {
            constructor(type, value) { 
                this.type = type; 
                this.value = value; 
            }
        }
        
        // Enhanced Number Parser with multiple format support
        class NumberParser {
            constructor() {
                this.defaultRadix = 10;
                this.syntaxModes = {
                    intel: true,
                    motorola: true,
                    c: true,
                    ibm: true
                };
            }

            parseNumber(str) {
                if (!str) return null;

                // Remove whitespace
                str = str.trim();
                if (!str) return null;

                // Reject expressions with arithmetic operators - these should be evaluated as expressions
                // Check for operators outside of quotes (but allow negative numbers with leading -)
                if (/[\+\*\/]/.test(str) || (/-/.test(str.substring(1)))) {
                    return null;  // This is an expression, not a simple number
                }

                // Try different number formats
                
                // Motorola/Intel: $hex
                if (str.startsWith('$')) {
                    return parseInt(str.substring(1), 16);
                }
                
                // C style: 0x/0X hex, 0b binary, 0 octal
                if (str.startsWith('0x') || str.startsWith('0X')) {
                    return parseInt(str, 16);
                }
                if (str.startsWith('0b') || str.startsWith('0B')) {
                    return parseInt(str.substring(2), 2);
                }
                if (str.startsWith('0') && str.length > 1 && /^[0-7]+$/.test(str.substring(1))) {
                    return parseInt(str, 8);
                }
                
                // Intel suffix: hex with H, binary with B, octal with O/Q
                if (/^[0-9a-fA-F]+[hH]$/.test(str)) {
                    return parseInt(str.slice(0, -1), 16);
                }
                if (/^[01]+[bB]$/.test(str)) {
                    return parseInt(str.slice(0, -1), 2);
                }
                if (/^[0-7]+[oOqQ]$/.test(str)) {
                    return parseInt(str.slice(0, -1), 8);
                }
                
                // Motorola prefix: %binary, @octal
                if (str.startsWith('%')) {
                    return parseInt(str.substring(1), 2);
                }
                if (str.startsWith('@')) {
                    return parseInt(str.substring(1), 8);
                }
                
                // IBM style: x'hex', h'hex', o'oct', b'bin'
                const ibmMatch = str.match(/^([xhobXHOB])'([^']*)'?$/);
                if (ibmMatch) {
                    const [, prefix, value] = ibmMatch;
                    switch (prefix.toLowerCase()) {
                        case 'x':
                        case 'h':
                            return parseInt(value, 16);
                        case 'o':
                            return parseInt(value, 8);
                        case 'b':
                            return parseInt(value, 2);
                    }
                }
                
                // ASCII/Character constants
                if (str.startsWith("'") && str.endsWith("'") && str.length >= 3) {
                    const chars = str.slice(1, -1);
                    let result = 0;
                    for (let i = 0; i < chars.length; i++) {
                        result = (result << 8) | chars.charCodeAt(i);
                    }
                    return result;
                }
                
                // Default decimal
                if (/^\d+$/.test(str)) {
                    return parseInt(str, this.defaultRadix);
                }
                
                return null;
            }
        }

        // Enhanced Lexer with temporary symbol support
        class Lexer {
            constructor(code) {
                this.code = code;
                this.tokens = [];
                this.numberParser = new NumberParser();
                this.directives = ['CPU', 'FNAME', 'EQU', 'EVAL', 'CONSTANT', 'ORG', 'DW', 'DEFW', 'WORD', 'DS', 'DEFS', 'DB', 'DEFB', 'DEFM', 'ASCII', 'TEXT', 'BYTE', 'INCLUDE', 'INCBIN', 'MACRO', 'ENDM', 'REPT', 'ENDR', 'IF', 'ENDIF', 'ELSE', 'ELIF', 'COND', 'ENDC', 'SECTION', 'ENDSECTION', 'RADIX', 'INTSYNTAX', 'RELAXED', 'PADDING', 'END'];
                this.tempSymbolCounters = {
                    named: 0,
                    plus: 0,
                    minus: 0,
                    slash: 0
                };
            }

            parse_operands(operands_str) {
                const operands = [];
                if (!operands_str) return operands;

                // Improved parsing to handle parentheses properly
                const parts = [];
                let current = '';
                let depth = 0;
                let inQuotes = false;
                let quoteChar = '';
                
                for (let i = 0; i < operands_str.length; i++) {
                    const char = operands_str[i];
                    
                    if (inQuotes) {
                        if (char === quoteChar) {
                            inQuotes = false;
                            quoteChar = '';
                        } 
                        current += char;
                    } else {
                        if (char === '(') {
                            depth++;
                            current += char;
                        } else if (char === ')') {
                            depth--;
                            current += char;
                        } else if (char === ',' && depth === 0) {
                            if (current.trim()) {
                                parts.push(current.trim());
                            }
                            current = '';
                        } else if ((char === '"' || char === "'") && (i === 0 || operands_str[i-1] !== '\\')) {
                            inQuotes = true;
                            quoteChar = char;
                            current += char;
                        } else {
                            current += char;
                        }
                    }
                }
                
                if (current.trim()) {
                    parts.push(current.trim());
                }
                
                for (let part of parts) {
                    part = part.trim();
                    if (!part) continue;
                    
                    // Try to parse as number first
                    const numValue = this.numberParser.parseNumber(part);
                    if (numValue !== null) {
                        operands.push(new Operand('immediate', numValue));
                        continue;
                    }
                    
                    // Check for registers
                    if (/^(A|B|C|D|E|H|L|I|R|IXH|IXL|IYH|IYL)$/i.test(part)) {
                        operands.push(new Operand('register', part.toUpperCase()));
                        continue;
                    }
                    
                    if (/^(AF|BC|DE|HL|SP|IX|IY|AF\')$/i.test(part)) {
                        operands.push(new Operand('register_pair', part.toUpperCase()));
                        continue;
                    }
                    
                    if (/^(NZ|Z|NC|C|PO|PE|P|M)$/i.test(part)) {
                        operands.push(new Operand('condition', part.toUpperCase()));
                        continue;
                    }
                    
                    // Memory operands
                    if (part.startsWith('(') && part.endsWith(')')) {
                        const innerContent = part.slice(1, -1);
                        const innerNum = this.numberParser.parseNumber(innerContent);
                        if (innerNum !== null) {
                            operands.push(new Operand('memory', innerNum));
                        } else {
                            // It's a symbol inside parentheses
                            operands.push(new Operand('memory', innerContent));
                        }
                        continue;
                    }
                    
                    // String literals
                    if ((part.startsWith('"') && part.endsWith('"')) || 
                        (part.startsWith("'") && part.endsWith("'") && part.length === 3)) {
                        operands.push(new Operand('string', part.slice(1, -1)));
                        continue;
                    }
                    
                    // Everything else is a symbol
                    operands.push(new Operand('symbol', part));
                }
                return operands;
            }

            tokenize() {
                const lines = this.code.split('\n');
                for (let lineNum = 0; lineNum < lines.length; lineNum++) {
                    const line = lines[lineNum];
                    let trimmedLine = line.split(';')[0].trim();
                    if (!trimmedLine) continue;

                    const parts = trimmedLine.match(/(?:[^\s"']+|"[^"]*"|'[^']*'|AF')+/g) || [];
                    if (parts.length === 0) continue;

                    let label = null;
                    let mnemonic = parts[0];
                    let operands_str = parts.slice(1).join(' ');

                    // Handle temporary symbols and labels
                    if (parts[0].endsWith(':')) {
                        label = parts[0].slice(0, -1);
                        
                        // Process temporary symbols
                        if (label.startsWith('$$')) {
                            // Named temporary symbol
                            label = `__temp_named_${this.tempSymbolCounters.named}_${label.substring(2)}`;
                        } else if (label === '+' || label === '-' || label === '/') {
                            // Nameless temporary symbol
                            if (label === '+') {
                                label = `__temp_plus_${this.tempSymbolCounters.plus}`;
                                this.tempSymbolCounters.plus++;
                            } else if (label === '-') {
                                label = `__temp_minus_${this.tempSymbolCounters.minus}`;
                                this.tempSymbolCounters.minus++;
                            } else if (label === '/') {
                                label = `__temp_slash_${this.tempSymbolCounters.slash}`;
                                this.tempSymbolCounters.slash++;
                            }
                        }
                        
                        mnemonic = parts.length > 1 ? parts[1] : null;
                        operands_str = parts.slice(2).join(' ');
                    }
                    else if (parts.length > 1) {
                        // Check if parts[1] is a directive (with or without leading dot)
                        let checkDirective = parts[1].startsWith('.') ? parts[1].substring(1) : parts[1];
                        if (this.directives.includes(checkDirective.toUpperCase())) {
                            label = parts[0];
                            mnemonic = parts[1];
                            operands_str = parts.slice(2).join(' ');
                        }
                    }

                    if (!mnemonic) {
                        if (label) this.tokens.push(new Directive(label, 'LABEL', [], lineNum + 1));
                        continue;
                    }

                    // Strip leading dot for TASM-style directives (.ORG, .EQU, .DB, etc.)
                    let mnemonic_clean = mnemonic;
                    if (mnemonic.startsWith('.')) {
                        mnemonic_clean = mnemonic.substring(1);
                    }

                    const mnemonic_upper = mnemonic_clean.toUpperCase();
                    const operands = this.parse_operands(operands_str || '');

                    if (this.directives.includes(mnemonic_upper)) {
                        this.tokens.push(new Directive(label, mnemonic_upper, operands, lineNum + 1));
                    } else {
                        this.tokens.push(new Instruction(label, mnemonic_clean.toLowerCase(), operands, lineNum + 1));
                    }
                }
                return this.tokens;
            }
        }

        // --- Complete Z80 Opcode Table (Enhanced) ---
        const Z80_OPCODES = {
            'nop': [0x00], 'ld_bc,imm16': [0x01], 'ld_(bc),a': [0x02], 'inc_bc': [0x03], 'inc_b': [0x04], 'dec_b': [0x05], 'ld_b,imm8': [0x06], 'rlca': [0x07],
            'ex_af,af': [0x08], 'ex_af,af\'': [0x08], 'add_hl,bc': [0x09], 'ld_a,(bc)': [0x0A], 'dec_bc': [0x0B], 'inc_c': [0x0C], 'dec_c': [0x0D], 'ld_c,imm8': [0x0E], 'rrca': [0x0F],
            'djnz_rel8': [0x10], 'ld_de,imm16': [0x11], 'ld_(de),a': [0x12], 'inc_de': [0x13], 'inc_d': [0x14], 'dec_d': [0x15], 'ld_d,imm8': [0x16], 'rla': [0x17],
            'jr_rel8': [0x18], 'add_hl,de': [0x19], 'ld_a,(de)': [0x1A], 'dec_de': [0x1B], 'inc_e': [0x1C], 'dec_e': [0x1D], 'ld_e,imm8': [0x1E], 'rra': [0x1F],
            'jr_nz,rel8': [0x20], 'ld_hl,imm16': [0x21], 'ld_(imm16),hl': [0x22], 'inc_hl': [0x23], 'inc_h': [0x24], 'dec_h': [0x25], 'ld_h,imm8': [0x26], 'daa': [0x27],
            'jr_z,rel8': [0x28], 'add_hl,hl': [0x29], 'ld_hl,(imm16)': [0x2A], 'dec_hl': [0x2B], 'inc_l': [0x2C], 'dec_l': [0x2D], 'ld_l,imm8': [0x2E], 'cpl': [0x2F],
            'jr_nc,rel8': [0x30], 'ld_sp,imm16': [0x31], 'ld_(imm16),a': [0x32], 'inc_sp': [0x33], 'inc_(hl)': [0x34], 'dec_(hl)': [0x35], 'ld_(hl),imm8': [0x36], 'scf': [0x37],
            'jr_c,rel8': [0x38], 'add_hl,sp': [0x39], 'ld_a,(imm16)': [0x3A], 'dec_sp': [0x3B], 'inc_a': [0x3C], 'dec_a': [0x3D], 'ld_a,imm8': [0x3E], 'ccf': [0x3F],
            'ld_b,b': [0x40], 'ld_b,c': [0x41], 'ld_b,d': [0x42], 'ld_b,e': [0x43], 'ld_b,h': [0x44], 'ld_b,l': [0x45], 'ld_b,(hl)': [0x46], 'ld_b,a': [0x47],
            'ld_c,b': [0x48], 'ld_c,c': [0x49], 'ld_c,d': [0x4A], 'ld_c,e': [0x4B], 'ld_c,h': [0x4C], 'ld_c,l': [0x4D], 'ld_c,(hl)': [0x4E], 'ld_c,a': [0x4F],
            'ld_d,b': [0x50], 'ld_d,c': [0x51], 'ld_d,d': [0x52], 'ld_d,e': [0x53], 'ld_d,h': [0x54], 'ld_d,l': [0x55], 'ld_d,(hl)': [0x56], 'ld_d,a': [0x57],
            'ld_e,b': [0x58], 'ld_e,c': [0x59], 'ld_e,d': [0x5A], 'ld_e,e': [0x5B], 'ld_e,h': [0x5C], 'ld_e,l': [0x5D], 'ld_e,(hl)': [0x5E], 'ld_e,a': [0x5F],
            'ld_h,b': [0x60], 'ld_h,c': [0x61], 'ld_h,d': [0x62], 'ld_h,e': [0x63], 'ld_h,h': [0x64], 'ld_h,l': [0x65], 'ld_h,(hl)': [0x66], 'ld_h,a': [0x67],
            'ld_l,b': [0x68], 'ld_l,c': [0x69], 'ld_l,d': [0x6A], 'ld_l,e': [0x6B], 'ld_l,h': [0x6C], 'ld_l,l': [0x6D], 'ld_l,(hl)': [0x6E], 'ld_l,a': [0x6F],
            'ld_(hl),b': [0x70], 'ld_(hl),c': [0x71], 'ld_(hl),d': [0x72], 'ld_(hl),e': [0x73], 'ld_(hl),h': [0x74], 'ld_(hl),l': [0x75], 'halt': [0x76], 'ld_(hl),a': [0x77],
            'ld_a,b': [0x78], 'ld_a,c': [0x79], 'ld_a,d': [0x7A], 'ld_a,e': [0x7B], 'ld_a,h': [0x7C], 'ld_a,l': [0x7D], 'ld_a,(hl)': [0x7E], 'ld_a,a': [0x7F],
            'add_a,b': [0x80], 'add_a,c': [0x81], 'add_a,d': [0x82], 'add_a,e': [0x83], 'add_a,h': [0x84], 'add_a,l': [0x85], 'add_a,(hl)': [0x86], 'add_a,a': [0x87],
            'adc_a,b': [0x88], 'adc_a,c': [0x89], 'adc_a,d': [0x8A], 'adc_a,e': [0x8B], 'adc_a,h': [0x8C], 'adc_a,l': [0x8D], 'adc_a,(hl)': [0x8E], 'adc_a,a': [0x8F],
            'sub_b': [0x90], 'sub_c': [0x91], 'sub_d': [0x92], 'sub_e': [0x93], 'sub_h': [0x94], 'sub_l': [0x95], 'sub_(hl)': [0x96], 'sub_a': [0x97],
            'sbc_a,b': [0x98], 'sbc_a,c': [0x99], 'sbc_a,d': [0x9A], 'sbc_a,e': [0x9B], 'sbc_a,h': [0x9C], 'sbc_a,l': [0x9D], 'sbc_a,(hl)': [0x9E], 'sbc_a,a': [0x9F],
            'and_b': [0xA0], 'and_c': [0xA1], 'and_d': [0xA2], 'and_e': [0xA3], 'and_h': [0xA4], 'and_l': [0xA5], 'and_(hl)': [0xA6], 'and_a': [0xA7],
            'xor_b': [0xA8], 'xor_c': [0xA9], 'xor_d': [0xAA], 'xor_e': [0xAB], 'xor_h': [0xAC], 'xor_l': [0xAD], 'xor_(hl)': [0xAE], 'xor_a': [0xAF],
            'or_b': [0xB0], 'or_c': [0xB1], 'or_d': [0xB2], 'or_e': [0xB3], 'or_h': [0xB4], 'or_l': [0xB5], 'or_(hl)': [0xB6], 'or_a': [0xB7],
            'cp_b': [0xB8], 'cp_c': [0xB9], 'cp_d': [0xBA], 'cp_e': [0xBB], 'cp_h': [0xBC], 'cp_l': [0xBD], 'cp_(hl)': [0xBE], 'cp_a': [0xBF],
            'ret_nz': [0xC0], 'pop_bc': [0xC1], 'jp_nz,imm16': [0xC2], 'jp_imm16': [0xC3], 'call_nz,imm16': [0xC4], 'push_bc': [0xC5], 'add_a,imm8': [0xC6], 'rst_00h': [0xC7],
            'ret_z': [0xC8], 'ret': [0xC9], 'jp_z,imm16': [0xCA], 'cb_prefix': [0xCB], 'call_z,imm16': [0xCC], 'call_imm16': [0xCD], 'adc_a,imm8': [0xCE], 'rst_08h': [0xCF],
            'ret_nc': [0xD0], 'pop_de': [0xD1], 'jp_nc,imm16': [0xD2], 'out_(imm8),a': [0xD3], 'call_nc,imm16': [0xD4], 'push_de': [0xD5], 'sub_imm8': [0xD6], 'rst_10h': [0xD7],
            'ret_c': [0xD8], 'exx': [0xD9], 'jp_c,imm16': [0xDA], 'in_a,(imm8)': [0xDB], 'call_c,imm16': [0xDC], 'dd_prefix': [0xDD], 'sbc_a,imm8': [0xDE], 'rst_18h': [0xDF],
            'ret_po': [0xE0], 'pop_hl': [0xE1], 'jp_po,imm16': [0xE2], 'ex_(sp),hl': [0xE3], 'call_po,imm16': [0xE4], 'push_hl': [0xE5], 'and_imm8': [0xE6], 'rst_20h': [0xE7],
            'ret_pe': [0xE8], 'jp_(hl)': [0xE9], 'jp_pe,imm16': [0xEA], 'ex_de,hl': [0xEB], 'call_pe,imm16': [0xEC], 'ed_prefix': [0xED], 'xor_imm8': [0xEE], 'rst_28h': [0xEF],
            'ret_p': [0xF0], 'pop_af': [0xF1], 'jp_p,imm16': [0xF2], 'di': [0xF3], 'call_p,imm16': [0xF4], 'push_af': [0xF5], 'or_imm8': [0xF6], 'rst_30h': [0xF7],
            'ret_m': [0xF8], 'ld_sp,hl': [0xF9], 'jp_m,imm16': [0xFA], 'ei': [0xFB], 'call_m,imm16': [0xFC], 'fd_prefix': [0xFD], 'cp_imm8': [0xFE], 'rst_38h': [0xFF],
            
            // Enhanced RST instructions
            'rst_0': [0xC7], 'rst_8': [0xCF], 'rst_16': [0xD7], 'rst_24': [0xDF], 'rst_32': [0xE7], 'rst_40': [0xEF], 'rst_48': [0xF7], 'rst_56': [0xFF],
            
            // ED prefix opcodes (complete set)
            'in_b,(c)': [0xED, 0x40], 'out_(c),b': [0xED, 0x41], 'sbc_hl,bc': [0xED, 0x42], 'ld_(imm16),bc': [0xED, 0x43], 'neg': [0xED, 0x44], 'retn': [0xED, 0x45], 'im_0': [0xED, 0x46], 'ld_i,a': [0xED, 0x47],
            'in_c,(c)': [0xED, 0x48], 'out_(c),c': [0xED, 0x49], 'adc_hl,bc': [0xED, 0x4A], 'ld_bc,(imm16)': [0xED, 0x4B], 'neg_undoc1': [0xED, 0x4C], 'reti': [0xED, 0x4D], 'im_0/1': [0xED, 0x4E], 'ld_r,a': [0xED, 0x4F],
            'in_d,(c)': [0xED, 0x50], 'out_(c),d': [0xED, 0x51], 'sbc_hl,de': [0xED, 0x52], 'ld_(imm16),de': [0xED, 0x53], 'neg_undoc2': [0xED, 0x54], 'retn_undoc1': [0xED, 0x55], 'im_1': [0xED, 0x56], 'ld_a,i': [0xED, 0x57],
            'in_e,(c)': [0xED, 0x58], 'out_(c),e': [0xED, 0x59], 'adc_hl,de': [0xED, 0x5A], 'ld_de,(imm16)': [0xED, 0x5B], 'neg_undoc3': [0xED, 0x5C], 'reti_undoc': [0xED, 0x5D], 'im_2': [0xED, 0x5E], 'ld_a,r': [0xED, 0x5F],
            'in_h,(c)': [0xED, 0x60], 'out_(c),h': [0xED, 0x61], 'sbc_hl,hl': [0xED, 0x62], 'ld_(imm16),hl_alt': [0xED, 0x63], 'neg_undoc4': [0xED, 0x64], 'retn_undoc2': [0xED, 0x65], 'im_0_alt': [0xED, 0x66], 'rrd': [0xED, 0x67],
            'in_l,(c)': [0xED, 0x68], 'out_(c),l': [0xED, 0x69], 'adc_hl,hl': [0xED, 0x6A], 'ld_hl,(imm16)_alt': [0xED, 0x6B], 'neg_undoc5': [0xED, 0x6C], 'retn_undoc3': [0xED, 0x6D], 'im_0/1_alt': [0xED, 0x6E], 'rld': [0xED, 0x6F],
            'in_(c)': [0xED, 0x70], 'out_(c),0': [0xED, 0x71], 'sbc_hl,sp': [0xED, 0x72], 'ld_(imm16),sp': [0xED, 0x73], 'neg_undoc6': [0xED, 0x74], 'retn_undoc4': [0xED, 0x75], 'im_1_alt': [0xED, 0x76], 'nop_ed1': [0xED, 0x77],
            'in_a,(c)': [0xED, 0x78], 'out_(c),a': [0xED, 0x79], 'adc_hl,sp': [0xED, 0x7A], 'ld_sp,(imm16)': [0xED, 0x7B], 'neg_undoc7': [0xED, 0x7C], 'reti_undoc2': [0xED, 0x7D], 'im_2_alt': [0xED, 0x7E], 'nop_ed2': [0xED, 0x7F],
            'ldi': [0xED, 0xA0], 'cpi': [0xED, 0xA1], 'ini': [0xED, 0xA2], 'outi': [0xED, 0xA3],
            'ldd': [0xED, 0xA8], 'cpd': [0xED, 0xA9], 'ind': [0xED, 0xAA], 'outd': [0xED, 0xAB],
            'ldir': [0xED, 0xB0], 'cpir': [0xED, 0xB1], 'inir': [0xED, 0xB2], 'otir': [0xED, 0xB3],
            'lddr': [0xED, 0xB8], 'cpdr': [0xED, 0xB9], 'indr': [0xED, 0xBA], 'otdr': [0xED, 0xBB],
            
            // CB prefix opcodes - Rotate and shift instructions
            'rlc_b': [0xCB, 0x00], 'rlc_c': [0xCB, 0x01], 'rlc_d': [0xCB, 0x02], 'rlc_e': [0xCB, 0x03], 'rlc_h': [0xCB, 0x04], 'rlc_l': [0xCB, 0x05], 'rlc_(hl)': [0xCB, 0x06], 'rlc_a': [0xCB, 0x07],
            'rrc_b': [0xCB, 0x08], 'rrc_c': [0xCB, 0x09], 'rrc_d': [0xCB, 0x0A], 'rrc_e': [0xCB, 0x0B], 'rrc_h': [0xCB, 0x0C], 'rrc_l': [0xCB, 0x0D], 'rrc_(hl)': [0xCB, 0x0E], 'rrc_a': [0xCB, 0x0F],
            'rl_b': [0xCB, 0x10], 'rl_c': [0xCB, 0x11], 'rl_d': [0xCB, 0x12], 'rl_e': [0xCB, 0x13], 'rl_h': [0xCB, 0x14], 'rl_l': [0xCB, 0x15], 'rl_(hl)': [0xCB, 0x16], 'rl_a': [0xCB, 0x17],
            'rr_b': [0xCB, 0x18], 'rr_c': [0xCB, 0x19], 'rr_d': [0xCB, 0x1A], 'rr_e': [0xCB, 0x1B], 'rr_h': [0xCB, 0x1C], 'rr_l': [0xCB, 0x1D], 'rr_(hl)': [0xCB, 0x1E], 'rr_a': [0xCB, 0x1F],
            'sla_b': [0xCB, 0x20], 'sla_c': [0xCB, 0x21], 'sla_d': [0xCB, 0x22], 'sla_e': [0xCB, 0x23], 'sla_h': [0xCB, 0x24], 'sla_l': [0xCB, 0x25], 'sla_(hl)': [0xCB, 0x26], 'sla_a': [0xCB, 0x27],
            'sra_b': [0xCB, 0x28], 'sra_c': [0xCB, 0x29], 'sra_d': [0xCB, 0x2A], 'sra_e': [0xCB, 0x2B], 'sra_h': [0xCB, 0x2C], 'sra_l': [0xCB, 0x2D], 'sra_(hl)': [0xCB, 0x2E], 'sra_a': [0xCB, 0x2F],
            'sll_b': [0xCB, 0x30], 'sll_c': [0xCB, 0x31], 'sll_d': [0xCB, 0x32], 'sll_e': [0xCB, 0x33], 'sll_h': [0xCB, 0x34], 'sll_l': [0xCB, 0x35], 'sll_(hl)': [0xCB, 0x36], 'sll_a': [0xCB, 0x37],
            'srl_b': [0xCB, 0x38], 'srl_c': [0xCB, 0x39], 'srl_d': [0xCB, 0x3A], 'srl_e': [0xCB, 0x3B], 'srl_h': [0xCB, 0x3C], 'srl_l': [0xCB, 0x3D], 'srl_(hl)': [0xCB, 0x3E], 'srl_a': [0xCB, 0x3F],
            
            // CB prefix - Bit test instructions
            'bit_0,b': [0xCB, 0x40], 'bit_0,c': [0xCB, 0x41], 'bit_0,d': [0xCB, 0x42], 'bit_0,e': [0xCB, 0x43], 'bit_0,h': [0xCB, 0x44], 'bit_0,l': [0xCB, 0x45], 'bit_0,(hl)': [0xCB, 0x46], 'bit_0,a': [0xCB, 0x47],
            'bit_1,b': [0xCB, 0x48], 'bit_1,c': [0xCB, 0x49], 'bit_1,d': [0xCB, 0x4A], 'bit_1,e': [0xCB, 0x4B], 'bit_1,h': [0xCB, 0x4C], 'bit_1,l': [0xCB, 0x4D], 'bit_1,(hl)': [0xCB, 0x4E], 'bit_1,a': [0xCB, 0x4F],
            'bit_2,b': [0xCB, 0x50], 'bit_2,c': [0xCB, 0x51], 'bit_2,d': [0xCB, 0x52], 'bit_2,e': [0xCB, 0x53], 'bit_2,h': [0xCB, 0x54], 'bit_2,l': [0xCB, 0x55], 'bit_2,(hl)': [0xCB, 0x56], 'bit_2,a': [0xCB, 0x57],
            'bit_3,b': [0xCB, 0x58], 'bit_3,c': [0xCB, 0x59], 'bit_3,d': [0xCB, 0x5A], 'bit_3,e': [0xCB, 0x5B], 'bit_3,h': [0xCB, 0x5C], 'bit_3,l': [0xCB, 0x5D], 'bit_3,(hl)': [0xCB, 0x5E], 'bit_3,a': [0xCB, 0x5F],
            'bit_4,b': [0xCB, 0x60], 'bit_4,c': [0xCB, 0x61], 'bit_4,d': [0xCB, 0x62], 'bit_4,e': [0xCB, 0x63], 'bit_4,h': [0xCB, 0x64], 'bit_4,l': [0xCB, 0x65], 'bit_4,(hl)': [0xCB, 0x66], 'bit_4,a': [0xCB, 0x67],
            'bit_5,b': [0xCB, 0x68], 'bit_5,c': [0xCB, 0x69], 'bit_5,d': [0xCB, 0x6A], 'bit_5,e': [0xCB, 0x6B], 'bit_5,h': [0xCB, 0x6C], 'bit_5,l': [0xCB, 0x6D], 'bit_5,(hl)': [0xCB, 0x6E], 'bit_5,a': [0xCB, 0x6F],
            'bit_6,b': [0xCB, 0x70], 'bit_6,c': [0xCB, 0x71], 'bit_6,d': [0xCB, 0x72], 'bit_6,e': [0xCB, 0x73], 'bit_6,h': [0xCB, 0x74], 'bit_6,l': [0xCB, 0x75], 'bit_6,(hl)': [0xCB, 0x76], 'bit_6,a': [0xCB, 0x77],
            'bit_7,b': [0xCB, 0x78], 'bit_7,c': [0xCB, 0x79], 'bit_7,d': [0xCB, 0x7A], 'bit_7,e': [0xCB, 0x7B], 'bit_7,h': [0xCB, 0x7C], 'bit_7,l': [0xCB, 0x7D], 'bit_7,(hl)': [0xCB, 0x7E], 'bit_7,a': [0xCB, 0x7F],
            
            // CB prefix - Bit reset instructions
            'res_0,b': [0xCB, 0x80], 'res_0,c': [0xCB, 0x81], 'res_0,d': [0xCB, 0x82], 'res_0,e': [0xCB, 0x83], 'res_0,h': [0xCB, 0x84], 'res_0,l': [0xCB, 0x85], 'res_0,(hl)': [0xCB, 0x86], 'res_0,a': [0xCB, 0x87],
            'res_1,b': [0xCB, 0x88], 'res_1,c': [0xCB, 0x89], 'res_1,d': [0xCB, 0x8A], 'res_1,e': [0xCB, 0x8B], 'res_1,h': [0xCB, 0x8C], 'res_1,l': [0xCB, 0x8D], 'res_1,(hl)': [0xCB, 0x8E], 'res_1,a': [0xCB, 0x8F],
            'res_2,b': [0xCB, 0x90], 'res_2,c': [0xCB, 0x91], 'res_2,d': [0xCB, 0x92], 'res_2,e': [0xCB, 0x93], 'res_2,h': [0xCB, 0x94], 'res_2,l': [0xCB, 0x95], 'res_2,(hl)': [0xCB, 0x96], 'res_2,a': [0xCB, 0x97],
            'res_3,b': [0xCB, 0x98], 'res_3,c': [0xCB, 0x99], 'res_3,d': [0xCB, 0x9A], 'res_3,e': [0xCB, 0x9B], 'res_3,h': [0xCB, 0x9C], 'res_3,l': [0xCB, 0x9D], 'res_3,(hl)': [0xCB, 0x9E], 'res_3,a': [0xCB, 0x9F],
            'res_4,b': [0xCB, 0xA0], 'res_4,c': [0xCB, 0xA1], 'res_4,d': [0xCB, 0xA2], 'res_4,e': [0xCB, 0xA3], 'res_4,h': [0xCB, 0xA4], 'res_4,l': [0xCB, 0xA5], 'res_4,(hl)': [0xCB, 0xA6], 'res_4,a': [0xCB, 0xA7],
            'res_5,b': [0xCB, 0xA8], 'res_5,c': [0xCB, 0xA9], 'res_5,d': [0xCB, 0xAA], 'res_5,e': [0xCB, 0xAB], 'res_5,h': [0xCB, 0xAC], 'res_5,l': [0xCB, 0xAD], 'res_5,(hl)': [0xCB, 0xAE], 'res_5,a': [0xCB, 0xAF],
            'res_6,b': [0xCB, 0xB0], 'res_6,c': [0xCB, 0xB1], 'res_6,d': [0xCB, 0xB2], 'res_6,e': [0xCB, 0xB3], 'res_6,h': [0xCB, 0xB4], 'res_6,l': [0xCB, 0xB5], 'res_6,(hl)': [0xCB, 0xB6], 'res_6,a': [0xCB, 0xB7],
            'res_7,b': [0xCB, 0xB8], 'res_7,c': [0xCB, 0xB9], 'res_7,d': [0xCB, 0xBA], 'res_7,e': [0xCB, 0xBB], 'res_7,h': [0xCB, 0xBC], 'res_7,l': [0xCB, 0xBD], 'res_7,(hl)': [0xCB, 0xBE], 'res_7,a': [0xCB, 0xBF],
            
            // CB prefix - Bit set instructions
            'set_0,b': [0xCB, 0xC0], 'set_0,c': [0xCB, 0xC1], 'set_0,d': [0xCB, 0xC2], 'set_0,e': [0xCB, 0xC3], 'set_0,h': [0xCB, 0xC4], 'set_0,l': [0xCB, 0xC5], 'set_0,(hl)': [0xCB, 0xC6], 'set_0,a': [0xCB, 0xC7],
            'set_1,b': [0xCB, 0xC8], 'set_1,c': [0xCB, 0xC9], 'set_1,d': [0xCB, 0xCA], 'set_1,e': [0xCB, 0xCB], 'set_1,h': [0xCB, 0xCC], 'set_1,l': [0xCB, 0xCD], 'set_1,(hl)': [0xCB, 0xCE], 'set_1,a': [0xCB, 0xCF],
            'set_2,b': [0xCB, 0xD0], 'set_2,c': [0xCB, 0xD1], 'set_2,d': [0xCB, 0xD2], 'set_2,e': [0xCB, 0xD3], 'set_2,h': [0xCB, 0xD4], 'set_2,l': [0xCB, 0xD5], 'set_2,(hl)': [0xCB, 0xD6], 'set_2,a': [0xCB, 0xD7],
            'set_3,b': [0xCB, 0xD8], 'set_3,c': [0xCB, 0xD9], 'set_3,d': [0xCB, 0xDA], 'set_3,e': [0xCB, 0xDB], 'set_3,h': [0xCB, 0xDC], 'set_3,l': [0xCB, 0xDD], 'set_3,(hl)': [0xCB, 0xDE], 'set_3,a': [0xCB, 0xDF],
            'set_4,b': [0xCB, 0xE0], 'set_4,c': [0xCB, 0xE1], 'set_4,d': [0xCB, 0xE2], 'set_4,e': [0xCB, 0xE3], 'set_4,h': [0xCB, 0xE4], 'set_4,l': [0xCB, 0xE5], 'set_4,(hl)': [0xCB, 0xE6], 'set_4,a': [0xCB, 0xE7],
            'set_5,b': [0xCB, 0xE8], 'set_5,c': [0xCB, 0xE9], 'set_5,d': [0xCB, 0xEA], 'set_5,e': [0xCB, 0xEB], 'set_5,h': [0xCB, 0xEC], 'set_5,l': [0xCB, 0xED], 'set_5,(hl)': [0xCB, 0xEE], 'set_5,a': [0xCB, 0xEF],
            'set_6,b': [0xCB, 0xF0], 'set_6,c': [0xCB, 0xF1], 'set_6,d': [0xCB, 0xF2], 'set_6,e': [0xCB, 0xF3], 'set_6,h': [0xCB, 0xF4], 'set_6,l': [0xCB, 0xF5], 'set_6,(hl)': [0xCB, 0xF6], 'set_6,a': [0xCB, 0xF7],
            'set_7,b': [0xCB, 0xF8], 'set_7,c': [0xCB, 0xF9], 'set_7,d': [0xCB, 0xFA], 'set_7,e': [0xCB, 0xFB], 'set_7,h': [0xCB, 0xFC], 'set_7,l': [0xCB, 0xFD], 'set_7,(hl)': [0xCB, 0xFE], 'set_7,a': [0xCB, 0xFF],
            
            // DD prefix opcodes - IX operations
            'add_ix,bc': [0xDD, 0x09], 'add_ix,de': [0xDD, 0x19], 'ld_ix,imm16': [0xDD, 0x21], 'ld_(imm16),ix': [0xDD, 0x22], 
            'inc_ix': [0xDD, 0x23], 'inc_ixh': [0xDD, 0x24], 'dec_ixh': [0xDD, 0x25], 'ld_ixh,imm8': [0xDD, 0x26], 
            'add_ix,ix': [0xDD, 0x29], 'ld_ix,(imm16)': [0xDD, 0x2A], 'dec_ix': [0xDD, 0x2B], 'inc_ixl': [0xDD, 0x2C], 
            'dec_ixl': [0xDD, 0x2D], 'ld_ixl,imm8': [0xDD, 0x2E], 'inc_(ix+offset)': [0xDD, 0x34], 'dec_(ix+offset)': [0xDD, 0x35],
            'ld_(ix+offset),imm8': [0xDD, 0x36], 'add_ix,sp': [0xDD, 0x39], 'ld_b,ixh': [0xDD, 0x44], 'ld_b,ixl': [0xDD, 0x45], 
            'ld_b,(ix+offset)': [0xDD, 0x46], 'ld_c,ixh': [0xDD, 0x4C], 'ld_c,ixl': [0xDD, 0x4D], 'ld_c,(ix+offset)': [0xDD, 0x4E],
            'ld_d,ixh': [0xDD, 0x54], 'ld_d,ixl': [0xDD, 0x55], 'ld_d,(ix+offset)': [0xDD, 0x56], 'ld_e,ixh': [0xDD, 0x5C], 
            'ld_e,ixl': [0xDD, 0x5D], 'ld_e,(ix+offset)': [0xDD, 0x5E], 'ld_ixh,b': [0xDD, 0x60], 'ld_ixh,c': [0xDD, 0x61], 
            'ld_ixh,d': [0xDD, 0x62], 'ld_ixh,e': [0xDD, 0x63], 'ld_ixh,ixh': [0xDD, 0x64], 'ld_ixh,ixl': [0xDD, 0x65], 
            'ld_h,(ix+offset)': [0xDD, 0x66], 'ld_ixh,a': [0xDD, 0x67], 'ld_ixl,b': [0xDD, 0x68], 'ld_ixl,c': [0xDD, 0x69], 
            'ld_ixl,d': [0xDD, 0x6A], 'ld_ixl,e': [0xDD, 0x6B], 'ld_ixl,ixh': [0xDD, 0x6C], 'ld_ixl,ixl': [0xDD, 0x6D], 
            'ld_l,(ix+offset)': [0xDD, 0x6E], 'ld_ixl,a': [0xDD, 0x6F], 'ld_(ix+offset),b': [0xDD, 0x70], 'ld_(ix+offset),c': [0xDD, 0x71],
            'ld_(ix+offset),d': [0xDD, 0x72], 'ld_(ix+offset),e': [0xDD, 0x73], 'ld_(ix+offset),h': [0xDD, 0x74], 'ld_(ix+offset),l': [0xDD, 0x75],
            'ld_(ix+offset),a': [0xDD, 0x77], 'ld_a,ixh': [0xDD, 0x7C], 'ld_a,ixl': [0xDD, 0x7D], 'ld_a,(ix+offset)': [0xDD, 0x7E],
            'add_a,ixh': [0xDD, 0x84], 'add_a,ixl': [0xDD, 0x85], 'add_a,(ix+offset)': [0xDD, 0x86], 'adc_a,ixh': [0xDD, 0x8C], 
            'adc_a,ixl': [0xDD, 0x8D], 'adc_a,(ix+offset)': [0xDD, 0x8E], 'sub_ixh': [0xDD, 0x94], 'sub_ixl': [0xDD, 0x95], 
            'sub_(ix+offset)': [0xDD, 0x96], 'sbc_a,ixh': [0xDD, 0x9C], 'sbc_a,ixl': [0xDD, 0x9D], 'sbc_a,(ix+offset)': [0xDD, 0x9E],
            'and_ixh': [0xDD, 0xA4], 'and_ixl': [0xDD, 0xA5], 'and_(ix+offset)': [0xDD, 0xA6], 'xor_ixh': [0xDD, 0xAC], 
            'xor_ixl': [0xDD, 0xAD], 'xor_(ix+offset)': [0xDD, 0xAE], 'or_ixh': [0xDD, 0xB4], 'or_ixl': [0xDD, 0xB5], 
            'or_(ix+offset)': [0xDD, 0xB6], 'cp_ixh': [0xDD, 0xBC], 'cp_ixl': [0xDD, 0xBD], 'cp_(ix+offset)': [0xDD, 0xBE],
            'pop_ix': [0xDD, 0xE1], 'ex_(sp),ix': [0xDD, 0xE3], 'push_ix': [0xDD, 0xE5], 'jp_(ix)': [0xDD, 0xE9], 'ld_sp,ix': [0xDD, 0xF9],
            
            // FD prefix opcodes - IY operations
            'add_iy,bc': [0xFD, 0x09], 'add_iy,de': [0xFD, 0x19], 'ld_iy,imm16': [0xFD, 0x21], 'ld_(imm16),iy': [0xFD, 0x22], 
            'inc_iy': [0xFD, 0x23], 'inc_iyh': [0xFD, 0x24], 'dec_iyh': [0xFD, 0x25], 'ld_iyh,imm8': [0xFD, 0x26],
            'add_iy,iy': [0xFD, 0x29], 'ld_iy,(imm16)': [0xFD, 0x2A], 'dec_iy': [0xFD, 0x2B], 'inc_iyl': [0xFD, 0x2C], 
            'dec_iyl': [0xFD, 0x2D], 'ld_iyl,imm8': [0xFD, 0x2E], 'inc_(iy+offset)': [0xFD, 0x34], 'dec_(iy+offset)': [0xFD, 0x35],
            'ld_(iy+offset),imm8': [0xFD, 0x36], 'add_iy,sp': [0xFD, 0x39], 'ld_b,iyh': [0xFD, 0x44], 'ld_b,iyl': [0xFD, 0x45], 
            'ld_b,(iy+offset)': [0xFD, 0x46], 'ld_c,iyh': [0xFD, 0x4C], 'ld_c,iyl': [0xFD, 0x4D], 'ld_c,(iy+offset)': [0xFD, 0x4E],
            'ld_d,iyh': [0xFD, 0x54], 'ld_d,iyl': [0xFD, 0x55], 'ld_d,(iy+offset)': [0xFD, 0x56], 'ld_e,iyh': [0xFD, 0x5C], 
            'ld_e,iyl': [0xFD, 0x5D], 'ld_e,(iy+offset)': [0xFD, 0x5E], 'ld_iyh,b': [0xFD, 0x60], 'ld_iyh,c': [0xFD, 0x61], 
            'ld_iyh,d': [0xFD, 0x62], 'ld_iyh,e': [0xFD, 0x63], 'ld_iyh,iyh': [0xFD, 0x64], 'ld_iyh,iyl': [0xFD, 0x65], 
            'ld_h,(iy+offset)': [0xFD, 0x66], 'ld_iyh,a': [0xFD, 0x67], 'ld_iyl,b': [0xFD, 0x68], 'ld_iyl,c': [0xFD, 0x69], 
            'ld_iyl,d': [0xFD, 0x6A], 'ld_iyl,e': [0xFD, 0x6B], 'ld_iyl,iyh': [0xFD, 0x6C], 'ld_iyl,iyl': [0xFD, 0x6D], 
            'ld_l,(iy+offset)': [0xFD, 0x6E], 'ld_iyl,a': [0xFD, 0x6F], 'ld_(iy+offset),b': [0xFD, 0x70], 'ld_(iy+offset),c': [0xFD, 0x71],
            'ld_(iy+offset),d': [0xFD, 0x72], 'ld_(iy+offset),e': [0xFD, 0x73], 'ld_(iy+offset),h': [0xFD, 0x74], 'ld_(iy+offset),l': [0xFD, 0x75],
            'ld_(iy+offset),a': [0xFD, 0x77], 'ld_a,iyh': [0xFD, 0x7C], 'ld_a,iyl': [0xFD, 0x7D], 'ld_a,(iy+offset)': [0xFD, 0x7E],
            'add_a,iyh': [0xFD, 0x84], 'add_a,iyl': [0xFD, 0x85], 'add_a,(iy+offset)': [0xFD, 0x86], 'adc_a,iyh': [0xFD, 0x8C], 
            'adc_a,iyl': [0xFD, 0x8D], 'adc_a,(iy+offset)': [0xFD, 0x8E], 'sub_iyh': [0xFD, 0x94], 'sub_iyl': [0xFD, 0x95], 
            'sub_(iy+offset)': [0xFD, 0x96], 'sbc_a,iyh': [0xFD, 0x9C], 'sbc_a,iyl': [0xFD, 0x9D], 'sbc_a,(iy+offset)': [0xFD, 0x9E],
            'and_iyh': [0xFD, 0xA4], 'and_iyl': [0xFD, 0xA5], 'and_(iy+offset)': [0xFD, 0xA6], 'xor_iyh': [0xFD, 0xAC], 
            'xor_iyl': [0xFD, 0xAD], 'xor_(iy+offset)': [0xFD, 0xAE], 'or_iyh': [0xFD, 0xB4], 'or_iyl': [0xFD, 0xB5], 
            'or_(iy+offset)': [0xFD, 0xB6], 'cp_iyh': [0xFD, 0xBC], 'cp_iyl': [0xFD, 0xBD], 'cp_(iy+offset)': [0xFD, 0xBE],
            'pop_iy': [0xFD, 0xE1], 'ex_(sp),iy': [0xFD, 0xE3], 'push_iy': [0xFD, 0xE5], 'jp_(iy)': [0xFD, 0xE9], 'ld_sp,iy': [0xFD, 0xF9],
        };

        // --- Enhanced Assembler Class ---
        class Assembler {
            constructor(files) {
                this.files = files;
                this.macroTable = {};
                this.symbolTable = {};
                this.constantTable = {}; // Separate table for SET/EQU values
                this.fileMap = [];
                this.symbolInfo = {};
                this.pc = 0;
                this.output = [];
                this.firstOrg = null;                
                this.currentPass = 0;
                this.currentFile = '';
                this.currentLine = 0;
                this.currentInstruction = null;
                this.fileStartAddress = 0;
                this.compilationStats = {
                    totalSize: 0,
                    codeSize: 0,
                    dataSize: 0,
                    symbolCount: 0,
                    fileCount: 0
                };
                this.conditionalStack = []; // For nested IF/ENDIF
                this.tempSymbolCounters = {
                    named: 0,
                    plus: 0,
                    minus: 0,
                    slash: 0
                };
                this.lastNonTempSymbol = '';
                this.numberParser = new NumberParser();
            }

            buildImage({ mode = 'range', base = null, size = null, fill = 0xFF } = {}) {
                const src = new Uint8Array(this.output);

                // If no packaging requested, return raw output
                if (!mode && !base && !size) {
                    return src;
                }

                // Derive a sensible window if the caller didn't specify one.
                const first = (this.firstOrg !== null) ? this.firstOrg : 0;
                const last  = src.length; // because you pad this.output to absolute PC

                if (mode !== 'range') { // 'auto' or anything else â†’ derive from ORGs
                    if (base == null) base = first;
                    if (size == null) size = Math.max(0, last - base);
                } else {
                // range mode: require base/size; if missing, fall back to first/last
                    if (base == null) base = first;
                    if (size == null) size = Math.max(0, last - base);
                }

                const out = new Uint8Array(size).fill(fill & 0xFF);

                // Copy the intersection of [base, base+size) from src into out[0..size)
                const start = Math.max(0, base);
                const end   = Math.min(src.length, base + size);
                if (end > start) {
                    out.set(src.subarray(start, end), 0);
                }
                return out;
            }


            async assemble(mainFile) {
                try {
                    this.currentFile = mainFile;
                    this.currentPass = 1;
                    log(`--- Pass 1: Conditional processing and macro expansion for ${mainFile} ---`);
                    const pass1_source = await this.expandMacrosAndConditionals(mainFile);
                    
                    const lexer = new Lexer(pass1_source);
                    let tokens = lexer.tokenize();
                    
                    // CPU directive is optional - default to Z80 if not specified
                    const cpuDirective = tokens.find(t => t.name === 'CPU');
                    if (cpuDirective && cpuDirective.operands[0].value.toUpperCase() !== 'Z80') {
                        throw new Error("Only Z80 CPU is supported (CPU directive found but not set to 'Z80')");
                    }
                    // If no CPU directive, we default to Z80 (zmac-compatible behavior)
                    
                    const fnameDirective = tokens.find(t => t.name === 'FNAME');
                    if (fnameDirective) {
                        outputFilename = fnameDirective.operands[0].value;
                    }

                    this.currentPass = 2;
                    log('--- Pass 2: Building symbol table ---');
                    this.buildSymbolTable(tokens);
                    
                    this.currentPass = 3;
                    log('--- Pass 3: Generating binary code ---');
                    this.generateCode(tokens);

                    // --- Packaging step: Platform-driven configuration ---
                    const platformConfig = getPlatformConfig();
                    const cfg = platformConfig.packager || { mode: null };

                    if (cfg.mode) {
                        compiledBinary = this.buildImage(cfg);
                        log(`Packaged for ${document.getElementById('target-platform').value}: ${platformConfig.description}`, 'info');
                    } else {
                        compiledBinary = this.buildImage();
                        log('Generated raw binary (no packaging)', 'info');
                    }

                    // Platform-specific validation
                    if (platformConfig.validateHeader === 'coleco') {
                        const headerInfo = validateColecoHeader(compiledBinary);
                        if (headerInfo.valid) {
                            log(`Valid ColecoVision ROM: ${headerInfo.usesDefaultScreen ? 'With' : 'Without'} default title screen`, 'success');
                        }
                    }

                    // --- Size metrics calculation ---
                    const src = new Uint8Array(this.output);
                    
                    if (cfg.mode) {
                        // Packaged binary metrics
                        const base = cfg.base || (this.firstOrg ?? 0);
                        const size = cfg.size || Math.max(0, src.length - base);
                        const end = Math.min(src.length, base + size);
                        const payloadUsed = Math.max(0, end - base);
                        const windowFree = Math.max(0, size - payloadUsed);
                        
                        this.compilationStats.totalSize = compiledBinary.length;
                        this.compilationStats.windowBase = base;
                        this.compilationStats.windowSize = size;
                        this.compilationStats.payloadUsed = payloadUsed;
                        this.compilationStats.windowFree = windowFree;
                        
                        log(
                            `Assembly successful! ROM window ${base.toString(16).toUpperCase()}..${(base+size-1).toString(16).toUpperCase()} | ` +
                            `payload used: ${payloadUsed} bytes | free: ${windowFree} bytes | packaged: ${compiledBinary.length} bytes.`,
                            'success'
                        );
                    } else {
                        // Raw binary metrics
                        this.compilationStats.totalSize = compiledBinary.length;
                        this.compilationStats.rawSize = compiledBinary.length;
                        
                        log(
                            `Assembly successful! Raw binary: ${compiledBinary.length} bytes | ` +
                            `Range: ${(this.firstOrg ?? 0).toString(16).toUpperCase()}-${(src.length-1).toString(16).toUpperCase()}`,
                            'success'
                        );
                    }

                    // Common stats
                    this.compilationStats.symbolCount = Object.keys(this.symbolInfo).length;
                    this.compilationStats.fileCount = this.fileMap.length;
                    
                    this.displaySymbolTable();
                    return compiledBinary;

                } catch (e) {
                    log(`Assembly failed on pass ${this.currentPass} in file '${this.currentFile}': ${e.message}`, 'error');
                    console.error(e);
                    return null;
                }
            }
            
            async expandMacrosAndConditionals(filename, visited = new Set()) {
                if (visited.has(filename)) throw new Error(`Circular include detected: ${filename}`);
                visited.add(filename);

                let source = this.files[filename];
                if (!source) throw new Error(`File not found: ${filename}`);
                if (source instanceof Uint8Array) source = new TextDecoder().decode(source);

                const lines = source.split('\n');
                let expandedSource = '';
                let inMacro = false;
                let currentMacro = null;
                let conditionalStack = [];
                let currentConditionState = true;

                for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
                    const line = lines[lineIdx];
                    const trimmed = line.trim();
                    const parts = trimmed.split(/\s+/);
                    const mnemonic = parts.length > 0 ? parts[0].toLowerCase() : '';

                    // Skip lines if we're in a false conditional branch
                    if (!currentConditionState && !['if', 'else', 'elif', 'endif'].includes(mnemonic)) {
                        continue;
                    }

                    if (inMacro) {
                        if (mnemonic === 'endm') {
                            inMacro = false;
                            this.macroTable[currentMacro.name] = currentMacro;
                            log(`Defined macro: ${currentMacro.name}`);
                            currentMacro = null;
                        } else {
                            currentMacro.body.push(line);
                        }
                    } else if (mnemonic === 'macro') {
                        inMacro = true;
                        currentMacro = { name: parts[1], params: parts.slice(2).join('').split(','), body: [] };
                    } else if (mnemonic === 'if') {
                        const condExpr = parts.slice(1).join(' ');
                        const condResult = this.evaluateCondition(condExpr);
                        conditionalStack.push({
                            condition: condResult,
                            hasElse: false,
                            line: lineIdx + 1
                        });
                        currentConditionState = this.calculateCurrentConditionState(conditionalStack);
                    } else if (mnemonic === 'else') {
                        if (conditionalStack.length === 0) {
                            throw new Error(`ELSE without matching IF at line ${lineIdx + 1}`);
                        }
                        const current = conditionalStack[conditionalStack.length - 1];
                        if (current.hasElse) {
                            throw new Error(`Multiple ELSE clauses for IF at line ${current.line}`);
                        }
                        current.hasElse = true;
                        current.condition = !current.condition;
                        currentConditionState = this.calculateCurrentConditionState(conditionalStack);
                    } else if (mnemonic === 'elif') {
                        if (conditionalStack.length === 0) {
                            throw new Error(`ELIF without matching IF at line ${lineIdx + 1}`);
                        }
                        const condExpr = parts.slice(1).join(' ');
                        const condResult = this.evaluateCondition(condExpr);
                        const current = conditionalStack[conditionalStack.length - 1];
                        current.condition = condResult;
                        currentConditionState = this.calculateCurrentConditionState(conditionalStack);
                    } else if (mnemonic === 'endif') {
                        if (conditionalStack.length === 0) {
                            throw new Error(`ENDIF without matching IF at line ${lineIdx + 1}`);
                        }
                        conditionalStack.pop();
                        currentConditionState = this.calculateCurrentConditionState(conditionalStack);
                    } else if (mnemonic === 'include') {
                        const includeFile = parts.slice(1).join(' ').replace(/"/g, '');
                        const includedContent = await this.expandMacrosAndConditionals(includeFile, new Set(visited));
                        expandedSource += `; === INCLUDED FILE: ${includeFile} ===\n`;
                        expandedSource += includedContent + '\n';
                        expandedSource += `; === END OF ${includeFile} ===\n`;
                    } else if (this.macroTable[mnemonic]) {
                        const macro = this.macroTable[mnemonic];
                        const args = trimmed.substring(mnemonic.length).split(',').map(s => s.trim());
                        let macroBody = macro.body.join('\n');
                        macro.params.forEach((param, index) => {
                            const regex = new RegExp(`\\b${param.trim()}\\b`, 'g');
                            macroBody = macroBody.replace(regex, args[index] || '');
                        });
                        expandedSource += `; === MACRO EXPANSION: ${mnemonic} ===\n`;
                        expandedSource += macroBody + '\n';
                        expandedSource += `; === END MACRO: ${mnemonic} ===\n`;
                    } else {
                        expandedSource += line + '\n';
                    }
                }
                
                if (inMacro) throw new Error(`Macro definition for ${currentMacro.name} was not closed with ENDM.`);
                if (conditionalStack.length > 0) {
                    throw new Error(`Unclosed IF directive at line ${conditionalStack[0].line}`);
                }
                
                return expandedSource;
            }

            calculateCurrentConditionState(conditionalStack) {
                return conditionalStack.length === 0 || conditionalStack.every(c => c.condition);
            }

            evaluateCondition(expr) {
                try {
                    // Simple condition evaluation
                    // Replace symbols with their values
                    let evalExpr = expr;
                    
                    // Handle defined() function
                    evalExpr = evalExpr.replace(/defined\s*\(\s*([^)]+)\s*\)/g, (match, symbol) => {
                        return (this.constantTable[symbol] !== undefined || this.symbolTable[symbol] !== undefined) ? '1' : '0';
                    });
                    
                    // Replace symbols with their constant values
                    for (const [symbol, value] of Object.entries(this.constantTable)) {
                        const regex = new RegExp(`\\b${symbol}\\b`, 'g');
                        evalExpr = evalExpr.replace(regex, value);
                    }
                    
                    // Try to parse numbers
                    evalExpr = evalExpr.replace(/\$[0-9a-fA-F]+/g, (match) => {
                        return parseInt(match.substring(1), 16).toString();
                    });
                    
                    // Basic expression evaluation
                    const result = new Function(`return ${evalExpr}`)();
                    return Boolean(result);
                } catch (e) {
                    log(`Warning: Could not evaluate condition '${expr}', assuming false`, 'warn');
                    return false;
                }
            }

            processTemporarySymbol(label) {
                if (label.startsWith('$')) {
                    // Named temporary symbol
                    return `__temp_named_${this.tempSymbolCounters.named}_${label.substring(2)}`;
                } else if (label === '+' || label === '-' || label === '/') {
                    // Nameless temporary symbol
                    if (label === '+') {
                        const newLabel = `__temp_plus_${this.tempSymbolCounters.plus}`;
                        this.tempSymbolCounters.plus++;
                        return newLabel;
                    } else if (label === '-') {
                        const newLabel = `__temp_minus_${this.tempSymbolCounters.minus}`;
                        this.tempSymbolCounters.minus++;
                        return newLabel;
                    } else if (label === '/') {
                        const newLabel = `__temp_slash_${this.tempSymbolCounters.slash}`;
                        this.tempSymbolCounters.slash++;
                        return newLabel;
                    }
                } else if (label.startsWith('.')) {
                    // Composed temporary symbol
                    return `${this.lastNonTempSymbol}${label}`;
                }
                return label;
            }

            resolveTemporarySymbolReference(symbol) {
                // Handle references to temporary symbols in expressions
                if (symbol === '+' || symbol === '++' || symbol === '+++') {
                    const lookAhead = symbol.length;
                    // Find the next plus symbol
                    for (let i = this.tempSymbolCounters.plus; i < this.tempSymbolCounters.plus + 10; i++) {
                        const candidate = `__temp_plus_${i}`;
                        if (this.symbolTable[candidate] !== undefined) {
                            return candidate;
                        }
                    }
                } else if (symbol === '-' || symbol === '--' || symbol === '---') {
                    const lookBack = symbol.length;
                    // Find the previous minus symbol
                    for (let i = this.tempSymbolCounters.minus - 1; i >= Math.max(0, this.tempSymbolCounters.minus - 10); i--) {
                        const candidate = `__temp_minus_${i}`;
                        if (this.symbolTable[candidate] !== undefined) {
                            return candidate;
                        }
                    }
                }
                return symbol;
            }

            trackFileStart(filename, address) {
                this.fileStartAddress = address;
                this.currentFile = filename;
            }

            trackFileEnd(filename, address, type = 'code') {
                const size = address - this.fileStartAddress;
                this.fileMap.push({
                    filename: filename,
                    startAddr: this.fileStartAddress,
                    endAddr: address,
                    size: size,
                    type: type
                });
                
                if (type === 'code') {
                    this.compilationStats.codeSize += size;
                } else {
                    this.compilationStats.dataSize += size;
                }
            }

            buildSymbolTable(tokens) {
                this.pc = 0;
                this.symbolTable = {};
                this.constantTable = {};
                this.symbolInfo = {};
                let currentSourceFile = 'main';
                
                for (const token of tokens) {
                    this.currentInstruction = token;
                    this.currentLine = token.lineNumber || 0;
                    
                    try {
                        if (token.label) {
                            const processedLabel = this.processTemporarySymbol(token.label);
                            
                            if (this.symbolTable[processedLabel] !== undefined) {
                               log(`Warning: Redefining label '${processedLabel}' at line ${this.currentLine}`, 'warn');
                            }
                            
                            this.symbolTable[processedLabel] = this.pc;
                            this.symbolInfo[processedLabel] = {
                                address: this.pc,
                                file: currentSourceFile,
                                lineNumber: this.currentLine,
                                type: token instanceof Directive ? 'constant' : 'label',
                                size: 0
                            };
                            
                            // Track last non-temporary symbol for composed temporary symbols
                            if (!token.label.startsWith('.') && !['+', '-', '/'].includes(token.label)) {
                                this.lastNonTempSymbol = processedLabel;
                            }
                        }

                        if (token instanceof Directive) {
                            switch (token.name) {
                                case 'ORG': 
                                    this.pc = this.evaluateExpression(token.operands[0]); 
                                    this.trackFileStart(currentSourceFile, this.pc);
                                    break;
                                case 'EQU':
                                    if (!token.label) throw new Error("EQU directive requires a label.");
                                    const equValue = this.evaluateExpression(token.operands[0]);
                                    const processedEquLabel = this.processTemporarySymbol(token.label);
                                    this.symbolTable[processedEquLabel] = equValue;
                                    this.constantTable[processedEquLabel] = equValue;
                                    this.symbolInfo[processedEquLabel] = {
                                        address: equValue,
                                        file: currentSourceFile,
                                        lineNumber: this.currentLine,
                                        type: 'constant',
                                        size: 0
                                    };
                                    break;
                                case 'EVAL':
                                    if (!token.label) throw new Error(`${token.name} directive requires a label.`);
                                    const setValue = this.evaluateExpression(token.operands[0]);
                                    const processedSetLabel = this.processTemporarySymbol(token.label);
                                    this.constantTable[processedSetLabel] = setValue;
                                    this.symbolInfo[processedSetLabel] = {
                                        address: setValue,
                                        file: currentSourceFile,
                                        lineNumber: this.currentLine,
                                        type: 'variable',
                                        size: 0
                                    };
                                    break;
                                case 'CONSTANT':
                                    // KCPSM-style constant definition
                                    if (token.operands.length < 2) throw new Error("CONSTANT directive requires name and value.");
                                    const constName = token.operands[0].value;
                                    const constValue = this.evaluateExpression(token.operands[1]);
                                    this.constantTable[constName] = constValue;
                                    this.symbolInfo[constName] = {
                                        address: constValue,
                                        file: currentSourceFile,
                                        lineNumber: this.currentLine,
                                        type: 'constant',
                                        size: 0
                                    };
                                    break;
                                case 'DB': case 'DEFB': case 'DEFM': case 'ASCII': case 'TEXT': case 'BYTE':
                                    const dbSize = token.operands.reduce((sum, op) =>
                                        sum + ((op.type === 'string') ? op.value.length : 1), 0);
                                    this.pc += dbSize;
                                    break;
                                case 'DW': case 'DEFW': case 'WORD':
                                    this.pc += token.operands.length * 2;
                                    break;
                                case 'DS': case 'DEFS': 
                                    this.pc += this.evaluateExpression(token.operands[0]); 
                                    break;
                                case 'INCBIN':
                                    const filename = token.operands[0].value;
                                    const fileData = this.findFile(filename);
                                    const incbinStartAddr = this.pc;
                                    this.pc += fileData.length;
                                    // Track binary file inclusion
                                    this.fileMap.push({
                                        filename: filename,
                                        startAddr: incbinStartAddr,
                                        endAddr: this.pc,
                                        size: fileData.length,
                                        type: 'binary'
                                    });
                                    break;
                                case 'RADIX':
                                    this.numberParser.defaultRadix = this.evaluateExpression(token.operands[0]);
                                    break;
                            }
                        } else if (token instanceof Instruction) {
                            const key = this.getOpcodeKey(token);
                            const opcode = Z80_OPCODES[key];
                            if (opcode) {
                                this.pc += opcode.length;
                                if (key.includes('imm8') || key.includes('rel8')) this.pc += 1;
                                if (key.includes('imm16')) this.pc += 2;
                                if (key.includes('offset')) this.pc += 1; // IX/IY offset
                            } else {
                                // Fallback size estimation for unknown opcodes
                                let size = 1;
                                if (token.mnemonic.startsWith('ld')) size++;
                                if (token.operands.some(op => 
                                    op.type === 'immediate' && op.value > 255 ||
                                    op.type === 'symbol' ||
                                    (op.type === 'memory' && (typeof op.value === 'number' || (typeof op.value === 'string' && !['bc','de','hl','sp','c'].includes(op.value.toLowerCase()))))
                                )) size += 1;
                                this.pc += size;
                                log(`Using estimated size ${size} for opcode: ${token.mnemonic} ${token.operands.map(o=>o.value).join(',')} at line ${this.currentLine}`, 'warn');
                            }
                        }
                    } catch (error) {
                        // Add context to the error
                        const contextMsg = `Line ${this.currentLine}: ${token.mnemonic || token.name || 'directive'} - ${error.message}`;
                        throw new Error(contextMsg);
                    }
                }
                
                // Calculate symbol sizes (distance to next symbol)
                const sortedSymbols = Object.keys(this.symbolInfo)
                    .filter(name => this.symbolInfo[name].type === 'label')
                    .sort((a, b) => this.symbolInfo[a].address - this.symbolInfo[b].address);
                
                for (let i = 0; i < sortedSymbols.length - 1; i++) {
                    const currentSym = sortedSymbols[i];
                    const nextSym = sortedSymbols[i + 1];
                    this.symbolInfo[currentSym].size = this.symbolInfo[nextSym].address - this.symbolInfo[currentSym].address;
                }
                
                log('Symbol table built successfully.');
                console.log('Symbol Table:', this.symbolTable);
                console.log('Symbol Info:', this.symbolInfo);
                console.log('File Map:', this.fileMap);
            }

            findFile(filename) {
                if (this.files[filename]) return this.files[filename];
                
                // Try case-insensitive lookup
                const lowercaseFilename = filename.toLowerCase();
                const foundFile = Object.keys(this.files).find(f => f.toLowerCase() === lowercaseFilename);
                if (foundFile) {
                    return this.files[foundFile];
                }
                throw new Error(`File not found: "${filename}". Available files: ${Object.keys(this.files).join(', ')}`);
            }

            displaySymbolTable() {
                let output = '';
                output += '=== COMPILATION SUMMARY ===\n';
                output += `Total Size: ${this.compilationStats.totalSize} bytes\n`;
                output += `Code Size: ${this.compilationStats.codeSize} bytes\n`;
                output += `Data Size: ${this.compilationStats.dataSize} bytes\n`;
                output += `Symbol Count: ${this.compilationStats.symbolCount}\n`;
                output += `File Count: ${this.compilationStats.fileCount}\n\n`;
                
                // Show different info based on packaging mode
                if (this.compilationStats.windowBase !== undefined) {
                    output += `ROM Window Base: ${this.compilationStats.windowBase.toString(16).toUpperCase()}\n`;
                    output += `ROM Window Size: ${this.compilationStats.windowSize} bytes\n`;
                    output += `Payload Used:    ${this.compilationStats.payloadUsed} bytes\n`;
                    output += `Window Free:     ${this.compilationStats.windowFree} bytes\n\n`;
                } else if (this.compilationStats.rawSize !== undefined) {
                    output += `Raw Binary Size: ${this.compilationStats.rawSize} bytes\n`;
                    output += `Address Range: ${(this.firstOrg ?? 0).toString(16).toUpperCase()}-${(this.output.length-1).toString(16).toUpperCase()}\n\n`;
                }
                
                output += '=== FILE MAP ===\n';
                output += 'Filename                 Start    End      Size     Type\n';
                output += '--------------------------------------------------------\n';
                for (const file of this.fileMap) {
                    output += `${file.filename.padEnd(25)}${file.startAddr.toString(16).toUpperCase().padStart(4, '0')}   ${file.endAddr.toString(16).toUpperCase().padStart(4, '0')}   ${file.size.toString().padStart(6)}   ${file.type}\n`;
                }
                
                output += '\n=== SYMBOL TABLE ===\n';
                output += 'Symbol                   Address  File         Line Type      Size\n';
                output += '----------------------------------------------------------------\n';
                
                const sortedSymbols = Object.keys(this.symbolInfo).sort((a, b) => 
                    this.symbolInfo[a].address - this.symbolInfo[b].address);
                
                for (const symbol of sortedSymbols) {
                    const info = this.symbolInfo[symbol];
                    output += `${symbol.padEnd(25)}${info.address.toString(16).toUpperCase().padStart(4, '0')}   ${info.file.padEnd(12)} ${info.lineNumber.toString().padStart(4)} ${info.type.padEnd(9)} ${info.size}\n`;
                }
                
                symbolsOutput.innerHTML = output;
            }

            generateCode(tokens) {
                this.pc = 0;
                this.output = [];
                for (const token of tokens) {
                    this.currentInstruction = token;
                    this.currentLine = token.lineNumber || 0;
                    
                    try {
                        if (token.label) {
                            const processedLabel = this.processTemporarySymbol(token.label);
                            this.pc = this.symbolTable[processedLabel];
                            while(this.output.length < this.pc) this.output.push(0);
                        }

                        if (token instanceof Directive) {
                            switch (token.name) {
                                case 'ORG':
                                    this.pc = this.evaluateExpression(token.operands[0]);
                                    if (this.firstOrg === null) this.firstOrg = this.pc;   // remember first ORG
                                    while (this.output.length < this.pc) this.output.push(0);
                                    break;
                                case 'DB': case 'DEFB': case 'DEFM': case 'ASCII': case 'TEXT': case 'BYTE':
                                    token.operands.forEach(op => {
                                        if (op.type === 'string') {
                                            for (let i = 0; i < op.value.length; i++) this.output.push(op.value.charCodeAt(i));
                                        } else {
                                            this.output.push(this.evaluateExpression(op) & 0xFF);
                                        }
                                    });
                                    break;
                                case 'DW': case 'DEFW': case 'WORD':
                                    token.operands.forEach(op => {
                                        const val = this.evaluateExpression(op);
                                        this.output.push(val & 0xFF);
                                        this.output.push((val >> 8) & 0xFF);
                                    });
                                    break;
                                case 'DS': case 'DEFS':
                                    const size = this.evaluateExpression(token.operands[0]);
                                    const fill = token.operands.length > 1 ? this.evaluateExpression(token.operands[1]) : 0;
                                    for (let i = 0; i < size; i++) this.output.push(fill & 0xFF);
                                    break;
                                case 'INCBIN':
                                    const filename = token.operands[0].value;
                                    const fileData = this.findFile(filename);
                                    this.output.push(...fileData);
                                    break;
                            }
                        } else if (token instanceof Instruction) {
                            const key = this.getOpcodeKey(token);
                            const opcode = Z80_OPCODES[key];
                            if (!opcode) {
                                const errorMsg = `Unknown instruction: ${token.mnemonic} ${token.operands.map(o => {
                                    if (o.type === 'memory') return `(${o.value})`;
                                    return o.value;
                                }).join(', ')} [Generated key: ${key}]`;
                                throw new Error(errorMsg);
                            }
                            
                            this.output.push(...opcode);
                            
                            // Handle operands
                            if (key.includes('imm16')) {
                                 const operand = token.operands.find(o => o.type === 'symbol' || o.type === 'immediate' || (o.type === 'memory' && (typeof o.value === 'number' || (typeof o.value === 'string' && !['bc','de','hl','sp','c'].includes(o.value.toLowerCase())))));
                                 if (!operand) throw new Error(`No 16-bit operand found for instruction: ${token.mnemonic}`);
                                 
                                 let val;
                                 if (operand.type === 'memory') {
                                     if (typeof operand.value === 'number') {
                                         val = operand.value;
                                     } else {
                                         // Memory operand with symbol - evaluate the symbol inside the parentheses
                                         val = this.evaluateExpression({type: 'symbol', value: operand.value});
                                     }
                                 } else {
                                     val = this.evaluateExpression(operand);
                                 }
                                 this.output.push(val & 0xFF);
                                 this.output.push((val >> 8) & 0xFF);
                            } else if (key.includes('imm8')) {
                                const operand = token.operands.find(o => 
                                    o.type === 'symbol' || 
                                    o.type === 'immediate' ||
                                    (o.type === 'memory' && (typeof o.value === 'number' || (typeof o.value === 'string' && !['bc','de','hl','sp','c'].includes(o.value.toLowerCase()))))
                                );
                                if (!operand) throw new Error(`No 8-bit operand found for instruction: ${token.mnemonic}`);
                                
                                let val;
                                if (operand.type === 'memory') {
                                    if (typeof operand.value === 'number') {
                                        val = operand.value;
                                    } else {
                                        // Memory operand with symbol - evaluate the symbol inside the parentheses
                                        val = this.evaluateExpression({type: 'symbol', value: operand.value});
                                    }
                                } else {
                                    val = this.evaluateExpression(operand);
                                }
                                this.output.push(val & 0xFF);
                            } else if (key.includes('rel8')) {
                                const operand = token.operands.find(o => o.type === 'symbol' || o.type === 'immediate');
                                const targetAddr = this.evaluateExpression(operand);
                                // Calculate current address: PC + instruction size (opcode bytes + 1 displacement byte)
                                const instrSize = opcode.length + 1;
                                const currentAddr = this.pc + instrSize;
                                let offset = targetAddr - currentAddr;
                                if (offset < -128 || offset > 127) throw new Error(`Relative jump out of range for ${token.mnemonic}: offset ${offset} (target: ${targetAddr}, current: ${currentAddr})`);
                                if (offset < 0) offset += 256;
                                this.output.push(offset);
                            } else if (key.includes('offset')) {
                                // IX/IY displacement - improved parsing for all formats
                                const offsetOperand = token.operands.find(o => o.type === 'memory' && typeof o.value === 'string');
                                if (offsetOperand) {
                                    // Extract offset from formats like: IX+5, IY-10, IX+SYMBOL, IX (zero offset)
                                    const match = offsetOperand.value.match(/(?:IX|IY)\s*([+-])\s*(.+)/i) ||
                                                  offsetOperand.value.match(/(?:IX|IY)\s*$/i);
                                    if (match && match[1] && match[2]) {
                                        // Has explicit offset: IX+5 or IY-SYMBOL
                                        const sign = match[1] === '-' ? -1 : 1;
                                        const offsetValue = this.evaluateExpression({type: 'symbol', value: match[2]});
                                        const signedOffset = sign * offsetValue;
                                        this.output.push(signedOffset & 0xFF);
                                    } else {
                                        // No offset or just IX/IY - use 0
                                        this.output.push(0);
                                    }
                                }
                            }
                        }
                        this.pc = this.output.length; 
                    } catch (error) {
                        // Add context to the error
                        const contextMsg = `Line ${this.currentLine}: ${token.mnemonic || 'directive'} ${(token.operands || []).map(o => o.value).join(', ')} - ${error.message}`;
                        throw new Error(contextMsg);
                    }
                }
            }

            exportSymbolTable() {
                const data = {
                    compilationStats: this.compilationStats,
                    fileMap: this.fileMap,
                    symbolTable: this.symbolTable,
                    constantTable: this.constantTable,
                    symbolInfo: this.symbolInfo,
                    timestamp: new Date().toISOString()
                };
                return JSON.stringify(data, null, 2);
            }

            getOpcodeKey(instruction) {
                const mnemonic = instruction.mnemonic.toLowerCase();

                // Handle EX AF,AF' specifically
                if (mnemonic === 'ex' && instruction.operands.length === 2 &&
                    instruction.operands[0].type === 'register_pair' && 
                    instruction.operands[0].value.toUpperCase() === 'AF' &&
                    instruction.operands[1].type === 'register_pair' && 
                    instruction.operands[1].value.toUpperCase() === "AF'") {
                    return 'ex_af,af\'';
                }

                // Handle IM instructions
                if (mnemonic === 'im' && instruction.operands.length === 1) {
                    return `im_${instruction.operands[0].value}`;
                }

                // Handle RST instructions
                if (mnemonic === 'rst' && instruction.operands.length === 1) {
                    const rstValue = this.evaluateExpression(instruction.operands[0]);
                    const rstMap = {0: '00h', 8: '08h', 16: '10h', 24: '18h', 32: '20h', 40: '28h', 48: '30h', 56: '38h'};
                    if (rstMap[rstValue]) {
                        return `rst_${rstMap[rstValue]}`;
                    }
                    return `rst_${rstValue}`;
                }

                if (instruction.operands.length === 0) return mnemonic;

                // Handle special undocumented IN (C) instruction  
                if (mnemonic === 'in' && instruction.operands.length === 1 && 
                    instruction.operands[0].type === 'memory' && 
                    typeof instruction.operands[0].value === 'string' &&
                    instruction.operands[0].value.toLowerCase() === 'c') {
                    return 'in_(c)';
                }

                // Handle OUT (C),0 instruction
                if (mnemonic === 'out' && instruction.operands.length === 2 &&
                    instruction.operands[0].type === 'memory' && 
                    typeof instruction.operands[0].value === 'string' &&
                    instruction.operands[0].value.toLowerCase() === 'c' &&
                    instruction.operands[1].type === 'immediate' &&
                    instruction.operands[1].value === 0) {
                    return 'out_(c),0';
                }

                // Handle JP (IX), JP (IY), JP (HL)
                if (mnemonic === 'jp' && instruction.operands.length === 1 && 
                    instruction.operands[0].type === 'memory') {
                    const memVal = instruction.operands[0].value;
                    if (typeof memVal === 'string') {
                        const reg = memVal.toLowerCase();
                        if (reg === 'ix') return 'jp_(ix)';
                        if (reg === 'iy') return 'jp_(iy)';
                        if (reg === 'hl') return 'jp_(hl)';
                    }
                }

                // Handle conditional jumps and calls
                if ((mnemonic === 'jp' || mnemonic === 'jr' || mnemonic === 'call' || mnemonic === 'ret') && 
                    instruction.operands.length > 0 && instruction.operands[0].type === 'condition') {
                    const condition = instruction.operands[0].value.toLowerCase();
                    if (instruction.operands.length === 1) {
                        return `${mnemonic}_${condition}`;
                    } else {
                        const addrType = (mnemonic === 'jr') ? 'rel8' : 'imm16';
                        return `${mnemonic}_${condition},${addrType}`;
                    }
                }

                const opTypes = instruction.operands.map(op => {
                    switch(op.type) {
                        case 'register': return op.value.toLowerCase();
                        case 'register_pair': 
                            // Handle AF' correctly
                            if (op.value.toUpperCase() === "AF'") return "af'";
                            return op.value.toLowerCase();
                        case 'condition': return op.value.toLowerCase();
                        case 'memory': 
                            // Handle memory operands - check if it's a known register or immediate address
                            if (typeof op.value === 'string') {
                                const memValue = op.value.toLowerCase();
                                // Handle IX/IY with displacement
                                if (memValue.includes('ix+') || memValue.includes('ix-')) {
                                    return '(ix+offset)';
                                }
                                if (memValue.includes('iy+') || memValue.includes('iy-')) {
                                    return '(iy+offset)';
                                }
                                if (['bc', 'de', 'hl', 'sp', 'c', 'ix', 'iy'].includes(memValue)) {
                                    return `(${memValue})`;
                                } else {
                                    // Special case for IN/OUT instructions - ports are 8-bit
                                    if (['in', 'out'].includes(mnemonic)) {
                                        return '(imm8)';
                                    }
                                    // Memory operand with symbol/address - treat as (imm16) for opcode lookup
                                    return '(imm16)';
                                }
                            } else {
                                // Numeric memory operand
                                if (['in', 'out'].includes(mnemonic)) {
                                    return '(imm8)';
                                }
                                return '(imm16)';
                            }
                        case 'immediate':
                        case 'symbol':
                            // Special handling for the first operand of bit/res/set
                            if (['bit', 'res', 'set'].includes(mnemonic) && instruction.operands.indexOf(op) === 0) {
                                const val = this.evaluateExpression(op);
                                if (val < 0 || val > 7) {
                                    throw new Error(`Bit position must be 0-7 for ${mnemonic}, got ${val}`);
                                }
                                return String(val);
                            }                          
                            if (mnemonic.startsWith('jr') || mnemonic === 'djnz') return 'rel8';
                            if (mnemonic === 'jp' || mnemonic === 'call') {
                                if (instruction.operands[0].type === 'memory') {
                                    const memVal = instruction.operands[0].value;
                                    if (typeof memVal === 'string') {
                                        return `(${memVal.toLowerCase()})`;
                                    } else {
                                        return '(imm16)';
                                    }
                                }
                                return 'imm16';
                            }
                            if (mnemonic === 'ld') {
                                const dest = instruction.operands[0];
                                if (dest.type === 'register_pair') return 'imm16';
                                if (dest.type === 'memory') {
                                    if (typeof dest.value === 'string') {
                                        if (!['bc','de','hl','ix','iy'].includes(dest.value.toLowerCase())) return 'imm16';
                                    } else {
                                        return 'imm16'; // Numeric memory operand
                                    }
                                }
                                return 'imm8';
                            }
                            if (['add', 'adc', 'sub', 'sbc', 'and', 'or', 'xor', 'cp', 'out', 'in'].includes(mnemonic)) {
                                return 'imm8';
                            }
                            if (['rst'].includes(mnemonic)) {
                                // RST is special - it's actually encoded in the opcode itself
                                return op.value.toString(16).padStart(2, '0') + 'h';
                            }
                            return 'imm16';
                        default: return 'unknown';
                    }
                }).join(',');
                
                return `${mnemonic}_${opTypes}`;
            }

            evaluateExpression(operand) {
                try {
                    if (operand.type === 'immediate') return operand.value;
                    if (operand.type !== 'symbol') {
                        if (this.currentPass < 3) return 0;
                        throw new Error(`Cannot evaluate expression for operand type: ${operand.type}`);
                    }
                
                    let expr = String(operand.value);
                    const originalExpr = expr; // Keep original for error reporting
                
                    // Handle temporary symbol references
                    expr = this.resolveTemporarySymbolReference(expr);
                
                    // Check if it's a direct opcode reference
                    const opcode = Z80_OPCODES[expr.toLowerCase()];
                    if (opcode) {
                        return opcode[opcode.length - 1];
                    }

                    // IMPORTANT: Parse hex/bin/oct numbers FIRST, before replacing $ with PC
                    // This allows $702b to be treated as hex, not $ (PC) followed by 702b
                    let parsedExpr = expr;
                    parsedExpr = parsedExpr.replace(/0x([0-9a-fA-F]+)/gi, (match, hex) => parseInt(hex, 16));
                    parsedExpr = parsedExpr.replace(/\$([0-9a-fA-F]+)/g, (match, hex) => parseInt(hex, 16));
                    parsedExpr = parsedExpr.replace(/([0-9a-fA-F]+)h\b/gi, (match, hex) => parseInt(hex, 16));
                    parsedExpr = parsedExpr.replace(/%([01]+)/g, (match, bin) => parseInt(bin, 2));
                    parsedExpr = parsedExpr.replace(/([01]+)b\b/gi, (match, bin) => parseInt(bin, 2));
                    parsedExpr = parsedExpr.replace(/@([0-7]+)/g, (match, oct) => parseInt(oct, 8));

                    // NOW replace $ with PC (for expressions like $ or $+5 where $ is alone)
                    parsedExpr = parsedExpr.replace(/\$/g, this.pc);
                    parsedExpr = parsedExpr.replace(/\*/g, this.pc); // Alternative PC symbol

                    // Replace constants first (higher priority than symbols)
                    const sortedConstants = Object.keys(this.constantTable).sort((a, b) => b.length - a.length);
                    for (const constant of sortedConstants) {
                        const regex = new RegExp(`\\b${constant}\\b`, 'g');
                        parsedExpr = parsedExpr.replace(regex, this.constantTable[constant]);
                    }

                    // Replace symbols
                    const sortedSymbols = Object.keys(this.symbolTable).sort((a, b) => b.length - a.length);

                    for (const symbol of sortedSymbols) {
                        const regex = new RegExp(`\\b${symbol}\\b`, 'g');
                        parsedExpr = parsedExpr.replace(regex, this.symbolTable[symbol]);
                    }

                    // Parse numbers with different bases (for simple number values)
                    const numValue = this.numberParser.parseNumber(parsedExpr);
                    if (numValue !== null) {
                        return numValue;
                    }

                    try {

                        // Now check for undefined symbols (after hex parsing)
                        if (/[a-zA-Z_]/.test(parsedExpr)) {
                            if (this.currentPass < 3) return 0;
                            throw new Error(`Undefined symbol in expression: ${originalExpr} (evaluated to: ${parsedExpr})`);
                        }

                        const sanitizedExpr = parsedExpr.replace(/[^\d\+\-\*\/\(\)\s\.]/g, '');
                        if (sanitizedExpr.trim() !== parsedExpr.trim()) {
                             if (this.currentPass < 3) return 0;
                             throw new Error(`Invalid characters in expression: ${originalExpr} (cleaned: ${sanitizedExpr})`);
                        }
                        return Math.floor(new Function(`return ${sanitizedExpr}`)());
                    } catch (e) {
                        if (this.currentPass < 3) return 0;
                        throw new Error(`Invalid expression: ${originalExpr} (sanitized: ${expr})`);
                    }
                } catch (error) {
                    // Add context about current instruction if available
                    if (this.currentInstruction) {
                        const instStr = this.currentInstruction.mnemonic || this.currentInstruction.name || 'unknown';
                        throw new Error(`${error.message} in instruction '${instStr}' at line ${this.currentLine}`);
                    }
                    throw error;
                }
            }
        }
        
        // --- Event Listeners ---
        compileBtn.addEventListener('click', async () => {
            consoleOutput.innerHTML = '';
            symbolsOutput.innerHTML = '';
            log('Starting enhanced compilation...');
            downloadBtn.classList.add('hidden');
            exportSymbolsBtn.classList.add('hidden');
            document.getElementById('test-buttons-container').classList.add('hidden');
            compiledBinary = null;
            assemblerInstance = null;

            let mainFile = currentFile;
            if (!mainFile) {
                const content = editor.getValue();
                if (!content.trim()) {
                    log('Editor is empty. Nothing to compile.', 'warn');
                    return;
                }
                mainFile = 'editor.asm';
                projectFiles[mainFile] = new TextEncoder().encode(content);
            }

            // Set output filename based on source file (like Pro version)
            const sourceBaseName = mainFile.replace(/\.[^/.]+$/, ''); // Remove extension
            outputFilename = `build_${sourceBaseName}.bin`;

            const assembler = new Assembler(projectFiles);
            const binary = await assembler.assemble(mainFile);

            if (binary) {
                assemblerInstance = assembler;
                downloadBtn.classList.remove('hidden');
                exportSymbolsBtn.classList.remove('hidden');
                document.getElementById('test-buttons-container').classList.remove('hidden');                
                switchTab('symbols'); // Automatically switch to symbols tab to show results
            } else {
                document.getElementById('test-buttons-container').classList.add('hidden');                
            }
        });

        // Function to download any file from the project
        function downloadProjectFile(filename) {
            const fileData = projectFiles[filename];
            if (!fileData) {
                log(`File not found: ${filename}`, 'error');
                return;
            }

            const blob = new Blob([fileData], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            log(`Downloaded: ${filename}`, 'success');
        }

        // Function to delete a file from the project
        function deleteProjectFile(filename) {
            if (!projectFiles[filename]) {
                log(`File not found: ${filename}`, 'error');
                return;
            }

            if (confirm(`Delete ${filename} from project?`)) {
                delete projectFiles[filename];
                log(`Deleted: ${filename}`, 'info');

                // If the deleted file was the current file, close the editor
                if (currentFile === filename) {
                    currentFile = null;
                    editor.setValue('');
                }

                renderFileTree();
            }
        }

        downloadBtn.addEventListener('click', () => {
            if (!compiledBinary) return;
            const blob = new Blob([compiledBinary], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = outputFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            log(`Downloaded ${outputFilename}.`);
        });

        exportSymbolsBtn.addEventListener('click', () => {
            if (!assemblerInstance) return;
            const symbolData = assemblerInstance.exportSymbolTable();
            const blob = new Blob([symbolData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = outputFilename.replace(/\.[^/.]+$/, '') + '_symbols.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            log(`Exported symbol table to ${outputFilename.replace(/\.[^/.]+$/, '') + '_symbols.json'}.`);
        });

        // Platform selection handler
        const targetPlatformSelect = document.getElementById('target-platform');
        targetPlatformSelect.addEventListener('change', () => {
            const config = getPlatformConfig();
            if (config.description) {
                log(`Target platform changed to: ${config.description}`, 'info');
            }
        });

        // COLECOVISION RENDERING
        document.getElementById('test-cv-screen').addEventListener('click', () => {
            if (compiledBinary) {
                const gameInfo = parseGameTitle(compiledBinary);
                emulateColecoBootScreen(gameInfo);
                log('Manual ColecoVision title screen test triggered', 'info');
            }
        });

        document.getElementById('test-dina-screen').addEventListener('click', () => {
            if (compiledBinary) {
                const gameInfo = parseGameTitle(compiledBinary);
                emulateDinaBoot(gameInfo);
            }
            log('Manual DINA 2-in-1 title screen test triggered', 'info');
        });        

        // Initial state
        updateCompileButtonState();
        log('AmysCVAssembler ready (zmac-compatible, multi-syntax Z80).', 'success');
        log('Target: ColecoVision ROM (also compatible with DINA 2-in-1)', 'info');
        log('Syntax: zmac, TASM, MACRO-80, MRAS, Intel, Motorola styles supported', 'info');
        log('Features: Direct binary output, no linker required', 'info');
        log('Supported files: .asm, .z80, .s (also .zip, .gz archives)', 'info');
        log('Drop your files to begin.', 'info');

        /*
         * ============================================================================
         * ZMAC COMPATIBILITY TEST EXAMPLES
         * ============================================================================
         *
         * Example 1: Basic Z80 Assembly with Labels and Jumps
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   START:
         *       ld a, $FF          ; Load immediate hex
         *       ld hl, BUFFER      ; Load address of buffer
         *       call CLEAR         ; Call subroutine
         *       jp START           ; Infinite loop
         *
         *   CLEAR:
         *       xor a              ; A = 0
         *       ld (hl), a         ; Clear byte
         *       ret
         *
         *   BUFFER: ds 256         ; Reserve 256 bytes
         *
         * Example 2: Using zmac Directives (DEFM, DEFB, DEFW)
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   HEADER:
         *       defb $AA, $55               ; Header bytes
         *       defm "GAME TITLE", 0        ; String with null terminator
         *       defw START                  ; 16-bit address
         *
         *   START:
         *       ld hl, MESSAGE
         *       call PRINT
         *       ret
         *
         *   MESSAGE:
         *       ascii "HELLO WORLD!"        ; ASCII string (synonym for DB)
         *       db 13, 10, 0                ; CR, LF, null
         *
         * Example 3: Macros and Conditionals
         * ----------------------------------------------------------------------------
         *   DEBUG equ 1
         *
         *   ; Macro definition
         *   DELAY macro count
         *       ld b, count
         *   .loop:
         *       djnz .loop
         *   endm
         *
         *   org $8000
         *
         *   START:
         *       DELAY 100                   ; Expand macro with parameter
         *
         *       if DEBUG
         *           ld a, $FF               ; Debug code
         *       else
         *           xor a                   ; Release code
         *       endif
         *
         *       ret
         *
         * Example 4: IX/IY Indexed Addressing
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   OFFSET equ 5
         *
         *   START:
         *       ld ix, BUFFER
         *       ld a, (ix+0)               ; Read from IX+0
         *       ld (ix+OFFSET), a          ; Write to IX+OFFSET
         *       ld b, (iy-10)              ; Read from IY-10
         *       ret
         *
         *   BUFFER: ds 256
         *
         * Example 5: Number Formats (All Supported)
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   HEX_STYLES:
         *       db $FF                      ; Dollar prefix
         *       db 0xFF                     ; 0x prefix
         *       db 0FFh                     ; Suffix h
         *
         *   BINARY_STYLES:
         *       db %11111111                ; Percent prefix
         *       db 0b11111111               ; 0b prefix
         *       db 11111111b                ; Suffix b
         *
         *   OCTAL_STYLES:
         *       db @377                     ; At sign prefix
         *       db 0377                     ; Leading zero
         *       db 377o                     ; Suffix o
         *
         *   DECIMAL:
         *       db 255                      ; Plain decimal
         *       db 255d                     ; Suffix d (optional)
         *
         * Example 6: ColecoVision ROM Header
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   ; ColecoVision header
         *   db $AA, $55                     ; Cart header (bypasses title screen)
         *   ; or: db $55, $AA               ; (shows default CV title screen)
         *
         *   dw 0, 0, 0, 0, 0, 0, 0          ; Reserved
         *   dw START                        ; Start address
         *   dw 0, 0, 0, 0, 0                ; RST handlers
         *
         *   ; Game title at $8024 (format: "LINE3/LINE2/YEAR")
         *   org $8024
         *   defm "MY GAME/BY ME/2024", 0
         *
         *   org $8100
         *   START:
         *       di                          ; Disable interrupts
         *       ld sp, $7400                ; Set stack
         *       jp MAIN
         *
         *   MAIN:
         *       ; Your game code here
         *       jp MAIN
         *
         * Example 7: Relative Jumps and DJNZ
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   START:
         *       ld b, 10
         *   LOOP:
         *       nop
         *       djnz LOOP                   ; Decrement B and jump if not zero
         *
         *       ld a, 5
         *       cp 10
         *       jr z, EQUAL                 ; Jump if zero (relative)
         *       jr nc, GREATER              ; Jump if no carry
         *       jr LESS
         *
         *   EQUAL:
         *       xor a
         *       ret
         *
         *   GREATER:
         *       ld a, 1
         *       ret
         *
         *   LESS:
         *       ld a, $FF
         *       ret
         *
         * Example 8: BIT/RES/SET Instructions
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   START:
         *       ld a, %10101010
         *
         *       bit 0, a                    ; Test bit 0
         *       jr z, BIT_CLEAR
         *
         *       set 1, a                    ; Set bit 1
         *       res 7, a                    ; Reset bit 7
         *
         *       ret
         *
         *   BIT_CLEAR:
         *       set 0, a
         *       ret
         *
         * ============================================================================
         */

    </script>

</body>
</html>