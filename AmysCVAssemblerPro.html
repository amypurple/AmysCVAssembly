<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AmysCVAssemblerPro - Z80 Assembler with Object Library Support</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/material-darker.min.css">
    <!-- JSZip for handling .zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- pako for handling .gz files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/mode/simple.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .CodeMirror {
            border-radius: 0.5rem;
            height: 100%;
            font-size: 14px;
        }
        .file-tree-item {
            cursor: pointer;
            padding: 8px 12px;
            margin: 4px 0;
            background: #334155;
            border-radius: 6px;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        .file-tree-item:hover {
            background-color: #475569;
            border-color: #64748b;
            transform: translateX(2px);
        }
        .file-tree-item.active {
            background-color: #4f46e5;
            color: white;
            font-weight: 600;
            border-color: #6366f1;
            border-left: 4px solid #60a5fa;
            padding-left: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        #file-tree {
            background: #1e293b;
            border-radius: 8px;
            padding: 12px;
            border: 2px solid #334155;
        }
        .cm-s-material-darker.CodeMirror {
            background-color: #1f2937;
        }
        #drop-zone {
            border: 2px dashed #475569;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 8px;
            transition: all 0.3s ease;
            position: relative;
            cursor: pointer;
        }
        #drop-zone:hover {
            border-color: #60a5fa;
            background: linear-gradient(135deg, #1e3a5f 0%, #0f172a 100%);
        }
        #drop-zone.drag-over {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #1e3a8a 0%, #1e293b 100%);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
            transform: scale(1.02);
        }
        .tab-button {
            cursor: pointer;
            transition: all 0.2s;
        }
        .tab-button.active {
            background-color: #4f46e5;
            color: white;
        }
        .tab-button:not(.active) {
            color: #9ca3af;
        }
        .tab-button:not(.active):hover {
            background-color: #374151;
            color: white;
        }
        .help-tab {
            color: #9ca3af;
            background-color: transparent;
        }
        .help-tab.active {
            background-color: #4f46e5;
            color: white;
        }
        .help-tab:not(.active):hover {
            background-color: #374151;
            color: white;
        }

        /* Dropdown menu styles */
        .dropdown {
            position: relative;
            display: inline-block;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background-color: #1f2937;
            min-width: 200px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid #374151;
            z-index: 1000;
            overflow: hidden;
        }
        .dropdown-content.show {
            display: block;
        }
        .dropdown-item {
            color: white;
            padding: 10px 16px;
            text-decoration: none;
            display: block;
            transition: background-color 0.2s;
            cursor: pointer;
            font-size: 14px;
        }
        .dropdown-item:hover {
            background-color: #374151;
        }
        .dropdown-item.disabled {
            color: #6b7280;
            cursor: not-allowed;
            opacity: 0.5;
        }
        .dropdown-item.disabled:hover {
            background-color: transparent;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Fira+Code&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col h-screen">

    <header class="bg-gray-800 p-4 shadow-md flex justify-between items-center">
        <h1 class="text-2xl font-bold text-white">AmysCVAssemblerPro <span class="text-sm text-gray-400">(with .REL support)</span></h1>
        <div class="flex items-center gap-4">
            <!-- Output Mode Selector -->
            <div class="flex items-center gap-2">
                <label class="text-xs text-gray-400">Output:</label>
                <select id="output-mode" class="bg-gray-700 text-white rounded px-2 py-1 text-sm" title="Select output format">
                    <option value="binary" selected title="ColecoVision ROM binary">Binary (.bin)</option>
                    <option value="rel" title="Classic Microsoft LINK-80 format - 6 character symbol limit">LINK-80 .REL</option>
                    <option value="rel-extended" title="Linkstor80 extended format - unlimited symbols, UTF-8 support">Extended .REL</option>
                </select>
                <button type="button" id="help-btn" class="bg-gray-700 hover:bg-gray-600 text-white rounded px-2 py-1 text-sm transition-colors" title="Help & Documentation">
                    ‚ùì
                </button>
            </div>

            <!-- Platform selector hidden - hardcoded to ColecoVision -->
            <select id="target-platform" class="hidden" title="Target Platform">
                <option value="coleco" selected>ColecoVision</option>
            </select>

            <!-- New File button -->
            <button type="button" id="new-file-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors" title="Create new untitled file">
                üìÑ New File
            </button>

            <!-- Always visible: Compile and Download -->
            <button id="compile-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed">
                Compile
            </button>
            <button id="download-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors hidden ml-2">
                Download Binary
            </button>

            <!-- Adaptive buttons container - shows 0-2 buttons based on context -->
            <div id="adaptive-actions" class="flex items-center gap-2 ml-2"></div>

            <!-- More dropdown - shown when 3+ actions available -->
            <div class="dropdown ml-2 hidden" id="more-dropdown">
                <button id="more-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    More ‚ñº
                </button>
                <div id="more-content" class="dropdown-content">
                    <!-- Dynamically populated -->
                </div>
            </div>

            <!-- Hidden buttons (managed by adaptive system) -->
            <button id="link-btn" class="hidden">Link Modules</button>
            <button id="build-lib-btn" class="hidden">Build Library (ASM‚ÜíLIB)</button>
            <button id="create-lib-btn" class="hidden">Create Library from REL</button>
            <button id="export-symbols-btn" class="hidden">Export Symbols</button>
            <button id="clean-project-btn" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-4 rounded-lg transition-colors ml-2 hidden" title="Clean temporary files (.lst)">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-1" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M10 11v6M14 11v6" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                Clean
            </button>
            <button id="test-cv-screen" class="hidden">Test CV Screen</button>
            <button id="test-dina-screen" class="hidden">Test DINA Screen</button>
        </div>
    </header>

    <main class="flex-grow flex p-4 gap-4 overflow-hidden">
        <!-- Left Panel: File Tree and Drop Zone -->
        <div class="w-1/4 flex flex-col bg-gray-800 p-4 rounded-lg shadow-lg">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 2px solid #475569;">
                <h2 class="text-lg font-semibold" style="color: #60a5fa; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 20px;">üìÇ</span> Project Files
                </h2>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <button type="button" id="download-project-btn" class="text-blue-400 hover:text-blue-300 transition-colors cursor-pointer" style="font-size: 20px; background: none; border: none; padding: 0;" title="Download entire project as ZIP">
                        üíæ
                    </button>
                    <span id="file-count" style="background: #334155; padding: 4px 10px; border-radius: 12px; font-size: 12px; color: #94a3b8;">0</span>
                </div>
            </div>
            <div id="file-tree" class="flex-grow overflow-y-auto mb-4">
                <p class="text-gray-400 text-sm">Drop files or a zip/gz archive below.</p>
            </div>
            <div id="drop-zone" class="p-6 text-center rounded-lg cursor-pointer hover:bg-gray-700 transition-colors">
                <div style="font-size: 36px; margin-bottom: 8px; opacity: 0.6;">üì•</div>
                <p style="color: #94a3b8; font-weight: 500; margin-bottom: 4px;">Drag & Drop Files Here</p>
                <p style="color: #64748b; font-size: 11px;">.asm .z80 .s .rel .lib .zip .gz</p>
                <p style="color: #64748b; font-size: 11px; margin-top: 8px;">or tap to browse</p>
                <input type="file" id="file-input" class="hidden" multiple accept=".asm,.z80,.s,.inc,.h,.rel,.o,.obj,.lib,.a,.bin,.rom,.col,.zip,.gz,.zx0,.pletter,.gfx,.chr,.dat,.map" title="Select files to upload">
            </div>
        </div>

        <!-- Middle Panel: Code Editor -->
        <div class="w-1/2 flex flex-col bg-gray-800 rounded-lg shadow-lg overflow-hidden min-h-0">
            <!-- File Header Bar -->
            <div id="file-header" class="bg-gray-700 px-4 py-2 flex items-center justify-between border-b border-gray-600">
                <div class="flex items-center gap-2">
                    <span class="text-gray-400 text-sm">Editing:</span>
                    <span id="current-file-name" class="text-blue-400 font-semibold text-sm">No file open</span>
                </div>
                <button type="button" id="close-file-btn" class="text-gray-400 hover:text-red-400 transition-colors text-xl leading-none" title="Close file and create new untitled.asm">
                    √ó
                </button>
            </div>
            <div id="editor-container" class="flex-grow relative min-h-0">
                 <textarea id="code-editor"></textarea>
            </div>
        </div>

        <!-- Right Panel: Console Output and Symbol Table -->
        <div class="w-1/4 flex flex-col bg-gray-800 p-4 rounded-lg shadow-lg">
            <div class="flex mb-2 border-b border-gray-700 pb-2">
                <button id="console-tab" class="tab-button active text-lg font-semibold px-3 py-1 rounded mr-2">Console</button>
                <button id="symbols-tab" class="tab-button text-lg font-semibold px-3 py-1 rounded">Symbols</button>
            </div>
            <pre id="console-output" class="flex-grow bg-gray-900 rounded-md p-2 text-sm overflow-y-auto whitespace-pre-wrap font-mono"></pre>
            <pre id="symbols-output" class="flex-grow bg-gray-900 rounded-md p-2 text-sm overflow-y-auto whitespace-pre-wrap font-mono hidden"></pre>
        </div>
    </main>

    <script>
        // Enhanced CodeMirror setup with better Z80 syntax highlighting
        CodeMirror.defineSimpleMode("z80", {
            start: [
                {regex: /;.*$/, token: "comment"},
                {regex: /([a-zA-Z_][a-zA-Z0-9_.]*):/, token: "tag"},
                {regex: /\$\$[a-zA-Z_][a-zA-Z0-9_]*/, token: "variable-3"}, // Named temporary symbols
                {regex: /\.[a-zA-Z_][a-zA-Z0-9_]*/, token: "variable-2"}, // Composed temporary symbols
                {regex: /[+-\/](?=\s*:)/, token: "variable-3"}, // Nameless temporary symbols
                {regex: /\.?(cpu|fname|equ|set|eval|constant|org|dw|ds|db|defb|defw|defs|defm|include|incbin|macro|endm|rept|endr|if|endif|else|elif|section|endsection|radix|intsyntax|relaxed|padding|area|module|globl|public|global|extern|cseg|dseg|aseg|common|end)\b/i, token: "keyword"},
                {regex: /\b(a|b|c|d|e|h|l|i|r|af|bc|de|hl|sp|ix|iy|af'|ixh|ixl|iyh|iyl|nz|z|nc|c|po|pe|p|m)\b/i, token: "atom"},
                {regex: /\b(add|adc|sub|sbc|and|or|xor|cp|inc|dec|ld|push|pop|ex|exx|jp|jr|call|ret|reti|retn|rst|djnz|nop|halt|di|ei|im|neg|cpl|scf|ccf|daa|rla|rra|rlca|rrca|rld|rrd|ldi|ldir|ldd|lddr|cpi|cpir|cpd|cpdr|in|out|ini|ind|outi|outd|rlc|rrc|rl|rr|sla|sra|sll|srl|bit|res|set)\b/i, token: "builtin"},
                {regex: /(\$|0x)[0-9a-fA-F]+|[0-9]+[hH]?|[01]+[bB]?|@[0-7]+|%[01]+/, token: "number"},
                {regex: /"[^"]*"/, token: "string"},
                {regex: /'[^\']'/, token: "string-2"},
                {regex: /[a-zA-Z_][a-zA-Z0-9_.]*/, token: "variable"},
            ],
            meta: {
                dontIndentStates: ["comment"],
                lineComment: ";"
            }
        });

        const editor = CodeMirror.fromTextArea(document.getElementById('code-editor'), {
            lineNumbers: true,
            theme: 'material-darker',
            mode: 'z80',
            indentUnit: 4,
            tabSize: 4,
        });

        // Paste overwrite confirmation handler
        editor.on('beforeChange', function(cm, change) {
            if (change.origin === 'paste') {
                const currentContent = cm.getValue();
                const pastedContent = change.text.join('\n');

                // Check if this is a significant paste that would overwrite content
                if (currentContent.length > 50 && pastedContent.length > currentContent.length * 0.5) {
                    const currentLines = currentContent.split('\n').length;
                    const pastedLines = change.text.length;

                    // Check if paste would replace most of the file
                    const isLargeOverwrite = pastedLines > currentLines * 0.5 || pastedContent.length > currentContent.length * 0.8;

                    if (isLargeOverwrite) {
                        const filename = currentFile || 'this file';
                        const confirmMsg = `You are pasting ${pastedLines} lines into ${filename} which currently has ${currentLines} lines.\n\n` +
                                         `This will significantly modify the file content.\n\n` +
                                         `Are you sure you want to continue?\n\n` +
                                         `(Tip: Click the √ó button to create a new file instead)`;

                        if (!confirm(confirmMsg)) {
                            change.cancel();
                        }
                    }
                }
            }
        });

        // --- Global State ---
        let projectFiles = {};
        let currentFile = null;
        let compiledBinary = null;
        let assemblerInstance = null;
        let outputFilename = 'output.bin';

        // Target platform configurations
        const PLATFORM_CONFIGS = {
            'coleco': {
                packager: null,  // No padding - output minimal ROM like zmac
                validateHeader: 'coleco',
                description: 'ColecoVision ROM (minimal size, also compatible with DINA 2-in-1)'
            }
        };

        // Get current platform configuration
        function getPlatformConfig() {
            // Always return ColecoVision config
            return PLATFORM_CONFIGS['coleco'];
        }

        // ColecoVision header validation and title screen emulation
        function validateColecoHeader(binary, showEmulation = true) {
            const testCvBtn = document.getElementById('test-cv-screen');
            const testDinaBtn = document.getElementById('test-dina-screen');

            if (binary.length < 2) {
                log('Warning: Binary too small for ColecoVision header', 'warn');
                testCvBtn.classList.add('hidden');
                testDinaBtn.classList.add('hidden');
                return { valid: false, usesDefaultScreen: false };
            }

            const header = (binary[1] << 8) | binary[0];
            let valid = false;
            let usesDefaultScreen = false;

            if (header === 0x55AA) {
                valid = true;
                usesDefaultScreen = true;
                log('ColecoVision header detected: $55AA (uses default ColecoVision title screen)', 'success');
            } else if (header === 0xAA55) {
                valid = true;
                usesDefaultScreen = false;
                log('ColecoVision header detected: $AA55 (bypasses default title screen - test cartridge)', 'success');
            } else {
                log(`Warning: Invalid ColecoVision header: ${header.toString(16).padStart(4, '0').toUpperCase()}. Expected $AA55 or $55AA`, 'warn');
            }

            if (header === 0x55AA || header === 0xAA55) {
                valid = true;
                testCvBtn.classList.remove('hidden');
                testDinaBtn.classList.remove('hidden');
            } else {
                testCvBtn.classList.add('hidden');
                testDinaBtn.classList.add('hidden');
            }

            return { valid, usesDefaultScreen, header };
        }

        // Parse ColecoVision game title from header
        function parseGameTitle(binary) {
            const titleOffset = 0x8024 - 0x8000; // Title starts at $8024
            if (binary.length <= titleOffset) {
                return { line2: "UNKNOWN GAME", line3: "NO TITLE DATA", year: "1982" };
            }
            
            // Read title string from binary
            let titleString = '';
            for (let i = titleOffset; i < binary.length && binary[i] !== 0; i++) {
                if (binary[i] >= 32 && binary[i] <= 126) { // Printable ASCII
                    titleString += String.fromCharCode(binary[i]);
                } else {
                    break; // Stop at first non-printable character
                }
            }
            
            // Parse format: "LINE3/LINE2/YEAR"
            const parts = titleString.split('/');
            const line3 = parts[0] || "UNKNOWN GAME";
            const line2 = parts[1] || "NO PUBLISHER";
            const year = parts[2] || "1982";
            
            log(`Parsed game title: "${line2}" / "${line3}" / "${year}"`, 'info');
            return { line2, line3, year };
        }

        // === TMS9918A Emulation Components ===
        const TMS_PALETTE = [
            "#00000000", "#000000", "#21C842", "#5EDC78", "#5455ED", "#7D76FC", "#D4524D", "#42EBF5",
            "#FC5554", "#FF7978", "#D4C154", "#E5CE80", "#21B03B", "#C95AA9", "#CCCCCC", "#FFFFFF"
        ];

        // ColecoVision logo data (2x24 tiles)
        const CV_LOGO_2x24 = [
            0x60,0x61,0x68,0x69,0x70,0x71,0x78,0x79,0x80,0x81,0x88,0x89,0x64,0x65,0x6C,0x74,0x75,0x7C,0x84,0x85,0x8C,0x8D,0x1E,0x1F,
            0x62,0x63,0x6A,0x6B,0x72,0x73,0x7A,0x7B,0x82,0x83,0x8A,0x8B,0x66,0x67,0x6D,0x76,0x77,0x7D,0x86,0x87,0x8E,0x8F,0x00,0x00
        ];

        // DINA logo data (4x12 tiles)
        const DINA_LOGO_4x12 = [
            0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
            0xA0,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0xA0,
            0xA0,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0xA0,
            0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
        ];

        // Pattern data (hex encoded)
        const CV_PATTERN_DATA = `00 00 00 00 00 00 00 00 7e 81 bd a1 a1 bd 81 7e 1f 04 04 04 00 00 00 00 44 6c 54 54 00 00 00 00 00 00 00 00 00 00 00 00 20 20 20 20 20 00 20 00 50 50 50 00 00 00 00 00 50 50 f8 50 f8 50 50 00 20 78 a0 70 28 f0 20 00 c0 c8 10 20 40 98 18 00 40 a0 a0 40 a8 90 68 00 20 20 20 00 00 00 00 00 20 40 80 80 80 40 20 00 20 10 08 08 08 10 20 00 20 a8 70 20 70 a8 20 00 00 20 20 f8 20 20 00 00 00 00 00 00 20 20 40 00 00 00 00 f8 00 00 00 00 00 00 00 00 00 00 20 00 00 08 10 20 40 80 00 00 70 88 98 a8 c8 88 70 00 20 60 20 20 20 20 70 00 70 88 08 30 40 80 f8 00 f8 08 10 30 08 88 70 00 10 30 50 90 f8 10 10 00 f8 80 f0 08 08 88 70 00 38 40 80 f0 88 88 70 00 f8 08 10 20 40 40 40 00 70 88 88 70 88 88 70 00 70 88 88 78 08 10 e0 00 00 00 20 00 20 00 00 00 00 00 20 00 20 20 40 00 10 20 40 80 40 20 10 00 00 00 f8 00 f8 00 00 00 40 20 10 08 10 20 40 00 70 88 10 20 20 00 20 00 70 88 a8 b8 b0 80 78 00 20 50 88 88 f8 88 88 00 f0 88 88 f0 88 88 f0 00 70 88 80 80 80 88 70 00 f0 88 88 88 88 88 f0 00 f8 80 80 f0 80 80 f8 00 f8 80 80 f0 80 80 80 00 78 80 80 80 98 88 78 00 88 88 88 f8 88 88 88 00 70 20 20 20 20 20 70 00 08 08 08 08 08 88 70 00 88 90 a0 c0 a0 90 88 00 80 80 80 80 80 80 f8 00 88 d8 a8 a8 88 88 88 00 88 88 c8 a8 98 88 88 00 70 88 88 88 88 88 70 00 f0 88 88 f0 80 80 80 00 70 88 88 88 a8 90 68 00 f0 88 88 f0 a0 90 88 00 70 88 80 70 08 88 70 00 f8 20 20 20 20 20 20 00 88 88 88 88 88 88 70 00 88 88 88 88 88 50 20 00 88 88 88 a8 a8 d8 88 00 88 88 50 20 50 88 88 00 88 88 50 20 20 20 20 00 f8 08 10 20 40 80 f8 00 f8 c0 c0 c0 c0 c0 f8 00 00 80 40 20 10 08 00 00 f8 18 18 18 18 18 f8 00 00 00 20 50 88 00 00 00 00 00 00 00 00 00 00 f8 3f 7f ff ff f3 f3 f0 f0 00 80 c0 c0 c0 c0 00 00 f3 f3 ff ff 7f 3f 00 00 c0 c0 c0 c0 80 00 00 00 f1 f1 f1 7b 7b 7b 3f 3f e0 e0 e0 c0 c0 c0 80 80 3f 1f 1f 1f 0e 0e 00 00 80 00 00 00 00 00 00 00 3f 7f ff ff f3 f3 f3 f3 00 80 c0 c0 c0 c0 c0 c0 f3 f3 ff ff 7f 3f 00 00 c0 c0 c0 c0 80 00 00 00 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 00 00 00 00 f0 f0 ff ff ff ff 00 00 00 00 c0 c0 c0 c0 00 00 1f 3f 7f 79 78 7f 7f 3f 80 c0 e0 e0 00 80 c0 e0 1f 01 79 7f 3f 1f 00 00 e0 e0 e0 e0 c0 80 00 00 ff ff ff f0 f0 ff ff ff c0 c0 c0 00 00 00 00 00 f0 f0 ff ff ff ff 00 00 00 00 c0 c0 c0 c0 00 00 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 3f 7f ff ff f3 f3 f0 f0 00 80 c0 c0 c0 c0 00 00 f3 f3 ff ff 7f 3f 00 00 c0 c0 c0 c0 80 00 00 00 3f 7f ff ff f3 f3 f3 f3 00 80 c0 c0 c0 c0 c0 c0 f3 f3 ff ff 7f 3f 00 00 c0 c0 c0 c0 80 00 00 00 3f 7f ff ff f3 f3 f3 f3 00 80 c0 c0 c0 c0 c0 c0 f3 f3 ff ff 7f 3f 00 00 c0 c0 c0 c0 80 00 00 00 f3 f3 fb fb fb ff ff ff c0 c0 c0 c0 c0 c0 c0 c0 ff f7 f7 f7 f3 f3 00 00 c0 c0 c0 c0 c0 c0 00 00`;
        const CV_COLOR_DATA = `00 00 00 f0 f0 f0 f0 f0 f0 f0 f0 f0 d0 80 90 b0 30 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00`;

        const DINA_PATTERN_DATA = `00 00 00 00 00 00 00 00 7e 81 bd a1 a1 bd 81 7e 1f 04 04 04 00 00 00 00 44 6c 54 54 00 00 00 00 00 00 00 00 00 00 00 00 00 20 20 20 20 20 00 20 00 50 50 50 00 00 00 00 00 50 50 f8 50 f8 50 50 00 20 78 a0 70 28 f0 20 00 c0 c8 10 20 40 98 18 00 40 a0 a0 40 a8 90 68 00 10 10 10 20 00 00 00 00 20 40 80 80 80 40 20 00 20 10 08 08 08 10 20 00 20 a8 70 20 70 a8 20 00 00 20 20 f8 20 20 00 00 00 00 00 18 18 08 10 00 00 00 00 f8 00 00 00 00 00 00 00 00 00 60 60 00 00 08 10 20 40 80 00 00 70 88 98 a8 c8 88 70 00 20 60 20 20 20 20 70 00 70 88 08 30 40 80 f8 00 f8 08 10 30 08 88 70 00 10 30 50 90 f8 10 10 00 f8 80 f0 08 08 88 70 00 30 40 80 f0 88 88 70 00 f8 08 10 20 40 40 40 00 70 88 88 70 88 88 70 00 70 88 88 78 08 10 e0 00 00 30 30 00 30 30 00 00 18 18 00 18 18 08 10 00 10 20 40 80 40 20 10 00 00 00 f8 00 f8 00 00 00 80 40 20 10 20 40 80 00 70 88 10 20 20 00 20 00 70 88 88 b8 b8 80 78 00 20 50 88 88 f8 88 88 00 f0 88 88 f0 88 88 f0 00 70 88 80 80 80 88 70 00 f0 88 88 88 88 88 f0 00 f8 80 80 f0 80 80 f8 00 f8 80 80 f0 80 80 80 00 78 80 80 b8 88 88 78 00 88 88 88 f8 88 88 88 00 70 20 20 20 20 20 70 00 08 08 08 08 08 88 70 00 88 90 a0 c0 a0 90 88 00 80 80 80 80 80 80 f8 00 88 d8 a8 88 88 88 88 00 88 88 c8 a8 98 88 88 00 70 88 88 88 88 88 70 00 f0 88 88 f0 80 80 80 00 70 88 88 88 a8 90 68 00 f0 88 88 f0 a0 90 88 00 70 88 80 70 08 88 70 00 f8 20 20 20 20 20 20 00 88 88 88 88 88 88 70 00 88 88 88 88 88 50 20 00 88 88 88 a8 a8 d8 88 00 88 88 50 20 50 88 88 00 88 88 50 20 20 20 20 00 f8 08 10 20 40 80 f8 00 f8 80 80 80 80 80 f8 00 00 80 40 20 10 08 00 00 f8 08 08 08 08 08 f8 00 00 00 20 50 88 00 00 00 00 00 00 00 00 00 f8 00 60 60 40 20 00 00 00 00 00 00 68 98 88 98 68 00 80 80 b0 c8 88 c8 b0 00 00 00 78 80 80 80 78 00 08 08 68 98 88 98 68 00 00 00 70 88 f8 80 70 00 10 28 20 f8 20 20 20 00 68 98 98 68 08 08 70 00 80 80 b0 c8 88 88 88 00 20 00 60 20 20 20 70 00 10 00 10 10 10 10 60 00 00 80 90 a0 c0 a0 90 00 60 20 20 20 20 20 70 00 00 00 d0 a8 a8 a8 a8 00 00 00 f0 88 88 88 88 00 00 00 70 88 88 88 70 00 00 b0 c8 c8 b0 80 80 00 00 68 98 98 68 08 08 00 00 00 90 a0 c0 80 80 00 00 00 78 80 70 08 f0 00 20 20 70 20 20 20 30 00 00 00 88 88 88 88 78 00 00 00 88 88 88 50 20 00 00 00 88 88 a8 a8 50 00 00 00 88 50 20 50 88 00 00 00 90 90 f0 10 f0 00 00 00 f8 10 20 40 f8 00 20 40 40 80 40 40 20 00 20 20 20 00 20 20 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 1f 70 01 1f 18 30 3f 20 f8 0e 80 fc 0d 19 fb 33 0c cc cc d9 98 98 31 31 73 e3 07 cc c0 df 80 9f 0c 18 ff 30 60 ff 00 ff 00 00 8f 00 00 1f 03 06 18 30 ff 30 60 ff 00 03 00 00 f1 01 03 e3 03 87 00 00 ff 80 00 00 f8 fc 00 00 f0 00 00 00 7e ff 60 ff e0 7f 60 c0 ff 00 66 e6 0c ec 61 c1 8f 00 63 63 c3 c6 86 87 0d 00 30 30 60 7f 00 00 ff 00 06 06 0c fc 00 00 fc 00 1f 78 30 3f 60 60 ff 00 ff 00 00 ff 01 03 fe 00 e0 c0 c0 84 84 07 03 00 0f 07 07 07 0f fc f8 00 83 83 83 83 83 fe 7c 00`;
        const DINA_COLOR_DATA = `00 00 00 f0 f0 f0 f0 f0 f0 f0 f0 f0 40 70 c0 a0 91 91 91 91 11 00 00 00 00 00 00 00 00 00 00 00`;

        function hexToBytes(src) {
            const cleaned = src.replace(/[^0-9A-Fa-f]/g, ' ').trim();
            if (!cleaned) return new Uint8Array();
            const parts = cleaned.split(/\s+/);
            return new Uint8Array(parts.map(p => parseInt(p, 16) & 0xFF));
        }

        function createTMSOverlay(scale = 3) {
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;z-index:100';
            const canvas = document.createElement('canvas');
            canvas.width = 256 * scale;
            canvas.height = 192 * scale;
            canvas.style.imageRendering = 'pixelated';
            overlay.appendChild(canvas);
            document.body.appendChild(overlay);
            
            const close = () => {
                if (document.body.contains(overlay)) document.body.removeChild(overlay);
                document.removeEventListener('keydown', close);
                document.removeEventListener('click', close);
            };
            
            setTimeout(() => {
                document.addEventListener('keydown', close);
                document.addEventListener('click', close);
            }, 0);
            
            return { ctx: canvas.getContext('2d'), scale, close };
        }

        function blankName() {
            const a = new Uint8Array(768); // 32x24
            a.fill(0x20);
            return a;
        }

        function pasteRect(name, row, col, w, h, flat) {
            for (let r = 0; r < h; r++) {
                for (let c = 0; c < w; c++) {
                    name[(row + r) * 32 + (col + c)] = flat[r * w + c] & 0xFF;
                }
            }
        }

        function putAsciiCenteredCeil(name, row, text = "") {
            const s = text.toUpperCase();
            const start = Math.max(0, Math.ceil((32 - s.length) / 2));
            for (let i = 0; i < s.length && start + i < 32; i++) {
                name[row * 32 + start + i] = s.charCodeAt(i) & 0xFF;
            }
        }

        function putAsciiAt(name, row, col, text = "") {
            const s = text.toUpperCase();
            for (let i = 0; i < s.length && col + i < 32; i++) {
                name[row * 32 + col + i] = s.charCodeAt(i) & 0xFF;
            }
        }

        function colorsFor(tileIndex, colorBytes, defFG = 15, defBG = 1) {
            let FG = defFG, BG = defBG;
            const idx = tileIndex >>> 3;
            if (idx < colorBytes.length) {
                const b = colorBytes[idx] >>> 0;
                FG = (b >>> 4) & 0xF;
                BG = b & 0xF;
                if (FG === 0) FG = defBG;
                if (BG === 0) BG = defBG;
            }
            return [FG, BG];
        }

        function drawTile8(ctx, pat, tileIndex, fg = 15, bg = 1, dx = 0, dy = 0, scale = 3) {
            const baseTile = 0x00E0 >>> 3;
            const local = (tileIndex - baseTile) * 8;
            if (local < 0 || local + 7 >= pat.length) {
                ctx.fillStyle = TMS_PALETTE[bg];
                ctx.fillRect(dx, dy, 8 * scale, 8 * scale);
                return;
            }
            for (let row = 0; row < 8; row++) {
                const b = pat[local + row] >>> 0;
                for (let bit = 7; bit >= 0; bit--) {
                    ctx.fillStyle = ((b >> bit) & 1) ? TMS_PALETTE[fg] : TMS_PALETTE[bg];
                    ctx.fillRect(dx + (7 - bit) * scale, dy + row * scale, scale, scale);
                }
            }
        }

        function drawScreenTo(ctx, scale, name, pat, color, defBG) {
            ctx.fillStyle = TMS_PALETTE[1];
            ctx.fillRect(0, 0, 256 * scale, 192 * scale);
            for (let r = 0; r < 24; r++) {
                for (let c = 0; c < 32; c++) {
                    const v = name[r * 32 + c];
                    const [fg, bg] = colorsFor(v, color, 15, defBG);
                    drawTile8(ctx, pat, v, fg, bg, c * 8 * scale, r * 8 * scale, scale);
                }
            }
        }

        function buildColecoName(title, publisher, year = "1982") {
            const name = blankName();
            pasteRect(name, 4, 5, 24, 2, CV_LOGO_2x24);
            
            if (publisher && title) {
                putAsciiCenteredCeil(name, 14, publisher);
                putAsciiCenteredCeil(name, 16, title);
            } else {
                putAsciiCenteredCeil(name, 13, "TURN GAME OFF");
                putAsciiCenteredCeil(name, 15, "BEFORE INSERTING CARTRIDGE");
                putAsciiCenteredCeil(name, 17, "OR EXPANSION MODULE.");
            }
            
            const base = 21 * 32 + 10;
            name[base + 0] = 0x1D; // ¬© glyph
            name[base + 1] = 0x20; // space
            const y = String(year).replace(/\D+/g, "").padStart(4,' ').slice(-4);
            for (let i = 0; i < 4; i++) name[base + 2 + i] = y.charCodeAt(i) & 0xFF;
            putAsciiAt(name, 21, 16, " COLECO");
            return name;
        }

        function buildDinaName(title, publisher) {
            const name = blankName();
            pasteRect(name, 3, 9, 12, 4, DINA_LOGO_4x12);
            putAsciiAt(name, 9, 6, "BIT CORPORATION 1986");
            putAsciiCenteredCeil(name, 14, publisher || "PRESENTS");
            putAsciiCenteredCeil(name, 16, title || "GAME TITLE");
            return name;
        }

        // Authentic ColecoVision boot screen emulation with proper TMS9918A rendering
        function emulateColecoBootScreen(gameInfo) {
            const pat = hexToBytes(CV_PATTERN_DATA);
            const color = hexToBytes(CV_COLOR_DATA);
            const name = buildColecoName(gameInfo.line3, gameInfo.line2, gameInfo.year);
            
            const { ctx, scale, close } = createTMSOverlay(3);
            drawScreenTo(ctx, scale, name, pat, color, 1);
            
            // Auto-close after 8 seconds (authentic timing) or on user input
            setTimeout(close, 8000);
            
            log(`Emulated authentic ColecoVision boot screen for "${gameInfo.line2}" (8 seconds)`, 'info');
        }

        // DINA 2-in-1 boot screen emulation with proper TMS9918A rendering
        function emulateDinaBoot(gameInfo) {
            const pat = hexToBytes(DINA_PATTERN_DATA);
            const color = hexToBytes(DINA_COLOR_DATA);
            const name = buildDinaName(gameInfo.line3, gameInfo.line2);
            
            const { ctx, scale, close } = createTMSOverlay(3);
            drawScreenTo(ctx, scale, name, pat, color, 2);
            
            // Auto-close after 4 seconds or on user input
            setTimeout(close, 4000);
            
            log('Emulated authentic DINA 2-in-1 boot screen (4 seconds)', 'info');
        }
        // --- DOM Elements ---
        const dropZone = document.getElementById('drop-zone');
        const fileTree = document.getElementById('file-tree');
        const consoleOutput = document.getElementById('console-output');
        const symbolsOutput = document.getElementById('symbols-output');
        const compileBtn = document.getElementById('compile-btn');
        const downloadBtn = document.getElementById('download-btn');
        const exportSymbolsBtn = document.getElementById('export-symbols-btn');
        const cleanProjectBtn = document.getElementById('clean-project-btn');
        const consoleTab = document.getElementById('console-tab');
        const symbolsTab = document.getElementById('symbols-tab');

        // --- Logging Utility ---
        const log = (message, type = 'info') => {
            const time = new Date().toLocaleTimeString();
            const color = {
                info: 'text-gray-400',
                success: 'text-green-400',
                error: 'text-red-400',
                warn: 'text-yellow-400'
            }[type];
            consoleOutput.innerHTML += `<span class="text-gray-600">[${time}]</span> <span class="${color}">${message}</span>\n`;
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        };

        // --- Tab Management ---
        let activeTab = 'console';
        
        const switchTab = (tabName) => {
            activeTab = tabName;
            if (tabName === 'console') {
                consoleTab.classList.add('active');
                symbolsTab.classList.remove('active');
                consoleOutput.classList.remove('hidden');
                symbolsOutput.classList.add('hidden');
            } else {
                symbolsTab.classList.add('active');
                consoleTab.classList.remove('active');
                consoleOutput.classList.add('hidden');
                symbolsOutput.classList.remove('hidden');
            }
        };

        consoleTab.addEventListener('click', () => switchTab('console'));
        symbolsTab.addEventListener('click', () => switchTab('symbols'));

        // --- File Handling ---
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');

            // Check if this is an internal file reorganization or external file drop
            const internalFile = e.dataTransfer.getData('text/plain');
            if (internalFile && projectFiles[internalFile]) {
                // Internal reorganization - move to root folder
                const fileName = extractFilename(internalFile);
                if (internalFile !== fileName) {
                    projectFiles[fileName] = projectFiles[internalFile];
                    delete projectFiles[internalFile];

                    if (projectManifest.mainFile === internalFile) {
                        projectManifest.mainFile = fileName;
                    }
                    if (currentFile === internalFile) {
                        currentFile = fileName;
                    }

                    updateManifest();
                    renderFileTree();
                    log(`Moved ${fileName} to root folder`, 'success');
                }
            } else {
                // External file drop
                handleFiles(e.dataTransfer.files);
            }
        });

        // Mobile-friendly: Click to browse files
        const fileInput = document.getElementById('file-input');

        dropZone.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFiles(e.target.files);
            }
        });

        async function handleFiles(files) {
            // Don't clear existing files - add to project instead
            // projectFiles = {};  // OLD: This cleared everything!
            log('Adding files to project...');

            let filesAdded = 0;
            const newFiles = [];

            for (const file of files) {
                const filename = file.name;
                if (filename.toLowerCase().endsWith('.zip')) {
                    await handleZipFile(file);
                    filesAdded++;
                } else if (filename.toLowerCase().endsWith('.gz')) {
                    await handleGzFile(file);
                    filesAdded++;
                } else {
                    await handleSingleFile(file);
                    newFiles.push(filename);
                    filesAdded++;
                }
            }

            log(`Added ${filesAdded} file(s) to project`, 'success');

            // Auto-detect main file if not set
            if (!projectManifest.mainFile) {
                const asmFiles = Object.keys(projectFiles).filter(f => /\.(asm|z80|s)$/i.test(f));
                if (asmFiles.length > 0) {
                    // Prefer files with "main", "start", or "header" in name
                    const mainCandidate = asmFiles.find(f =>
                        f.toLowerCase().includes('main') ||
                        f.toLowerCase().includes('start') ||
                        f.toLowerCase().includes('header')
                    ) || asmFiles[0];
                    projectManifest.mainFile = mainCandidate;
                    log(`Set main file: ${mainCandidate}`, 'info');
                }
            }

            updateManifest();
            renderFileTree();

            // Automatically open the first newly added .asm or .z80 file or main file
            const firstNewAsm = newFiles.find(f => {
                const lower = f.toLowerCase();
                return lower.endsWith('.asm') || lower.endsWith('.z80');
            });
            if (firstNewAsm) {
                openFile(firstNewAsm);
            } else if (projectManifest.mainFile) {
                openFile(projectManifest.mainFile);
            }
        }

        async function handleZipFile(file) {
            const zip = await JSZip.loadAsync(file);

            // Check for project.json manifest
            const manifestFile = zip.file('project.json');
            let manifest = null;

            if (manifestFile) {
                const manifestText = await manifestFile.async('text');
                try {
                    manifest = JSON.parse(manifestText);
                    log(`üì¶ Loading structured project: ${manifest.name}`, 'info');
                    projectManifest = { ...projectManifest, ...manifest };
                } catch (e) {
                    log('Warning: project.json found but invalid', 'warn');
                }
            }

            // Extract all files preserving folder structure
            for (const [relativePath, zipEntry] of Object.entries(zip.files)) {
                if (!zipEntry.dir) {
                    const content = await zipEntry.async('uint8array');
                    projectFiles[relativePath] = content;
                    log(`Unzipped: ${relativePath}`);
                }
            }

            // Apply manifest settings if available
            if (manifest) {
                if (manifest.mainFile) {
                    currentFile = manifest.mainFile;
                }
                if (manifest.build?.relFormat) {
                    const outputDropdown = document.getElementById('output-mode');
                    if (outputDropdown) {
                        outputDropdown.value = manifest.build.relFormat;
                    }
                }
            }
        }

        async function handleGzFile(file) {
            const buffer = await file.arrayBuffer();
            const decompressed = pako.inflate(new Uint8Array(buffer));
            const originalName = file.name.replace(/\.gz$/i, '');
            projectFiles[originalName] = decompressed;
            log(`Decompressed: ${originalName}`);
        }

        async function handleSingleFile(file) {
            const content = await file.arrayBuffer().then(b => new Uint8Array(b));
            projectFiles[file.name] = content;
            log(`Loaded: ${file.name}`);
        }

        // File type classification system
        const FILE_TYPES = {
            SOURCE: {
                extensions: ['.asm', '.z80', '.s'],
                icon: '‚öôÔ∏è',
                color: '#3b82f6',
                editable: true,
                compilable: true
            },
            INCLUDE: {
                extensions: ['.inc', '.h'],
                icon: 'üìã',
                color: '#60a5fa',
                editable: true,
                compilable: false
            },
            OBJECT: {
                extensions: ['.rel', '.o', '.obj'],
                icon: 'üì¶',
                color: '#a855f7',
                editable: false,
                compilable: false
            },
            LIBRARY: {
                extensions: ['.lib', '.a'],
                icon: 'üìö',
                color: '#f97316',
                editable: false,
                compilable: false
            },
            BINARY: {
                extensions: ['.bin', '.rom', '.col'],
                icon: 'üíæ',
                color: '#10b981',
                editable: false,
                compilable: false
            },
            COMPRESSED: {
                extensions: ['.zx0', '.zx7', '.pletter', '.rle', '.lz4', '.aplib'],
                icon: 'üóúÔ∏è',
                color: '#fbbf24',
                editable: false,
                compilable: false,
                isAsset: true
            },
            GRAPHICS: {
                extensions: ['.gfx', '.chr', '.spr', '.til', '.pcx', '.scr', '.psg'],
                icon: 'üé®',
                color: '#ec4899',
                editable: false,
                compilable: false,
                isAsset: true
            },
            DATA: {
                extensions: ['.dat', '.raw', '.map', '.lvl', '.tbl'],
                icon: 'üìä',
                color: '#06b6d4',
                editable: false,
                compilable: false,
                isAsset: true
            },
            ARCHIVE: {
                extensions: ['.zip', '.gz', '.tar'],
                icon: 'üì¶',
                color: '#fbbf24',
                editable: false,
                compilable: false
            },
            PROJECT: {
                extensions: ['.json', '.toml', '.yaml', '.cfg'],
                icon: '‚öôÔ∏è',
                color: '#64748b',
                editable: true,
                compilable: false
            },
            DOCS: {
                extensions: ['.md', '.txt'],
                icon: 'üìÑ',
                color: '#94a3b8',
                editable: true,
                compilable: false
            }
        };

        function getFileType(filename) {
            const lowerName = filename.toLowerCase();
            for (const [typeName, typeInfo] of Object.entries(FILE_TYPES)) {
                for (const ext of typeInfo.extensions) {
                    if (lowerName.endsWith(ext)) {
                        return { ...typeInfo, typeName };
                    }
                }
            }
            // Default type for unknown extensions
            return {
                icon: 'üìÑ',
                color: '#e2e8f0',
                editable: false,
                compilable: false,
                typeName: 'UNKNOWN'
            };
        }

        // Project manifest management
        let projectManifest = {
            name: 'untitled-project',
            version: '1.0.0',
            type: 'colecovision-rom',
            mainFile: null,
            outputFormat: 'binary',
            files: {},
            libraryPaths: [],
            build: {
                relFormat: 'binary',
                outputName: 'output.bin'
            }
        };

        function updateManifest() {
            // Update files list
            projectManifest.files = {};
            for (const filename of Object.keys(projectFiles)) {
                if (filename === 'project.json') continue;
                const fileType = getFileType(filename);
                const folder = extractFolder(filename);
                projectManifest.files[filename] = {
                    type: fileType.typeName.toLowerCase(),
                    folder: folder || ''
                };
            }

            // Update output format from dropdown
            const outputMode = document.getElementById('output-mode')?.value;
            if (outputMode) {
                projectManifest.build.relFormat = outputMode;
            }
        }

        function extractFolder(filepath) {
            const lastSlash = Math.max(filepath.lastIndexOf('/'), filepath.lastIndexOf('\\'));
            return lastSlash > 0 ? filepath.substring(0, lastSlash) : '';
        }

        function extractFilename(filepath) {
            const lastSlash = Math.max(filepath.lastIndexOf('/'), filepath.lastIndexOf('\\'));
            return lastSlash >= 0 ? filepath.substring(lastSlash + 1) : filepath;
        }

        function renderFileTree() {
            fileTree.innerHTML = '';
            const sortedFiles = Object.keys(projectFiles).sort();

            // Update file count badge
            const fileCountBadge = document.getElementById('file-count');
            if (fileCountBadge) {
                fileCountBadge.textContent = sortedFiles.length;
                if (sortedFiles.length > 0) {
                    fileCountBadge.style.background = '#3b82f6';
                    fileCountBadge.style.color = '#ffffff';
                } else {
                    fileCountBadge.style.background = '#334155';
                    fileCountBadge.style.color = '#94a3b8';
                }
            }

            if (sortedFiles.length === 0) {
                 fileTree.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #94a3b8;">
                        <div style="font-size: 32px; margin-bottom: 8px;">üìÅ</div>
                        <div style="font-size: 14px;">No files in project</div>
                        <div style="font-size: 12px; margin-top: 4px; color: #64748b;">Drag and drop files here to start</div>
                    </div>
                 `;
                 return;
            }
            sortedFiles.forEach(filename => {
                const item = document.createElement('div');

                // Pro version: Style .REL files differently
                // Create file item with download button
                const itemContainer = document.createElement('div');
                itemContainer.style.display = 'flex';
                itemContainer.style.justifyContent = 'space-between';
                itemContainer.style.alignItems = 'center';

                const fileLabel = document.createElement('span');
                fileLabel.style.flex = '1';
                fileLabel.style.cursor = 'pointer';
                fileLabel.style.display = 'flex';
                fileLabel.style.alignItems = 'center';
                fileLabel.style.gap = '8px';

                // Determine file type using classification system
                const fileType = getFileType(filename);
                const displayName = extractFilename(filename);
                const folder = extractFolder(filename);

                // Add main file indicator
                const isMainFile = (projectManifest.mainFile === filename);
                const mainStar = isMainFile ? '<span style="color: #fbbf24; margin-right: 2px;">‚≠ê</span>' : '';

                // Show folder path if exists
                const folderHint = folder ? `<span style="color: #64748b; font-size: 11px; margin-left: 4px;">${folder}/</span>` : '';

                fileLabel.innerHTML = `${mainStar}<span style="font-size: 16px;">${fileType.icon}</span><span style="color: ${fileType.color}; font-weight: 500;">${displayName}</span>${folderHint}`;
                fileLabel.onclick = () => openFile(filename);
                fileLabel.oncontextmenu = (e) => showContextMenu(e, filename);

                // Make file draggable for reorganization
                fileLabel.draggable = true;
                fileLabel.ondragstart = (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', filename);
                    item.style.opacity = '0.5';
                };
                fileLabel.ondragend = (e) => {
                    item.style.opacity = '1';
                };

                // Make file items drop targets (to organize into same folder)
                item.ondragover = (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    if (e.target === item || item.contains(e.target)) {
                        item.style.background = '#475569';
                        item.style.borderColor = '#3b82f6';
                    }
                };
                item.ondragleave = (e) => {
                    if (e.target === item || item.contains(e.target)) {
                        item.style.background = '';
                        item.style.borderColor = '';
                    }
                };
                item.ondrop = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    item.style.background = '';
                    item.style.borderColor = '';

                    const draggedFile = e.dataTransfer.getData('text/plain');
                    if (draggedFile && draggedFile !== filename) {
                        // Move dragged file to same folder as target
                        const targetFolder = extractFolder(filename);
                        const draggedName = extractFilename(draggedFile);
                        const newPath = targetFolder ? `${targetFolder}/${draggedName}` : draggedName;

                        if (newPath !== draggedFile) {
                            projectFiles[newPath] = projectFiles[draggedFile];
                            delete projectFiles[draggedFile];

                            if (projectManifest.mainFile === draggedFile) {
                                projectManifest.mainFile = newPath;
                            }
                            if (currentFile === draggedFile) {
                                currentFile = newPath;
                            }

                            updateManifest();
                            renderFileTree();
                            log(`Moved ${draggedName} to ${targetFolder || 'root'}`, 'success');
                        }
                    }
                };

                // Add download button
                const downloadIcon = document.createElement('span');
                downloadIcon.innerHTML = 'üíæ';
                downloadIcon.style.cursor = 'pointer';
                downloadIcon.style.marginLeft = '8px';
                downloadIcon.style.fontSize = '16px';
                downloadIcon.style.padding = '4px 6px';
                downloadIcon.style.borderRadius = '4px';
                downloadIcon.style.transition = 'all 0.2s ease';
                downloadIcon.title = 'Download file';
                downloadIcon.onmouseenter = () => {
                    downloadIcon.style.background = '#3b82f6';
                    downloadIcon.style.transform = 'scale(1.2)';
                };
                downloadIcon.onmouseleave = () => {
                    downloadIcon.style.background = 'transparent';
                    downloadIcon.style.transform = 'scale(1)';
                };
                downloadIcon.onclick = (e) => {
                    e.stopPropagation();
                    downloadProjectFile(filename);
                };

                // Add rename button
                const renameIcon = document.createElement('span');
                renameIcon.innerHTML = '‚úèÔ∏è';
                renameIcon.style.cursor = 'pointer';
                renameIcon.style.marginLeft = '4px';
                renameIcon.style.fontSize = '16px';
                renameIcon.style.padding = '4px 6px';
                renameIcon.style.borderRadius = '4px';
                renameIcon.style.transition = 'all 0.2s ease';
                renameIcon.title = 'Rename file';
                renameIcon.onmouseenter = () => {
                    renameIcon.style.background = '#f59e0b';
                    renameIcon.style.transform = 'scale(1.2)';
                };
                renameIcon.onmouseleave = () => {
                    renameIcon.style.background = 'transparent';
                    renameIcon.style.transform = 'scale(1)';
                };
                renameIcon.onclick = (e) => {
                    e.stopPropagation();
                    renameFileIcon(filename);
                };

                // Add delete button
                const deleteIcon = document.createElement('span');
                deleteIcon.innerHTML = 'üóëÔ∏è';
                deleteIcon.style.cursor = 'pointer';
                deleteIcon.style.marginLeft = '4px';
                deleteIcon.style.fontSize = '16px';
                deleteIcon.style.padding = '4px 6px';
                deleteIcon.style.borderRadius = '4px';
                deleteIcon.style.transition = 'all 0.2s ease';
                deleteIcon.title = 'Delete file from project';
                deleteIcon.onmouseenter = () => {
                    deleteIcon.style.background = '#ef4444';
                    deleteIcon.style.transform = 'scale(1.2)';
                };
                deleteIcon.onmouseleave = () => {
                    deleteIcon.style.background = 'transparent';
                    deleteIcon.style.transform = 'scale(1)';
                };
                deleteIcon.onclick = (e) => {
                    e.stopPropagation();
                    deleteProjectFile(filename);
                };

                itemContainer.appendChild(fileLabel);
                itemContainer.appendChild(downloadIcon);
                itemContainer.appendChild(renameIcon);
                itemContainer.appendChild(deleteIcon);

                item.className = 'file-tree-item';
                if (filename === currentFile) {
                    item.classList.add('active');
                }
                item.appendChild(itemContainer);
                fileTree.appendChild(item);
            });
            updateCompileButtonState();

            // Pro version: Update link button visibility when files change
            if (typeof updateLinkButtonVisibility === 'function') {
                updateLinkButtonVisibility();
            }
        }

        // Simple check: is this a text source file?
        function isEditableTextFile(filename) {
            const lower = filename.toLowerCase();
            return lower.endsWith('.asm') ||
                   lower.endsWith('.z80') ||
                   lower.endsWith('.s') ||
                   lower.endsWith('.inc') ||
                   lower.endsWith('.h') ||
                   lower.endsWith('.txt');
        }

        async function openFile(filename) {
            if (!projectFiles[filename]) {
                log(`File not found: ${filename}`, 'error');
                return;
            }

            currentFile = filename;

            // Update file header display
            document.getElementById('current-file-name').textContent = filename;
            const content = projectFiles[filename];

            // Set editor to read-only by default, will be set to editable only for text files
            editor.setOption('readOnly', true);

            // Pro version: Handle .LIB files specially
            if (filename.toLowerCase().endsWith('.lib')) {
                try {
                    const zip = await JSZip.loadAsync(content);
                    const moduleInfos = [];

                    // Parse all .REL files in the library
                    for (const [relFilename, file] of Object.entries(zip.files)) {
                        if (!file.dir && relFilename.toLowerCase().endsWith('.rel')) {
                            try {
                                const relData = await file.async('uint8array');
                                const parser = new RelFileParser(relData);
                                const module = parser.parse();
                                moduleInfos.push({
                                    filename: relFilename,
                                    module: module
                                });
                            } catch (e) {
                                moduleInfos.push({
                                    filename: relFilename,
                                    error: e.message
                                });
                            }
                        }
                    }

                    // Display .LIB file information in editor
                    let libInfo = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n`;
                    libInfo += `‚ïë  LIBRARY FILE: ${filename.padEnd(48)}‚ïë\n`;
                    libInfo += `‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n`;

                    libInfo += `Total Modules: ${moduleInfos.length}\n\n`;

                    if (moduleInfos.length === 0) {
                        libInfo += `(Empty library - no .REL files found)\n`;
                    } else {
                        // Summary statistics
                        const validModules = moduleInfos.filter(m => !m.error);
                        const totalPublicSymbols = validModules.reduce((sum, m) => sum + m.module.publicSymbols.length, 0);
                        const totalCodeSize = validModules.reduce((sum, m) => sum + m.module.codeSize, 0);
                        const totalDataSize = validModules.reduce((sum, m) => sum + m.module.dataSize, 0);

                        libInfo += `Summary:\n`;
                        libInfo += `  Valid Modules: ${validModules.length}\n`;
                        libInfo += `  Total Public Symbols: ${totalPublicSymbols}\n`;
                        libInfo += `  Total Code Size: ${totalCodeSize} bytes\n`;
                        libInfo += `  Total Data Size: ${totalDataSize} bytes\n\n`;

                        libInfo += `${'‚ïê'.repeat(63)}\n\n`;

                        // List each module
                        moduleInfos.forEach((info, index) => {
                            libInfo += `Module ${index + 1}: ${info.filename}\n`;
                            libInfo += `${'‚îÄ'.repeat(63)}\n`;

                            if (info.error) {
                                libInfo += `  ERROR: ${info.error}\n\n`;
                            } else {
                                const m = info.module;
                                libInfo += `  Module Name: ${m.name || 'Unknown'}\n`;
                                libInfo += `  Code Size: ${m.codeSize} bytes\n`;
                                libInfo += `  Data Size: ${m.dataSize} bytes\n`;

                                if (m.publicSymbols.length > 0) {
                                    libInfo += `\n  Exported Symbols (${m.publicSymbols.length}):\n`;
                                    m.publicSymbols.forEach(sym => {
                                        const addrTypeStr = sym.addressType === 0x01 ? 'CODE' :
                                                          sym.addressType === 0x02 ? 'DATA' : 'OTHER';
                                        libInfo += `    ‚Ä¢ ${sym.name.padEnd(24)} = $${sym.value.toString(16).padStart(4, '0').toUpperCase()} (${addrTypeStr})\n`;
                                    });
                                }

                                if (m.externalRefs.length > 0) {
                                    const uniqueExternals = [...new Set(m.externalRefs.map(r => r.symbol))];
                                    libInfo += `\n  External Dependencies (${uniqueExternals.length}):\n`;
                                    uniqueExternals.forEach(sym => {
                                        const refs = m.externalRefs.filter(r => r.symbol === sym);
                                        libInfo += `    ‚Ä¢ ${sym} (${refs.length} reference${refs.length > 1 ? 's' : ''})\n`;
                                    });
                                }

                                libInfo += '\n';
                            }
                        });

                        libInfo += `${'‚ïê'.repeat(63)}\n\n`;
                    }

                    libInfo += `USAGE:\n`;
                    libInfo += `  This library can be used during linking. The smart linker will\n`;
                    libInfo += `  automatically include only the modules needed by your program.\n\n`;
                    libInfo += `  To use:\n`;
                    libInfo += `  1. Add this .LIB file to your project\n`;
                    libInfo += `  2. Compile your .asm files to .REL format\n`;
                    libInfo += `  3. Switch output mode to Binary (.bin)\n`;
                    libInfo += `  4. Click "Link Modules" to create the final binary\n`;

                    editor.setValue(libInfo);
                    // readOnly already set at start of openFile()

                    // Hide download button for .LIB files (each file has its own download icon)
                    downloadBtn.classList.add('hidden');

                    log(`Loaded library: ${filename} with ${moduleInfos.length} module(s)`, 'success');
                    if (moduleInfos.length > 0) {
                        const validModules = moduleInfos.filter(m => !m.error);
                        const totalPublicSymbols = validModules.reduce((sum, m) => sum + m.module.publicSymbols.length, 0);
                        log(`  ${validModules.length} valid modules, ${totalPublicSymbols} exported symbols`, 'info');
                    }
                } catch (e) {
                    editor.setValue(`--- ERROR PARSING .LIB FILE ---\n\n${e.message}\n\nNote: .LIB files should be ZIP archives containing .REL files`);
                    // readOnly already set at start of openFile()
                    log(`Error parsing .LIB file: ${e.message}`, 'error');
                }
            }
            // Pro version: Handle .REL files specially
            else if (filename.toLowerCase().endsWith('.rel')) {
                try {
                    // Create a copy to avoid parser modifying the original data
                    const parser = new RelFileParser(content.slice(0));
                    const module = parser.parse();

                    // Display .REL file information in editor
                    let relInfo = `--- RELOCATABLE OBJECT FILE: ${filename} ---\n\n`;
                    relInfo += `Module Name: ${module.name || 'Unknown'}\n\n`;
                    relInfo += `Code Size: ${module.codeSize} bytes\n`;
                    relInfo += `Data Size: ${module.dataSize} bytes\n\n`;

                    if (module.publicSymbols.length > 0) {
                        relInfo += `Public Symbols (${module.publicSymbols.length}):\n`;
                        module.publicSymbols.forEach(sym => {
                            const addrTypeStr = sym.addressType === 0x01 ? 'CODE' : sym.addressType === 0x02 ? 'DATA' : 'OTHER';
                            relInfo += `  ${sym.name} = 0x${sym.value.toString(16).padStart(4, '0')} (${addrTypeStr})\n`;
                        });
                        relInfo += '\n';
                    }

                    if (module.externalRefs.length > 0) {
                        relInfo += `External References (${module.externalRefs.length}):\n`;
                        const uniqueExternals = [...new Set(module.externalRefs.map(r => r.symbol))];
                        uniqueExternals.forEach(sym => {
                            const refs = module.externalRefs.filter(r => r.symbol === sym);
                            relInfo += `  ${sym} (${refs.length} reference${refs.length > 1 ? 's' : ''})\n`;
                        });
                        relInfo += '\n';
                    }

                    if (module.relocations.length > 0) {
                        relInfo += `Relocations: ${module.relocations.length}\n\n`;
                    }

                    relInfo += `--- This .REL file can be linked with other modules ---\n`;
                    relInfo += `Use the "Link Modules" button when in Binary output mode.\n`;

                    editor.setValue(relInfo);
                    // readOnly already set at start of openFile()

                    // Hide download button for .REL files (each file has its own download icon)
                    downloadBtn.classList.add('hidden');

                    log(`Loaded relocatable object: ${filename}`, 'success');
                    log(`  Module: ${module.name}, Code: ${module.codeSize}B, Data: ${module.dataSize}B`, 'info');
                    log(`  Exports: ${module.publicSymbols.length}, Imports: ${module.externalRefs.length}`, 'info');
                } catch (e) {
                    editor.setValue(`--- ERROR PARSING .REL FILE ---\n\n${e.message}`);
                    // readOnly already set at start of openFile()
                    log(`Error parsing .REL file: ${e.message}`, 'error');
                }
            } else {
                // Simple logic: if it's a text file (.asm, .z80, .s, .inc, .h, .txt), make it editable
                if (isEditableTextFile(filename)) {
                    try {
                        const decoder = new TextDecoder('utf-8', { fatal: false }); // Allow malformed sequences
                        const textContent = decoder.decode(content);
                        editor.setValue(textContent);
                        editor.setOption('readOnly', false); // ONLY text files are editable
                        log(`Opened text file: ${filename}`);
                    } catch (e) {
                        editor.setValue(`--- ERROR OPENING FILE: ${filename} ---\n\n${e.message}`);
                        // readOnly already set at start of openFile()
                        log(`Error opening file: ${e.message}`, 'error');
                    }
                } else {
                    // Everything else is read-only (binary, compiled, etc.)
                    editor.setValue(`--- BINARY FILE: ${filename} ---\n\nCannot display content.\n\nThis file is read-only.`);
                    // readOnly already set at start of openFile()
                    log(`Opened binary file: ${filename}`);
                    downloadBtn.classList.add('hidden');
                }
            }

            renderFileTree();
        }

        editor.on("change", () => {
            if (currentFile) {
                // Simple: only save if it's a text file
                if (isEditableTextFile(currentFile)) {
                    const textEncoder = new TextEncoder();
                    projectFiles[currentFile] = textEncoder.encode(editor.getValue());
                }
            }
            updateCompileButtonState();
        });

        function updateCompileButtonState() {
            const hasAsmFile = Object.keys(projectFiles).some(f => {
                const lower = f.toLowerCase();
                return lower.endsWith('.asm') || lower.endsWith('.z80');
            });
            const editorContent = editor.getValue();
            // A very basic check for Z80 code
            const seemsLikeZ80 = /ld|jp|call|ret/i.test(editorContent);
            compileBtn.disabled = !(hasAsmFile || (editorContent.trim() && seemsLikeZ80));
        }

        // --- Parser Classes ---
        class Instruction {
            constructor(label, mnemonic, operands, lineNumber = 0, sourceLine = '') {
                this.label = label;
                this.mnemonic = mnemonic;
                this.operands = operands;
                this.lineNumber = lineNumber;
                this.sourceLine = sourceLine;
            }
        }

        class Directive {
            constructor(label, name, operands, lineNumber = 0, sourceLine = '') {
                this.label = label;
                this.name = name;
                this.operands = operands;
                this.lineNumber = lineNumber;
                this.sourceLine = sourceLine;
            }
        }

        class Operand {
            constructor(type, value) { 
                this.type = type; 
                this.value = value; 
            }
        }
        
        // Enhanced Number Parser with multiple format support
        class NumberParser {
            constructor() {
                this.defaultRadix = 10;
                this.syntaxModes = {
                    intel: true,
                    motorola: true,
                    c: true,
                    ibm: true
                };
            }

            parseNumber(str) {
                if (!str) return null;

                // Remove whitespace
                str = str.trim();
                if (!str) return null;

                // Reject expressions with arithmetic operators - these should be evaluated as expressions
                // Check for operators outside of quotes (but allow negative numbers with leading -)
                if (/[\+\*\/]/.test(str) || (/-/.test(str.substring(1)))) {
                    return null;  // This is an expression, not a simple number
                }

                // Try different number formats
                
                // Motorola/Intel: $hex
                if (str.startsWith('$')) {
                    return parseInt(str.substring(1), 16);
                }
                
                // C style: 0x/0X hex, 0b binary, 0 octal
                if (str.startsWith('0x') || str.startsWith('0X')) {
                    return parseInt(str, 16);
                }
                if (str.startsWith('0b') || str.startsWith('0B')) {
                    return parseInt(str.substring(2), 2);
                }
                if (str.startsWith('0') && str.length > 1 && /^[0-7]+$/.test(str.substring(1))) {
                    return parseInt(str, 8);
                }
                
                // Intel suffix: hex with H, binary with B, octal with O/Q
                if (/^[0-9a-fA-F]+[hH]$/.test(str)) {
                    return parseInt(str.slice(0, -1), 16);
                }
                if (/^[01]+[bB]$/.test(str)) {
                    return parseInt(str.slice(0, -1), 2);
                }
                if (/^[0-7]+[oOqQ]$/.test(str)) {
                    return parseInt(str.slice(0, -1), 8);
                }
                
                // Motorola prefix: %binary, @octal
                if (str.startsWith('%')) {
                    return parseInt(str.substring(1), 2);
                }
                if (str.startsWith('@')) {
                    return parseInt(str.substring(1), 8);
                }
                
                // IBM style: x'hex', h'hex', o'oct', b'bin'
                const ibmMatch = str.match(/^([xhobXHOB])'([^']*)'?$/);
                if (ibmMatch) {
                    const [, prefix, value] = ibmMatch;
                    switch (prefix.toLowerCase()) {
                        case 'x':
                        case 'h':
                            return parseInt(value, 16);
                        case 'o':
                            return parseInt(value, 8);
                        case 'b':
                            return parseInt(value, 2);
                    }
                }
                
                // ASCII/Character constants
                if (str.startsWith("'") && str.endsWith("'") && str.length >= 3) {
                    const chars = str.slice(1, -1);
                    let result = 0;
                    for (let i = 0; i < chars.length; i++) {
                        result = (result << 8) | chars.charCodeAt(i);
                    }
                    return result;
                }
                
                // Default decimal
                if (/^\d+$/.test(str)) {
                    return parseInt(str, this.defaultRadix);
                }
                
                return null;
            }
        }

        // Enhanced Lexer with temporary symbol support
        class Lexer {
            constructor(code) {
                this.code = code;
                this.tokens = [];
                this.numberParser = new NumberParser();
                this.directives = ['CPU', 'FNAME', 'EQU', 'EVAL', 'CONSTANT', 'ORG', 'DW', 'DEFW', 'WORD', 'DS', 'DEFS', 'DB', 'DEFB', 'DEFM', 'ASCII', 'TEXT', 'BYTE', 'INCLUDE', 'INCBIN', 'MACRO', 'ENDM', 'REPT', 'ENDR', 'IF', 'ENDIF', 'ELSE', 'ELIF', 'COND', 'ENDC', 'SECTION', 'ENDSECTION', 'RADIX', 'INTSYNTAX', 'RELAXED', 'PADDING', 'END', 'PUBLIC', 'GLOBAL', 'GLOBL', 'ENTRY', 'EXTERN', 'EXT', 'EXTRN', 'CSEG', 'DSEG', 'ASEG', 'COMMON', 'AREA', 'MODULE'];
                this.tempSymbolCounters = {
                    named: 0,
                    plus: 0,
                    minus: 0,
                    slash: 0
                };
            }

            parse_operands(operands_str) {
                const operands = [];
                if (!operands_str) return operands;

                // Improved parsing to handle parentheses properly
                const parts = [];
                let current = '';
                let depth = 0;
                let inQuotes = false;
                let quoteChar = '';
                
                for (let i = 0; i < operands_str.length; i++) {
                    const char = operands_str[i];
                    
                    if (inQuotes) {
                        if (char === quoteChar) {
                            inQuotes = false;
                            quoteChar = '';
                        } 
                        current += char;
                    } else {
                        if (char === '(') {
                            depth++;
                            current += char;
                        } else if (char === ')') {
                            depth--;
                            current += char;
                        } else if (char === ',' && depth === 0) {
                            if (current.trim()) {
                                parts.push(current.trim());
                            }
                            current = '';
                        } else if ((char === '"' || char === "'") && (i === 0 || operands_str[i-1] !== '\\')) {
                            inQuotes = true;
                            quoteChar = char;
                            current += char;
                        } else {
                            current += char;
                        }
                    }
                }
                
                if (current.trim()) {
                    parts.push(current.trim());
                }
                
                for (let part of parts) {
                    part = part.trim();
                    if (!part) continue;
                    
                    // Try to parse as number first
                    const numValue = this.numberParser.parseNumber(part);
                    if (numValue !== null) {
                        operands.push(new Operand('immediate', numValue));
                        continue;
                    }
                    
                    // Check for registers
                    if (/^(A|B|C|D|E|H|L|I|R|IXH|IXL|IYH|IYL)$/i.test(part)) {
                        operands.push(new Operand('register', part.toUpperCase()));
                        continue;
                    }
                    
                    if (/^(AF|BC|DE|HL|SP|IX|IY|AF\')$/i.test(part)) {
                        operands.push(new Operand('register_pair', part.toUpperCase()));
                        continue;
                    }
                    
                    if (/^(NZ|Z|NC|C|PO|PE|P|M)$/i.test(part)) {
                        operands.push(new Operand('condition', part.toUpperCase()));
                        continue;
                    }
                    
                    // Memory operands
                    if (part.startsWith('(') && part.endsWith(')')) {
                        const innerContent = part.slice(1, -1);
                        const innerNum = this.numberParser.parseNumber(innerContent);
                        if (innerNum !== null) {
                            operands.push(new Operand('memory', innerNum));
                        } else {
                            // It's a symbol inside parentheses
                            operands.push(new Operand('memory', innerContent));
                        }
                        continue;
                    }
                    
                    // Single character constants (both " and ') - convert to immediate ASCII value
                    if ((part.startsWith('"') && part.endsWith('"') && part.length === 3) ||
                        (part.startsWith("'") && part.endsWith("'") && part.length === 3)) {
                        const charValue = part.charCodeAt(1); // Get ASCII value
                        operands.push(new Operand('immediate', charValue));
                        continue;
                    }

                    // Multi-character string literals
                    if ((part.startsWith('"') && part.endsWith('"')) ||
                        (part.startsWith("'") && part.endsWith("'"))) {
                        operands.push(new Operand('string', part.slice(1, -1)));
                        continue;
                    }

                    // Everything else is a symbol
                    operands.push(new Operand('symbol', part));
                }
                return operands;
            }

            tokenize() {
                const lines = this.code.split('\n');
                for (let lineNum = 0; lineNum < lines.length; lineNum++) {
                    const line = lines[lineNum];
                    let trimmedLine = line.split(';')[0].trim();
                    if (!trimmedLine) continue;

                    const parts = trimmedLine.match(/(?:[^\s"']+|"[^"]*"|'[^']*'|AF')+/g) || [];
                    if (parts.length === 0) continue;

                    let label = null;
                    let mnemonic = parts[0];
                    let operands_str = parts.slice(1).join(' ');

                    // Handle temporary symbols and labels
                    if (parts[0].endsWith(':')) {
                        label = parts[0].slice(0, -1);
                        
                        // Process temporary symbols
                        if (label.startsWith('$$')) {
                            // Named temporary symbol
                            label = `__temp_named_${this.tempSymbolCounters.named}_${label.substring(2)}`;
                        } else if (label === '+' || label === '-' || label === '/') {
                            // Nameless temporary symbol
                            if (label === '+') {
                                label = `__temp_plus_${this.tempSymbolCounters.plus}`;
                                this.tempSymbolCounters.plus++;
                            } else if (label === '-') {
                                label = `__temp_minus_${this.tempSymbolCounters.minus}`;
                                this.tempSymbolCounters.minus++;
                            } else if (label === '/') {
                                label = `__temp_slash_${this.tempSymbolCounters.slash}`;
                                this.tempSymbolCounters.slash++;
                            }
                        }
                        
                        mnemonic = parts.length > 1 ? parts[1] : null;
                        operands_str = parts.slice(2).join(' ');
                    } 
                    else if (parts.length > 1) {
                        // Check if second part is a directive (with or without dot prefix)
                        let checkMnemonic = parts[1].toUpperCase();
                        if (checkMnemonic.startsWith('.')) {
                            checkMnemonic = checkMnemonic.substring(1);
                        }
                        if (this.directives.includes(checkMnemonic)) {
                            label = parts[0];
                            mnemonic = parts[1];
                            operands_str = parts.slice(2).join(' ');
                        }
                    }

                    if (!mnemonic) {
                        if (label) this.tokens.push(new Directive(label, 'LABEL', [], lineNum + 1, line));
                        continue;
                    }

                    // Handle SDCC-style directives with dot prefix (.area, .module, .globl, .ds)
                    let mnemonic_upper = mnemonic.toUpperCase();
                    if (mnemonic_upper.startsWith('.')) {
                        mnemonic_upper = mnemonic_upper.substring(1); // Remove leading dot
                    }

                    const operands = this.parse_operands(operands_str || '');

                    if (this.directives.includes(mnemonic_upper)) {
                        this.tokens.push(new Directive(label, mnemonic_upper, operands, lineNum + 1, line));
                    } else {
                        this.tokens.push(new Instruction(label, mnemonic.toLowerCase(), operands, lineNum + 1, line));
                    }
                }
                return this.tokens;
            }
        }

        // --- Complete Z80 Opcode Table (Enhanced) ---
        const Z80_OPCODES = {
            'nop': [0x00], 'ld_bc,imm16': [0x01], 'ld_(bc),a': [0x02], 'inc_bc': [0x03], 'inc_b': [0x04], 'dec_b': [0x05], 'ld_b,imm8': [0x06], 'rlca': [0x07],
            'ex_af,af': [0x08], 'ex_af,af\'': [0x08], 'add_hl,bc': [0x09], 'ld_a,(bc)': [0x0A], 'dec_bc': [0x0B], 'inc_c': [0x0C], 'dec_c': [0x0D], 'ld_c,imm8': [0x0E], 'rrca': [0x0F],
            'djnz_rel8': [0x10], 'ld_de,imm16': [0x11], 'ld_(de),a': [0x12], 'inc_de': [0x13], 'inc_d': [0x14], 'dec_d': [0x15], 'ld_d,imm8': [0x16], 'rla': [0x17],
            'jr_rel8': [0x18], 'add_hl,de': [0x19], 'ld_a,(de)': [0x1A], 'dec_de': [0x1B], 'inc_e': [0x1C], 'dec_e': [0x1D], 'ld_e,imm8': [0x1E], 'rra': [0x1F],
            'jr_nz,rel8': [0x20], 'ld_hl,imm16': [0x21], 'ld_(imm16),hl': [0x22], 'inc_hl': [0x23], 'inc_h': [0x24], 'dec_h': [0x25], 'ld_h,imm8': [0x26], 'daa': [0x27],
            'jr_z,rel8': [0x28], 'add_hl,hl': [0x29], 'ld_hl,(imm16)': [0x2A], 'dec_hl': [0x2B], 'inc_l': [0x2C], 'dec_l': [0x2D], 'ld_l,imm8': [0x2E], 'cpl': [0x2F],
            'jr_nc,rel8': [0x30], 'ld_sp,imm16': [0x31], 'ld_(imm16),a': [0x32], 'inc_sp': [0x33], 'inc_(hl)': [0x34], 'dec_(hl)': [0x35], 'ld_(hl),imm8': [0x36], 'scf': [0x37],
            'jr_c,rel8': [0x38], 'add_hl,sp': [0x39], 'ld_a,(imm16)': [0x3A], 'dec_sp': [0x3B], 'inc_a': [0x3C], 'dec_a': [0x3D], 'ld_a,imm8': [0x3E], 'ccf': [0x3F],
            'ld_b,b': [0x40], 'ld_b,c': [0x41], 'ld_b,d': [0x42], 'ld_b,e': [0x43], 'ld_b,h': [0x44], 'ld_b,l': [0x45], 'ld_b,(hl)': [0x46], 'ld_b,a': [0x47],
            'ld_c,b': [0x48], 'ld_c,c': [0x49], 'ld_c,d': [0x4A], 'ld_c,e': [0x4B], 'ld_c,h': [0x4C], 'ld_c,l': [0x4D], 'ld_c,(hl)': [0x4E], 'ld_c,a': [0x4F],
            'ld_d,b': [0x50], 'ld_d,c': [0x51], 'ld_d,d': [0x52], 'ld_d,e': [0x53], 'ld_d,h': [0x54], 'ld_d,l': [0x55], 'ld_d,(hl)': [0x56], 'ld_d,a': [0x57],
            'ld_e,b': [0x58], 'ld_e,c': [0x59], 'ld_e,d': [0x5A], 'ld_e,e': [0x5B], 'ld_e,h': [0x5C], 'ld_e,l': [0x5D], 'ld_e,(hl)': [0x5E], 'ld_e,a': [0x5F],
            'ld_h,b': [0x60], 'ld_h,c': [0x61], 'ld_h,d': [0x62], 'ld_h,e': [0x63], 'ld_h,h': [0x64], 'ld_h,l': [0x65], 'ld_h,(hl)': [0x66], 'ld_h,a': [0x67],
            'ld_l,b': [0x68], 'ld_l,c': [0x69], 'ld_l,d': [0x6A], 'ld_l,e': [0x6B], 'ld_l,h': [0x6C], 'ld_l,l': [0x6D], 'ld_l,(hl)': [0x6E], 'ld_l,a': [0x6F],
            'ld_(hl),b': [0x70], 'ld_(hl),c': [0x71], 'ld_(hl),d': [0x72], 'ld_(hl),e': [0x73], 'ld_(hl),h': [0x74], 'ld_(hl),l': [0x75], 'halt': [0x76], 'ld_(hl),a': [0x77],
            'ld_a,b': [0x78], 'ld_a,c': [0x79], 'ld_a,d': [0x7A], 'ld_a,e': [0x7B], 'ld_a,h': [0x7C], 'ld_a,l': [0x7D], 'ld_a,(hl)': [0x7E], 'ld_a,a': [0x7F],
            'add_a,b': [0x80], 'add_a,c': [0x81], 'add_a,d': [0x82], 'add_a,e': [0x83], 'add_a,h': [0x84], 'add_a,l': [0x85], 'add_a,(hl)': [0x86], 'add_a,a': [0x87],
            'adc_a,b': [0x88], 'adc_a,c': [0x89], 'adc_a,d': [0x8A], 'adc_a,e': [0x8B], 'adc_a,h': [0x8C], 'adc_a,l': [0x8D], 'adc_a,(hl)': [0x8E], 'adc_a,a': [0x8F],
            'sub_b': [0x90], 'sub_c': [0x91], 'sub_d': [0x92], 'sub_e': [0x93], 'sub_h': [0x94], 'sub_l': [0x95], 'sub_(hl)': [0x96], 'sub_a': [0x97],
            'sbc_a,b': [0x98], 'sbc_a,c': [0x99], 'sbc_a,d': [0x9A], 'sbc_a,e': [0x9B], 'sbc_a,h': [0x9C], 'sbc_a,l': [0x9D], 'sbc_a,(hl)': [0x9E], 'sbc_a,a': [0x9F],
            'and_b': [0xA0], 'and_c': [0xA1], 'and_d': [0xA2], 'and_e': [0xA3], 'and_h': [0xA4], 'and_l': [0xA5], 'and_(hl)': [0xA6], 'and_a': [0xA7],
            'xor_b': [0xA8], 'xor_c': [0xA9], 'xor_d': [0xAA], 'xor_e': [0xAB], 'xor_h': [0xAC], 'xor_l': [0xAD], 'xor_(hl)': [0xAE], 'xor_a': [0xAF],
            'or_b': [0xB0], 'or_c': [0xB1], 'or_d': [0xB2], 'or_e': [0xB3], 'or_h': [0xB4], 'or_l': [0xB5], 'or_(hl)': [0xB6], 'or_a': [0xB7],
            'cp_b': [0xB8], 'cp_c': [0xB9], 'cp_d': [0xBA], 'cp_e': [0xBB], 'cp_h': [0xBC], 'cp_l': [0xBD], 'cp_(hl)': [0xBE], 'cp_a': [0xBF],
            'ret_nz': [0xC0], 'pop_bc': [0xC1], 'jp_nz,imm16': [0xC2], 'jp_imm16': [0xC3], 'call_nz,imm16': [0xC4], 'push_bc': [0xC5], 'add_a,imm8': [0xC6], 'rst_00h': [0xC7],
            'ret_z': [0xC8], 'ret': [0xC9], 'jp_z,imm16': [0xCA], 'cb_prefix': [0xCB], 'call_z,imm16': [0xCC], 'call_imm16': [0xCD], 'adc_a,imm8': [0xCE], 'rst_08h': [0xCF],
            'ret_nc': [0xD0], 'pop_de': [0xD1], 'jp_nc,imm16': [0xD2], 'out_(imm8),a': [0xD3], 'call_nc,imm16': [0xD4], 'push_de': [0xD5], 'sub_imm8': [0xD6], 'rst_10h': [0xD7],
            'ret_c': [0xD8], 'exx': [0xD9], 'jp_c,imm16': [0xDA], 'in_a,(imm8)': [0xDB], 'call_c,imm16': [0xDC], 'dd_prefix': [0xDD], 'sbc_a,imm8': [0xDE], 'rst_18h': [0xDF],
            'ret_po': [0xE0], 'pop_hl': [0xE1], 'jp_po,imm16': [0xE2], 'ex_(sp),hl': [0xE3], 'call_po,imm16': [0xE4], 'push_hl': [0xE5], 'and_imm8': [0xE6], 'rst_20h': [0xE7],
            'ret_pe': [0xE8], 'jp_(hl)': [0xE9], 'jp_pe,imm16': [0xEA], 'ex_de,hl': [0xEB], 'call_pe,imm16': [0xEC], 'ed_prefix': [0xED], 'xor_imm8': [0xEE], 'rst_28h': [0xEF],
            'ret_p': [0xF0], 'pop_af': [0xF1], 'jp_p,imm16': [0xF2], 'di': [0xF3], 'call_p,imm16': [0xF4], 'push_af': [0xF5], 'or_imm8': [0xF6], 'rst_30h': [0xF7],
            'ret_m': [0xF8], 'ld_sp,hl': [0xF9], 'jp_m,imm16': [0xFA], 'ei': [0xFB], 'call_m,imm16': [0xFC], 'fd_prefix': [0xFD], 'cp_imm8': [0xFE], 'rst_38h': [0xFF],
            
            // Enhanced RST instructions
            'rst_0': [0xC7], 'rst_8': [0xCF], 'rst_16': [0xD7], 'rst_24': [0xDF], 'rst_32': [0xE7], 'rst_40': [0xEF], 'rst_48': [0xF7], 'rst_56': [0xFF],
            
            // ED prefix opcodes (complete set)
            'in_b,(c)': [0xED, 0x40], 'out_(c),b': [0xED, 0x41], 'sbc_hl,bc': [0xED, 0x42], 'ld_(imm16),bc': [0xED, 0x43], 'neg': [0xED, 0x44], 'retn': [0xED, 0x45], 'im_0': [0xED, 0x46], 'ld_i,a': [0xED, 0x47],
            'in_c,(c)': [0xED, 0x48], 'out_(c),c': [0xED, 0x49], 'adc_hl,bc': [0xED, 0x4A], 'ld_bc,(imm16)': [0xED, 0x4B], 'neg_undoc1': [0xED, 0x4C], 'reti': [0xED, 0x4D], 'im_0/1': [0xED, 0x4E], 'ld_r,a': [0xED, 0x4F],
            'in_d,(c)': [0xED, 0x50], 'out_(c),d': [0xED, 0x51], 'sbc_hl,de': [0xED, 0x52], 'ld_(imm16),de': [0xED, 0x53], 'neg_undoc2': [0xED, 0x54], 'retn_undoc1': [0xED, 0x55], 'im_1': [0xED, 0x56], 'ld_a,i': [0xED, 0x57],
            'in_e,(c)': [0xED, 0x58], 'out_(c),e': [0xED, 0x59], 'adc_hl,de': [0xED, 0x5A], 'ld_de,(imm16)': [0xED, 0x5B], 'neg_undoc3': [0xED, 0x5C], 'reti_undoc': [0xED, 0x5D], 'im_2': [0xED, 0x5E], 'ld_a,r': [0xED, 0x5F],
            'in_h,(c)': [0xED, 0x60], 'out_(c),h': [0xED, 0x61], 'sbc_hl,hl': [0xED, 0x62], 'ld_(imm16),hl_alt': [0xED, 0x63], 'neg_undoc4': [0xED, 0x64], 'retn_undoc2': [0xED, 0x65], 'im_0_alt': [0xED, 0x66], 'rrd': [0xED, 0x67],
            'in_l,(c)': [0xED, 0x68], 'out_(c),l': [0xED, 0x69], 'adc_hl,hl': [0xED, 0x6A], 'ld_hl,(imm16)_alt': [0xED, 0x6B], 'neg_undoc5': [0xED, 0x6C], 'retn_undoc3': [0xED, 0x6D], 'im_0/1_alt': [0xED, 0x6E], 'rld': [0xED, 0x6F],
            'in_(c)': [0xED, 0x70], 'out_(c),0': [0xED, 0x71], 'sbc_hl,sp': [0xED, 0x72], 'ld_(imm16),sp': [0xED, 0x73], 'neg_undoc6': [0xED, 0x74], 'retn_undoc4': [0xED, 0x75], 'im_1_alt': [0xED, 0x76], 'nop_ed1': [0xED, 0x77],
            'in_a,(c)': [0xED, 0x78], 'out_(c),a': [0xED, 0x79], 'adc_hl,sp': [0xED, 0x7A], 'ld_sp,(imm16)': [0xED, 0x7B], 'neg_undoc7': [0xED, 0x7C], 'reti_undoc2': [0xED, 0x7D], 'im_2_alt': [0xED, 0x7E], 'nop_ed2': [0xED, 0x7F],
            'ldi': [0xED, 0xA0], 'cpi': [0xED, 0xA1], 'ini': [0xED, 0xA2], 'outi': [0xED, 0xA3],
            'ldd': [0xED, 0xA8], 'cpd': [0xED, 0xA9], 'ind': [0xED, 0xAA], 'outd': [0xED, 0xAB],
            'ldir': [0xED, 0xB0], 'cpir': [0xED, 0xB1], 'inir': [0xED, 0xB2], 'otir': [0xED, 0xB3],
            'lddr': [0xED, 0xB8], 'cpdr': [0xED, 0xB9], 'indr': [0xED, 0xBA], 'otdr': [0xED, 0xBB],
            
            // CB prefix opcodes - Rotate and shift instructions
            'rlc_b': [0xCB, 0x00], 'rlc_c': [0xCB, 0x01], 'rlc_d': [0xCB, 0x02], 'rlc_e': [0xCB, 0x03], 'rlc_h': [0xCB, 0x04], 'rlc_l': [0xCB, 0x05], 'rlc_(hl)': [0xCB, 0x06], 'rlc_a': [0xCB, 0x07],
            'rrc_b': [0xCB, 0x08], 'rrc_c': [0xCB, 0x09], 'rrc_d': [0xCB, 0x0A], 'rrc_e': [0xCB, 0x0B], 'rrc_h': [0xCB, 0x0C], 'rrc_l': [0xCB, 0x0D], 'rrc_(hl)': [0xCB, 0x0E], 'rrc_a': [0xCB, 0x0F],
            'rl_b': [0xCB, 0x10], 'rl_c': [0xCB, 0x11], 'rl_d': [0xCB, 0x12], 'rl_e': [0xCB, 0x13], 'rl_h': [0xCB, 0x14], 'rl_l': [0xCB, 0x15], 'rl_(hl)': [0xCB, 0x16], 'rl_a': [0xCB, 0x17],
            'rr_b': [0xCB, 0x18], 'rr_c': [0xCB, 0x19], 'rr_d': [0xCB, 0x1A], 'rr_e': [0xCB, 0x1B], 'rr_h': [0xCB, 0x1C], 'rr_l': [0xCB, 0x1D], 'rr_(hl)': [0xCB, 0x1E], 'rr_a': [0xCB, 0x1F],
            'sla_b': [0xCB, 0x20], 'sla_c': [0xCB, 0x21], 'sla_d': [0xCB, 0x22], 'sla_e': [0xCB, 0x23], 'sla_h': [0xCB, 0x24], 'sla_l': [0xCB, 0x25], 'sla_(hl)': [0xCB, 0x26], 'sla_a': [0xCB, 0x27],
            'sra_b': [0xCB, 0x28], 'sra_c': [0xCB, 0x29], 'sra_d': [0xCB, 0x2A], 'sra_e': [0xCB, 0x2B], 'sra_h': [0xCB, 0x2C], 'sra_l': [0xCB, 0x2D], 'sra_(hl)': [0xCB, 0x2E], 'sra_a': [0xCB, 0x2F],
            'sll_b': [0xCB, 0x30], 'sll_c': [0xCB, 0x31], 'sll_d': [0xCB, 0x32], 'sll_e': [0xCB, 0x33], 'sll_h': [0xCB, 0x34], 'sll_l': [0xCB, 0x35], 'sll_(hl)': [0xCB, 0x36], 'sll_a': [0xCB, 0x37],
            'srl_b': [0xCB, 0x38], 'srl_c': [0xCB, 0x39], 'srl_d': [0xCB, 0x3A], 'srl_e': [0xCB, 0x3B], 'srl_h': [0xCB, 0x3C], 'srl_l': [0xCB, 0x3D], 'srl_(hl)': [0xCB, 0x3E], 'srl_a': [0xCB, 0x3F],
            
            // CB prefix - Bit test instructions
            'bit_0,b': [0xCB, 0x40], 'bit_0,c': [0xCB, 0x41], 'bit_0,d': [0xCB, 0x42], 'bit_0,e': [0xCB, 0x43], 'bit_0,h': [0xCB, 0x44], 'bit_0,l': [0xCB, 0x45], 'bit_0,(hl)': [0xCB, 0x46], 'bit_0,a': [0xCB, 0x47],
            'bit_1,b': [0xCB, 0x48], 'bit_1,c': [0xCB, 0x49], 'bit_1,d': [0xCB, 0x4A], 'bit_1,e': [0xCB, 0x4B], 'bit_1,h': [0xCB, 0x4C], 'bit_1,l': [0xCB, 0x4D], 'bit_1,(hl)': [0xCB, 0x4E], 'bit_1,a': [0xCB, 0x4F],
            'bit_2,b': [0xCB, 0x50], 'bit_2,c': [0xCB, 0x51], 'bit_2,d': [0xCB, 0x52], 'bit_2,e': [0xCB, 0x53], 'bit_2,h': [0xCB, 0x54], 'bit_2,l': [0xCB, 0x55], 'bit_2,(hl)': [0xCB, 0x56], 'bit_2,a': [0xCB, 0x57],
            'bit_3,b': [0xCB, 0x58], 'bit_3,c': [0xCB, 0x59], 'bit_3,d': [0xCB, 0x5A], 'bit_3,e': [0xCB, 0x5B], 'bit_3,h': [0xCB, 0x5C], 'bit_3,l': [0xCB, 0x5D], 'bit_3,(hl)': [0xCB, 0x5E], 'bit_3,a': [0xCB, 0x5F],
            'bit_4,b': [0xCB, 0x60], 'bit_4,c': [0xCB, 0x61], 'bit_4,d': [0xCB, 0x62], 'bit_4,e': [0xCB, 0x63], 'bit_4,h': [0xCB, 0x64], 'bit_4,l': [0xCB, 0x65], 'bit_4,(hl)': [0xCB, 0x66], 'bit_4,a': [0xCB, 0x67],
            'bit_5,b': [0xCB, 0x68], 'bit_5,c': [0xCB, 0x69], 'bit_5,d': [0xCB, 0x6A], 'bit_5,e': [0xCB, 0x6B], 'bit_5,h': [0xCB, 0x6C], 'bit_5,l': [0xCB, 0x6D], 'bit_5,(hl)': [0xCB, 0x6E], 'bit_5,a': [0xCB, 0x6F],
            'bit_6,b': [0xCB, 0x70], 'bit_6,c': [0xCB, 0x71], 'bit_6,d': [0xCB, 0x72], 'bit_6,e': [0xCB, 0x73], 'bit_6,h': [0xCB, 0x74], 'bit_6,l': [0xCB, 0x75], 'bit_6,(hl)': [0xCB, 0x76], 'bit_6,a': [0xCB, 0x77],
            'bit_7,b': [0xCB, 0x78], 'bit_7,c': [0xCB, 0x79], 'bit_7,d': [0xCB, 0x7A], 'bit_7,e': [0xCB, 0x7B], 'bit_7,h': [0xCB, 0x7C], 'bit_7,l': [0xCB, 0x7D], 'bit_7,(hl)': [0xCB, 0x7E], 'bit_7,a': [0xCB, 0x7F],
            
            // CB prefix - Bit reset instructions
            'res_0,b': [0xCB, 0x80], 'res_0,c': [0xCB, 0x81], 'res_0,d': [0xCB, 0x82], 'res_0,e': [0xCB, 0x83], 'res_0,h': [0xCB, 0x84], 'res_0,l': [0xCB, 0x85], 'res_0,(hl)': [0xCB, 0x86], 'res_0,a': [0xCB, 0x87],
            'res_1,b': [0xCB, 0x88], 'res_1,c': [0xCB, 0x89], 'res_1,d': [0xCB, 0x8A], 'res_1,e': [0xCB, 0x8B], 'res_1,h': [0xCB, 0x8C], 'res_1,l': [0xCB, 0x8D], 'res_1,(hl)': [0xCB, 0x8E], 'res_1,a': [0xCB, 0x8F],
            'res_2,b': [0xCB, 0x90], 'res_2,c': [0xCB, 0x91], 'res_2,d': [0xCB, 0x92], 'res_2,e': [0xCB, 0x93], 'res_2,h': [0xCB, 0x94], 'res_2,l': [0xCB, 0x95], 'res_2,(hl)': [0xCB, 0x96], 'res_2,a': [0xCB, 0x97],
            'res_3,b': [0xCB, 0x98], 'res_3,c': [0xCB, 0x99], 'res_3,d': [0xCB, 0x9A], 'res_3,e': [0xCB, 0x9B], 'res_3,h': [0xCB, 0x9C], 'res_3,l': [0xCB, 0x9D], 'res_3,(hl)': [0xCB, 0x9E], 'res_3,a': [0xCB, 0x9F],
            'res_4,b': [0xCB, 0xA0], 'res_4,c': [0xCB, 0xA1], 'res_4,d': [0xCB, 0xA2], 'res_4,e': [0xCB, 0xA3], 'res_4,h': [0xCB, 0xA4], 'res_4,l': [0xCB, 0xA5], 'res_4,(hl)': [0xCB, 0xA6], 'res_4,a': [0xCB, 0xA7],
            'res_5,b': [0xCB, 0xA8], 'res_5,c': [0xCB, 0xA9], 'res_5,d': [0xCB, 0xAA], 'res_5,e': [0xCB, 0xAB], 'res_5,h': [0xCB, 0xAC], 'res_5,l': [0xCB, 0xAD], 'res_5,(hl)': [0xCB, 0xAE], 'res_5,a': [0xCB, 0xAF],
            'res_6,b': [0xCB, 0xB0], 'res_6,c': [0xCB, 0xB1], 'res_6,d': [0xCB, 0xB2], 'res_6,e': [0xCB, 0xB3], 'res_6,h': [0xCB, 0xB4], 'res_6,l': [0xCB, 0xB5], 'res_6,(hl)': [0xCB, 0xB6], 'res_6,a': [0xCB, 0xB7],
            'res_7,b': [0xCB, 0xB8], 'res_7,c': [0xCB, 0xB9], 'res_7,d': [0xCB, 0xBA], 'res_7,e': [0xCB, 0xBB], 'res_7,h': [0xCB, 0xBC], 'res_7,l': [0xCB, 0xBD], 'res_7,(hl)': [0xCB, 0xBE], 'res_7,a': [0xCB, 0xBF],
            
            // CB prefix - Bit set instructions
            'set_0,b': [0xCB, 0xC0], 'set_0,c': [0xCB, 0xC1], 'set_0,d': [0xCB, 0xC2], 'set_0,e': [0xCB, 0xC3], 'set_0,h': [0xCB, 0xC4], 'set_0,l': [0xCB, 0xC5], 'set_0,(hl)': [0xCB, 0xC6], 'set_0,a': [0xCB, 0xC7],
            'set_1,b': [0xCB, 0xC8], 'set_1,c': [0xCB, 0xC9], 'set_1,d': [0xCB, 0xCA], 'set_1,e': [0xCB, 0xCB], 'set_1,h': [0xCB, 0xCC], 'set_1,l': [0xCB, 0xCD], 'set_1,(hl)': [0xCB, 0xCE], 'set_1,a': [0xCB, 0xCF],
            'set_2,b': [0xCB, 0xD0], 'set_2,c': [0xCB, 0xD1], 'set_2,d': [0xCB, 0xD2], 'set_2,e': [0xCB, 0xD3], 'set_2,h': [0xCB, 0xD4], 'set_2,l': [0xCB, 0xD5], 'set_2,(hl)': [0xCB, 0xD6], 'set_2,a': [0xCB, 0xD7],
            'set_3,b': [0xCB, 0xD8], 'set_3,c': [0xCB, 0xD9], 'set_3,d': [0xCB, 0xDA], 'set_3,e': [0xCB, 0xDB], 'set_3,h': [0xCB, 0xDC], 'set_3,l': [0xCB, 0xDD], 'set_3,(hl)': [0xCB, 0xDE], 'set_3,a': [0xCB, 0xDF],
            'set_4,b': [0xCB, 0xE0], 'set_4,c': [0xCB, 0xE1], 'set_4,d': [0xCB, 0xE2], 'set_4,e': [0xCB, 0xE3], 'set_4,h': [0xCB, 0xE4], 'set_4,l': [0xCB, 0xE5], 'set_4,(hl)': [0xCB, 0xE6], 'set_4,a': [0xCB, 0xE7],
            'set_5,b': [0xCB, 0xE8], 'set_5,c': [0xCB, 0xE9], 'set_5,d': [0xCB, 0xEA], 'set_5,e': [0xCB, 0xEB], 'set_5,h': [0xCB, 0xEC], 'set_5,l': [0xCB, 0xED], 'set_5,(hl)': [0xCB, 0xEE], 'set_5,a': [0xCB, 0xEF],
            'set_6,b': [0xCB, 0xF0], 'set_6,c': [0xCB, 0xF1], 'set_6,d': [0xCB, 0xF2], 'set_6,e': [0xCB, 0xF3], 'set_6,h': [0xCB, 0xF4], 'set_6,l': [0xCB, 0xF5], 'set_6,(hl)': [0xCB, 0xF6], 'set_6,a': [0xCB, 0xF7],
            'set_7,b': [0xCB, 0xF8], 'set_7,c': [0xCB, 0xF9], 'set_7,d': [0xCB, 0xFA], 'set_7,e': [0xCB, 0xFB], 'set_7,h': [0xCB, 0xFC], 'set_7,l': [0xCB, 0xFD], 'set_7,(hl)': [0xCB, 0xFE], 'set_7,a': [0xCB, 0xFF],
            
            // DD prefix opcodes - IX operations
            'add_ix,bc': [0xDD, 0x09], 'add_ix,de': [0xDD, 0x19], 'ld_ix,imm16': [0xDD, 0x21], 'ld_(imm16),ix': [0xDD, 0x22], 
            'inc_ix': [0xDD, 0x23], 'inc_ixh': [0xDD, 0x24], 'dec_ixh': [0xDD, 0x25], 'ld_ixh,imm8': [0xDD, 0x26], 
            'add_ix,ix': [0xDD, 0x29], 'ld_ix,(imm16)': [0xDD, 0x2A], 'dec_ix': [0xDD, 0x2B], 'inc_ixl': [0xDD, 0x2C], 
            'dec_ixl': [0xDD, 0x2D], 'ld_ixl,imm8': [0xDD, 0x2E], 'inc_(ix+offset)': [0xDD, 0x34], 'dec_(ix+offset)': [0xDD, 0x35],
            'ld_(ix+offset),imm8': [0xDD, 0x36], 'add_ix,sp': [0xDD, 0x39], 'ld_b,ixh': [0xDD, 0x44], 'ld_b,ixl': [0xDD, 0x45], 
            'ld_b,(ix+offset)': [0xDD, 0x46], 'ld_c,ixh': [0xDD, 0x4C], 'ld_c,ixl': [0xDD, 0x4D], 'ld_c,(ix+offset)': [0xDD, 0x4E],
            'ld_d,ixh': [0xDD, 0x54], 'ld_d,ixl': [0xDD, 0x55], 'ld_d,(ix+offset)': [0xDD, 0x56], 'ld_e,ixh': [0xDD, 0x5C], 
            'ld_e,ixl': [0xDD, 0x5D], 'ld_e,(ix+offset)': [0xDD, 0x5E], 'ld_ixh,b': [0xDD, 0x60], 'ld_ixh,c': [0xDD, 0x61], 
            'ld_ixh,d': [0xDD, 0x62], 'ld_ixh,e': [0xDD, 0x63], 'ld_ixh,ixh': [0xDD, 0x64], 'ld_ixh,ixl': [0xDD, 0x65], 
            'ld_h,(ix+offset)': [0xDD, 0x66], 'ld_ixh,a': [0xDD, 0x67], 'ld_ixl,b': [0xDD, 0x68], 'ld_ixl,c': [0xDD, 0x69], 
            'ld_ixl,d': [0xDD, 0x6A], 'ld_ixl,e': [0xDD, 0x6B], 'ld_ixl,ixh': [0xDD, 0x6C], 'ld_ixl,ixl': [0xDD, 0x6D], 
            'ld_l,(ix+offset)': [0xDD, 0x6E], 'ld_ixl,a': [0xDD, 0x6F], 'ld_(ix+offset),b': [0xDD, 0x70], 'ld_(ix+offset),c': [0xDD, 0x71],
            'ld_(ix+offset),d': [0xDD, 0x72], 'ld_(ix+offset),e': [0xDD, 0x73], 'ld_(ix+offset),h': [0xDD, 0x74], 'ld_(ix+offset),l': [0xDD, 0x75],
            'ld_(ix+offset),a': [0xDD, 0x77], 'ld_a,ixh': [0xDD, 0x7C], 'ld_a,ixl': [0xDD, 0x7D], 'ld_a,(ix+offset)': [0xDD, 0x7E],
            'add_a,ixh': [0xDD, 0x84], 'add_a,ixl': [0xDD, 0x85], 'add_a,(ix+offset)': [0xDD, 0x86], 'adc_a,ixh': [0xDD, 0x8C], 
            'adc_a,ixl': [0xDD, 0x8D], 'adc_a,(ix+offset)': [0xDD, 0x8E], 'sub_ixh': [0xDD, 0x94], 'sub_ixl': [0xDD, 0x95], 
            'sub_(ix+offset)': [0xDD, 0x96], 'sbc_a,ixh': [0xDD, 0x9C], 'sbc_a,ixl': [0xDD, 0x9D], 'sbc_a,(ix+offset)': [0xDD, 0x9E],
            'and_ixh': [0xDD, 0xA4], 'and_ixl': [0xDD, 0xA5], 'and_(ix+offset)': [0xDD, 0xA6], 'xor_ixh': [0xDD, 0xAC], 
            'xor_ixl': [0xDD, 0xAD], 'xor_(ix+offset)': [0xDD, 0xAE], 'or_ixh': [0xDD, 0xB4], 'or_ixl': [0xDD, 0xB5], 
            'or_(ix+offset)': [0xDD, 0xB6], 'cp_ixh': [0xDD, 0xBC], 'cp_ixl': [0xDD, 0xBD], 'cp_(ix+offset)': [0xDD, 0xBE],
            'pop_ix': [0xDD, 0xE1], 'ex_(sp),ix': [0xDD, 0xE3], 'push_ix': [0xDD, 0xE5], 'jp_(ix)': [0xDD, 0xE9], 'ld_sp,ix': [0xDD, 0xF9],
            
            // FD prefix opcodes - IY operations
            'add_iy,bc': [0xFD, 0x09], 'add_iy,de': [0xFD, 0x19], 'ld_iy,imm16': [0xFD, 0x21], 'ld_(imm16),iy': [0xFD, 0x22], 
            'inc_iy': [0xFD, 0x23], 'inc_iyh': [0xFD, 0x24], 'dec_iyh': [0xFD, 0x25], 'ld_iyh,imm8': [0xFD, 0x26],
            'add_iy,iy': [0xFD, 0x29], 'ld_iy,(imm16)': [0xFD, 0x2A], 'dec_iy': [0xFD, 0x2B], 'inc_iyl': [0xFD, 0x2C], 
            'dec_iyl': [0xFD, 0x2D], 'ld_iyl,imm8': [0xFD, 0x2E], 'inc_(iy+offset)': [0xFD, 0x34], 'dec_(iy+offset)': [0xFD, 0x35],
            'ld_(iy+offset),imm8': [0xFD, 0x36], 'add_iy,sp': [0xFD, 0x39], 'ld_b,iyh': [0xFD, 0x44], 'ld_b,iyl': [0xFD, 0x45], 
            'ld_b,(iy+offset)': [0xFD, 0x46], 'ld_c,iyh': [0xFD, 0x4C], 'ld_c,iyl': [0xFD, 0x4D], 'ld_c,(iy+offset)': [0xFD, 0x4E],
            'ld_d,iyh': [0xFD, 0x54], 'ld_d,iyl': [0xFD, 0x55], 'ld_d,(iy+offset)': [0xFD, 0x56], 'ld_e,iyh': [0xFD, 0x5C], 
            'ld_e,iyl': [0xFD, 0x5D], 'ld_e,(iy+offset)': [0xFD, 0x5E], 'ld_iyh,b': [0xFD, 0x60], 'ld_iyh,c': [0xFD, 0x61], 
            'ld_iyh,d': [0xFD, 0x62], 'ld_iyh,e': [0xFD, 0x63], 'ld_iyh,iyh': [0xFD, 0x64], 'ld_iyh,iyl': [0xFD, 0x65], 
            'ld_h,(iy+offset)': [0xFD, 0x66], 'ld_iyh,a': [0xFD, 0x67], 'ld_iyl,b': [0xFD, 0x68], 'ld_iyl,c': [0xFD, 0x69], 
            'ld_iyl,d': [0xFD, 0x6A], 'ld_iyl,e': [0xFD, 0x6B], 'ld_iyl,iyh': [0xFD, 0x6C], 'ld_iyl,iyl': [0xFD, 0x6D], 
            'ld_l,(iy+offset)': [0xFD, 0x6E], 'ld_iyl,a': [0xFD, 0x6F], 'ld_(iy+offset),b': [0xFD, 0x70], 'ld_(iy+offset),c': [0xFD, 0x71],
            'ld_(iy+offset),d': [0xFD, 0x72], 'ld_(iy+offset),e': [0xFD, 0x73], 'ld_(iy+offset),h': [0xFD, 0x74], 'ld_(iy+offset),l': [0xFD, 0x75],
            'ld_(iy+offset),a': [0xFD, 0x77], 'ld_a,iyh': [0xFD, 0x7C], 'ld_a,iyl': [0xFD, 0x7D], 'ld_a,(iy+offset)': [0xFD, 0x7E],
            'add_a,iyh': [0xFD, 0x84], 'add_a,iyl': [0xFD, 0x85], 'add_a,(iy+offset)': [0xFD, 0x86], 'adc_a,iyh': [0xFD, 0x8C], 
            'adc_a,iyl': [0xFD, 0x8D], 'adc_a,(iy+offset)': [0xFD, 0x8E], 'sub_iyh': [0xFD, 0x94], 'sub_iyl': [0xFD, 0x95], 
            'sub_(iy+offset)': [0xFD, 0x96], 'sbc_a,iyh': [0xFD, 0x9C], 'sbc_a,iyl': [0xFD, 0x9D], 'sbc_a,(iy+offset)': [0xFD, 0x9E],
            'and_iyh': [0xFD, 0xA4], 'and_iyl': [0xFD, 0xA5], 'and_(iy+offset)': [0xFD, 0xA6], 'xor_iyh': [0xFD, 0xAC], 
            'xor_iyl': [0xFD, 0xAD], 'xor_(iy+offset)': [0xFD, 0xAE], 'or_iyh': [0xFD, 0xB4], 'or_iyl': [0xFD, 0xB5], 
            'or_(iy+offset)': [0xFD, 0xB6], 'cp_iyh': [0xFD, 0xBC], 'cp_iyl': [0xFD, 0xBD], 'cp_(iy+offset)': [0xFD, 0xBE],
            'pop_iy': [0xFD, 0xE1], 'ex_(sp),iy': [0xFD, 0xE3], 'push_iy': [0xFD, 0xE5], 'jp_(iy)': [0xFD, 0xE9], 'ld_sp,iy': [0xFD, 0xF9],
        };

        // --- BitStreamWriter for .REL file generation ---
        class BitStreamWriter {
            constructor() {
                this.bytes = [];
                this.currentByte = 0;
                this.bitPosition = 0;
            }

            writeBit(bit) {
                if (bit) {
                    this.currentByte |= (1 << (7 - this.bitPosition));
                }
                this.bitPosition++;
                if (this.bitPosition === 8) {
                    this.bytes.push(this.currentByte);
                    this.currentByte = 0;
                    this.bitPosition = 0;
                }
            }

            writeBits(value, count) {
                for (let i = count - 1; i >= 0; i--) {
                    this.writeBit((value >> i) & 1);
                }
            }

            alignToByte() {
                if (this.bitPosition > 0) {
                    this.bytes.push(this.currentByte);
                    this.currentByte = 0;
                    this.bitPosition = 0;
                }
            }

            getBytes() {
                this.alignToByte();
                return new Uint8Array(this.bytes);
            }
        }

        // --- BitStreamReader for .REL file parsing ---
        class BitStreamReader {
            constructor(bytes) {
                this.bytes = bytes;
                this.bytePosition = 0;
                this.bitPosition = 0;
            }

            readBit() {
                if (this.bytePosition >= this.bytes.length) {
                    return null;
                }
                const bit = (this.bytes[this.bytePosition] >> (7 - this.bitPosition)) & 1;
                this.bitPosition++;
                if (this.bitPosition === 8) {
                    this.bitPosition = 0;
                    this.bytePosition++;
                }
                return bit;
            }

            readBits(count) {
                let value = 0;
                for (let i = 0; i < count; i++) {
                    const bit = this.readBit();
                    if (bit === null) return null;
                    value = (value << 1) | bit;
                }
                return value;
            }

            isAtEnd() {
                return this.bytePosition >= this.bytes.length;
            }

            alignToByte() {
                if (this.bitPosition > 0) {
                    this.bitPosition = 0;
                    this.bytePosition++;
                }
            }
        }

        // Pro version: .REL file parser
        class RelFileParser {
            constructor(bytes) {
                this.reader = new BitStreamReader(bytes);
                this.module = {
                    name: '',
                    publicSymbols: [],      // {name, value, addressType}
                    externalSymbols: [],    // {name}
                    externalRefs: [],       // {symbol, location, addressType}
                    codeBytes: [],
                    dataBytes: [],
                    relocations: [],        // {location, addressType, isWord}
                    codeSize: 0,
                    dataSize: 0,
                    isExtendedFormat: false
                };
                this.currentSegment = 'code';
                this.currentLocation = 0;
                this.endOfFile = false; // Flag to stop parsing

                // Detect extended format by checking for header signature
                this.detectExtendedFormat(bytes);
            }

            detectExtendedFormat(bytes) {
                // Linkstor80 extended format signature (first 16 bytes)
                const extendedSignature = [
                    0x85, 0xD3, 0x13, 0x92, 0xD4, 0xD5, 0x13, 0xD4,
                    0xA5, 0x00, 0x00, 0x13, 0x8F, 0xFF, 0xF0, 0x9E
                ];

                if (bytes.length >= 16) {
                    let isExtended = true;
                    for (let i = 0; i < 16; i++) {
                        if (bytes[i] !== extendedSignature[i]) {
                            isExtended = false;
                            break;
                        }
                    }

                    if (isExtended) {
                        this.module.isExtendedFormat = true;
                        // Skip the header by advancing the reader
                        for (let i = 0; i < 16; i++) {
                            this.reader.readBits(8);
                        }
                        console.log('[DEBUG] Detected EXTENDED format .REL file (Linkstor80)');
                    } else {
                        console.log('[DEBUG] Detected STANDARD format .REL file (LINK-80)');
                    }
                }
            }

            parse() {
                while (!this.reader.isAtEnd() && !this.endOfFile) {
                    const bit = this.reader.readBit();
                    if (bit === null) break;

                    if (bit === 0) {
                        // Absolute byte
                        const byte = this.reader.readBits(8);
                        if (byte !== null) {
                            if (this.currentSegment === 'code') {
                                this.module.codeBytes.push(byte);
                            } else {
                                this.module.dataBytes.push(byte);
                            }
                            this.currentLocation++;
                        }
                    } else {
                        // Relocatable item or special
                        const type = this.reader.readBits(2);
                        if (type === null) break;

                        if (type === 0x00) {
                            // Special LINK item
                            this.parseSpecialItem();
                        } else {
                            // Relocatable word
                            const value = this.reader.readBits(16);
                            if (value !== null) {
                                const addressType = type;
                                this.module.relocations.push({
                                    location: this.currentLocation,
                                    addressType: addressType,
                                    isWord: true
                                });

                                // Store the word in current segment
                                if (this.currentSegment === 'code') {
                                    this.module.codeBytes.push(value & 0xFF);
                                    this.module.codeBytes.push((value >> 8) & 0xFF);
                                } else {
                                    this.module.dataBytes.push(value & 0xFF);
                                    this.module.dataBytes.push((value >> 8) & 0xFF);
                                }
                                this.currentLocation += 2;
                            }
                        }
                    }
                }

                this.module.codeSize = this.module.codeBytes.length;
                this.module.dataSize = this.module.dataBytes.length;

                return this.module;
            }

            parseSpecialItem() {
                const controlCode = this.reader.readBits(4);
                if (controlCode === null) return;

                switch (controlCode) {
                    case 0x00: // Entry Symbol declaration (PUBLIC)
                        {
                            const symbolName = this.readSymbolName();
                            if (!this.module.externalSymbols.includes(symbolName)) {
                                this.module.externalSymbols.push(symbolName);
                            }
                        }
                        break;

                    case 0x02: // Program Name
                        {
                            const moduleName = this.readSymbolName();
                            this.module.name = moduleName;
                        }
                        break;

                    case 0x06: // Chain External reference
                        {
                            const addressType = this.reader.readBits(2);
                            const location = this.reader.readBits(16);
                            console.log(`[DEBUG] External ref: addressType=${addressType}, location=0x${location.toString(16)}`);
                            const symbolName = this.readSymbolName();
                            console.log(`[DEBUG] External ref symbol: "${symbolName}"`);
                            this.module.externalRefs.push({
                                symbol: symbolName,
                                location: location,
                                addressType: addressType
                            });
                        }
                        break;

                    case 0x07: // Define Entry Point (PUBLIC value)
                        {
                            const addressType = this.reader.readBits(2);
                            const value = this.reader.readBits(16);
                            const symbolName = this.readSymbolName();
                            this.module.publicSymbols.push({
                                name: symbolName,
                                value: value,
                                addressType: addressType
                            });
                        }
                        break;

                    case 0x0A: // Define Data Area Size
                        {
                            const addressType = this.reader.readBits(2);
                            const size = this.reader.readBits(16);
                            if (addressType === 0x02) { // DATA
                                this.module.dataSize = size;
                            }
                        }
                        break;

                    case 0x0B: // Set Location Counter
                        {
                            const addressType = this.reader.readBits(2);
                            const location = this.reader.readBits(16);
                            this.currentLocation = location;
                            // Determine current segment from address type
                            if (addressType === 0x01) {
                                this.currentSegment = 'code';
                            } else if (addressType === 0x02) {
                                this.currentSegment = 'data';
                            }
                        }
                        break;

                    case 0x0D: // Define Program Size
                        {
                            const addressType = this.reader.readBits(2);
                            const size = this.reader.readBits(16);
                            if (addressType === 0x01) { // CODE
                                this.module.codeSize = size;
                            }
                        }
                        break;

                    case 0x0E: // End Program
                        this.reader.alignToByte();
                        break;

                    case 0x0F: // End File
                        console.log('[DEBUG] End of file marker reached');
                        this.endOfFile = true; // Signal to stop parsing
                        return; // Stop parsing

                    default:
                        // Skip unknown control codes
                        console.warn(`Unknown .REL control code: ${controlCode}`);
                        break;
                }
            }

            readSymbolName() {
                const lengthField = this.reader.readBits(3);
                console.log(`[DEBUG] Symbol length field: ${lengthField}`);
                if (lengthField === null) return '';

                let actualLength = lengthField;

                // Check for extended format marker (111 = 7)
                if (lengthField === 0x07) {
                    // Peek at next byte to see if it's FFh (extended format escape)
                    const escapeByte = this.reader.readBits(8);
                    console.log(`[DEBUG] Potential extended format escape byte: 0x${escapeByte?.toString(16)}`);

                    if (escapeByte === 0xFF) {
                        // Extended format: Read actual length
                        const len1 = this.reader.readBits(8);
                        if (len1 === null) return '';

                        // Check if we need a second length byte
                        if (len1 === 0xFF) {
                            const len2 = this.reader.readBits(8);
                            actualLength = len1 | (len2 << 8);
                        } else {
                            actualLength = len1;
                        }
                        console.log(`[DEBUG] Extended format length: ${actualLength}`);
                    } else {
                        // False alarm - it's actually a 7-character standard name
                        // The escapeByte is the first character
                        let name = String.fromCharCode(escapeByte);
                        for (let i = 1; i < 7; i++) {
                            const charCode = this.reader.readBits(8);
                            if (charCode !== null) {
                                name += String.fromCharCode(charCode);
                            }
                        }
                        console.log(`[DEBUG] Standard 7-char symbol: "${name}"`);
                        return name.replace(/\0/g, '').trim(); // Clean up null chars
                    }
                }

                if (actualLength === 0) return '';

                // Validate symbol length is reasonable
                if (actualLength > 255) {
                    console.error(`[DEBUG] Symbol length ${actualLength} seems invalid - possible format mismatch!`);
                    throw new Error(`Invalid symbol length: ${actualLength}. Possible REL format mismatch.`);
                }

                // Read the symbol characters
                let name = '';
                const charCodes = [];
                for (let i = 0; i < actualLength; i++) {
                    const charCode = this.reader.readBits(8);
                    charCodes.push(charCode);
                    if (charCode !== null) {
                        name += String.fromCharCode(charCode);
                    }
                }
                const formatType = lengthField === 0x07 ? 'EXTENDED' : 'STANDARD';
                console.log(`[DEBUG] Symbol (${formatType}): [${charCodes.join(', ')}] => "${name}"`);
                return name;
            }
        }

        // Pro version: Linker for combining .REL files
        class RelLinker {
            constructor(options = {}) {
                this.codeBase = options.codeBase || 0x8000;
                this.dataBase = options.dataBase || 0x7000;
                this.modules = [];
                this.symbolTable = {}; // Global symbol table
                this.errors = [];
            }

            addModule(module) {
                this.modules.push(module);
            }

            link() {
                log('Linking modules...', 'info');

                // Pass 1: Collect all PUBLIC symbols
                for (const module of this.modules) {
                    log(`  Processing module: ${module.name}`, 'info');

                    for (const pubSym of module.publicSymbols) {
                        if (this.symbolTable[pubSym.name]) {
                            this.errors.push(`Duplicate public symbol: ${pubSym.name}`);
                        } else {
                            this.symbolTable[pubSym.name] = {
                                value: pubSym.value,
                                addressType: pubSym.addressType,
                                module: module.name
                            };
                        }
                    }
                }

                if (this.errors.length > 0) {
                    throw new Error(`Link errors:\n${this.errors.join('\n')}`);
                }

                log(`  Collected ${Object.keys(this.symbolTable).length} public symbols`, 'info');

                // Pass 2: Assign base addresses to each module
                let currentCodeBase = this.codeBase;
                let currentDataBase = this.dataBase;

                for (const module of this.modules) {
                    module.linkedCodeBase = currentCodeBase;
                    module.linkedDataBase = currentDataBase;

                    currentCodeBase += module.codeSize;
                    currentDataBase += module.dataSize;

                    log(`  ${module.name}: CODE @ 0x${module.linkedCodeBase.toString(16)}, DATA @ 0x${module.linkedDataBase.toString(16)}`, 'info');
                }

                // Pass 3: Resolve external references and relocate
                const totalCodeSize = currentCodeBase - this.codeBase;
                const totalDataSize = currentDataBase - this.dataBase;

                // Pad to minimum ROM size for emulator compatibility
                const minRomSize = 8192; // 8KB minimum for most ColecoVision emulators
                const finalSize = Math.max(totalCodeSize, minRomSize);
                const output = new Uint8Array(finalSize);

                // Fill with 0xFF (common ROM padding value)
                if (finalSize > totalCodeSize) {
                    output.fill(0xFF);
                    log(`Padding ROM from ${totalCodeSize} bytes to ${finalSize} bytes (8KB)`, 'info');
                }

                let outputPos = 0;

                for (const module of this.modules) {
                    // Copy code bytes with relocation
                    const relocatedCode = this.relocateModule(module);

                    // Write to output
                    output.set(relocatedCode, outputPos);
                    outputPos += relocatedCode.length;
                }

                log(`Link successful! Final binary: ${output.length} bytes at 0x${this.codeBase.toString(16)}`, 'success');
                log(`  CODE: ${totalCodeSize} bytes, DATA: ${totalDataSize} bytes`, 'info');

                return output;
            }

            relocateModule(module) {
                const relocated = new Uint8Array(module.codeBytes.length);

                // Copy all bytes first
                for (let i = 0; i < module.codeBytes.length; i++) {
                    relocated[i] = module.codeBytes[i];
                }

                // Apply relocations
                for (const reloc of module.relocations) {
                    if (reloc.isWord && reloc.location + 1 < relocated.length) {
                        // Read original value
                        const originalValue = relocated[reloc.location] | (relocated[reloc.location + 1] << 8);

                        let newValue;
                        if (reloc.addressType === 0x01) {
                            // CODE segment relocation
                            newValue = originalValue + module.linkedCodeBase;
                        } else if (reloc.addressType === 0x02) {
                            // DATA segment relocation
                            newValue = originalValue + module.linkedDataBase;
                        } else {
                            // Keep original for absolute
                            newValue = originalValue;
                        }

                        // Write relocated value
                        relocated[reloc.location] = newValue & 0xFF;
                        relocated[reloc.location + 1] = (newValue >> 8) & 0xFF;
                    }
                }

                // Resolve external references
                for (const extRef of module.externalRefs) {
                    console.log(`[DEBUG LINKER] Resolving external ref: "${extRef.symbol}" in module ${module.name}`);
                    console.log(`[DEBUG LINKER] Symbol table keys:`, Object.keys(this.symbolTable));
                    const symbol = this.symbolTable[extRef.symbol];

                    if (!symbol) {
                        console.error(`[DEBUG LINKER] Symbol "${extRef.symbol}" not found! Char codes:`,
                            Array.from(extRef.symbol).map(c => c.charCodeAt(0)));

                        // Check if symbol looks corrupted (non-printable chars)
                        const hasBadChars = Array.from(extRef.symbol).some(c => {
                            const code = c.charCodeAt(0);
                            return code < 32 || code > 126;
                        });

                        if (hasBadChars) {
                            this.errors.push(`Corrupted symbol name in ${module.name} - possible .REL format mismatch!\nTry recompiling ${module.name}.asm with matching REL format.`);
                        } else {
                            this.errors.push(`Undefined external symbol: ${extRef.symbol} in module ${module.name}`);
                        }
                        continue;
                    }

                    // Calculate final address
                    let finalAddress;
                    if (symbol.addressType === 0x01) {
                        // CODE symbol
                        const ownerModule = this.modules.find(m => m.name === symbol.module);
                        finalAddress = symbol.value + (ownerModule?.linkedCodeBase || 0);
                    } else if (symbol.addressType === 0x02) {
                        // DATA symbol
                        const ownerModule = this.modules.find(m => m.name === symbol.module);
                        finalAddress = symbol.value + (ownerModule?.linkedDataBase || 0);
                    } else {
                        // Absolute
                        finalAddress = symbol.value;
                    }

                    // Patch the reference
                    if (extRef.location + 1 < relocated.length) {
                        relocated[extRef.location] = finalAddress & 0xFF;
                        relocated[extRef.location + 1] = (finalAddress >> 8) & 0xFF;
                    }
                }

                if (this.errors.length > 0) {
                    throw new Error(`Link errors:\n${this.errors.join('\n')}`);
                }

                return relocated;
            }
        }

        // Pro version: Library Manager for selective linking
        class LibraryManager {
            constructor() {
                this.libraries = []; // Array of {name, modules: []}
            }

            // Add a library (collection of .REL modules)
            addLibrary(name, modules) {
                this.libraries.push({
                    name: name,
                    modules: modules
                });
                log(`Added library: ${name} with ${modules.length} modules`, 'info');
            }

            // Find modules that satisfy unresolved EXTERN symbols
            resolveExternals(unresolvedSymbols, alreadyIncluded) {
                const resolved = [];

                for (const symbol of unresolvedSymbols) {
                    for (const library of this.libraries) {
                        for (const module of library.modules) {
                            // Skip if already included
                            if (alreadyIncluded.has(module.name)) continue;

                            // Check if this module provides the symbol
                            const providesSymbol = module.publicSymbols.some(
                                pub => pub.name.toUpperCase() === symbol.toUpperCase()
                            );

                            if (providesSymbol) {
                                resolved.push({
                                    symbol: symbol,
                                    module: module,
                                    library: library.name
                                });
                                break; // Found provider, move to next symbol
                            }
                        }
                    }
                }

                return resolved;
            }
        }

        // Pro version: Enhanced Linker with selective library linking
        class SmartLinker extends RelLinker {
            constructor(options = {}) {
                super(options);
                this.libraryManager = new LibraryManager();
                this.includedModules = new Set();
            }

            addLibrary(name, modules) {
                this.libraryManager.addLibrary(name, modules);
            }

            link() {
                log('Smart linking with selective library inclusion...', 'info');

                // Start with explicitly added modules
                for (const module of this.modules) {
                    this.includedModules.add(module.name);
                }

                // Iteratively resolve EXTERN symbols from libraries
                let maxIterations = 10; // Prevent infinite loops
                let iteration = 0;
                let foundNewModules = true;

                while (foundNewModules && iteration < maxIterations) {
                    iteration++;
                    foundNewModules = false;

                    // Collect all unresolved EXTERN symbols
                    const unresolvedSymbols = new Set();
                    for (const module of this.modules) {
                        for (const extRef of module.externalRefs) {
                            unresolvedSymbols.add(extRef.symbol);
                        }
                    }

                    // Remove symbols already provided by included modules
                    for (const module of this.modules) {
                        for (const pubSym of module.publicSymbols) {
                            unresolvedSymbols.delete(pubSym.name);
                        }
                    }

                    if (unresolvedSymbols.size === 0) break;

                    // Try to resolve from libraries
                    const resolved = this.libraryManager.resolveExternals(
                        Array.from(unresolvedSymbols),
                        this.includedModules
                    );

                    for (const {symbol, module, library} of resolved) {
                        log(`  Including ${module.name} from ${library} (provides ${symbol})`, 'info');
                        this.modules.push(module);
                        this.includedModules.add(module.name);
                        foundNewModules = true;
                    }
                }

                // Call parent link method
                return super.link();
            }
        }

        // --- Enhanced Assembler Class ---
        class Assembler {
            constructor(files) {
                this.files = files;
                this.macroTable = {};
                this.symbolTable = {};
                this.constantTable = {}; // Separate table for SET/EQU values
                this.fileMap = [];
                this.symbolInfo = {};
                this.pc = 0;
                this.output = [];
                this.firstOrg = null;                
                this.currentPass = 0;
                this.currentFile = '';
                this.currentLine = 0;
                this.currentInstruction = null;
                this.fileStartAddress = 0;
                this.compilationStats = {
                    totalSize: 0,
                    codeSize: 0,
                    dataSize: 0,
                    symbolCount: 0,
                    fileCount: 0
                };
                this.conditionalStack = []; // For nested IF/ENDIF
                this.tempSymbolCounters = {
                    named: 0,
                    plus: 0,
                    minus: 0,
                    slash: 0
                };
                this.lastNonTempSymbol = '';
                this.numberParser = new NumberParser();
                this.listingLines = []; // For .LST file generation
                this.sourceLines = [];   // Store original source lines
                this.errorCount = 0;     // Track errors for listing

                // Pro version: Segment management for .REL output
                this.outputMode = 'binary'; // 'binary' or 'rel'
                this.segments = {
                    code: { base: 0, size: 0, bytes: [], relocations: [] },
                    data: { base: 0, size: 0, bytes: [], relocations: [] },
                    common: { blocks: {} },
                    absolute: { bytes: [] }
                };
                this.currentSegment = 'code';
                this.publicSymbols = new Set();
                this.externalSymbols = new Set();
                this.externalRefs = []; // {symbol, location, addressType}
                this.relocations = []; // {location, type, segment}
                this.moduleName = '';
            }

            buildImage({ mode = 'range', base = null, size = null, fill = 0xFF } = {}) {
                const src = new Uint8Array(this.output);

                // If no packaging requested, return raw output
                if (!mode && !base && !size) {
                    return src;
                }

                // Derive a sensible window if the caller didn't specify one.
                const first = (this.firstOrg !== null) ? this.firstOrg : 0;
                const last  = src.length; // because you pad this.output to absolute PC

                if (mode !== 'range') { // 'auto' or anything else ‚Üí derive from ORGs
                    if (base == null) base = first;
                    if (size == null) size = Math.max(0, last - base);
                } else {
                // range mode: require base/size; if missing, fall back to first/last
                    if (base == null) base = first;
                    if (size == null) size = Math.max(0, last - base);
                }

                const out = new Uint8Array(size).fill(fill & 0xFF);

                // Copy the intersection of [base, base+size) from src into out[0..size)
                const start = Math.max(0, base);
                const end   = Math.min(src.length, base + size);
                if (end > start) {
                    out.set(src.subarray(start, end), 0);
                }
                return out;
            }


            async assemble(mainFile) {
                try {
                    this.currentFile = mainFile;
                    this.currentPass = 1;
                    log(`--- Pass 1: Conditional processing and macro expansion for ${mainFile} ---`);
                    const pass1_source = await this.expandMacrosAndConditionals(mainFile);

                    // Store all source lines for listing generation
                    this.sourceLines = pass1_source.split('\n');

                    const lexer = new Lexer(pass1_source);
                    let tokens = lexer.tokenize();
                    
                    // CPU directive is optional - default to Z80 if not specified
                    const cpuDirective = tokens.find(t => t.name === 'CPU');
                    if (cpuDirective && cpuDirective.operands[0].value.toUpperCase() !== 'Z80') {
                        throw new Error("Only Z80 CPU is supported (CPU directive found but not set to 'Z80')");
                    }
                    // If no CPU directive, we default to Z80 (zmac-compatible behavior)
                    
                    const fnameDirective = tokens.find(t => t.name === 'FNAME');
                    if (fnameDirective) {
                        outputFilename = fnameDirective.operands[0].value;
                    }

                    this.currentPass = 2;
                    log('--- Pass 2: Building symbol table ---');
                    this.buildSymbolTable(tokens);
                    
                    this.currentPass = 3;
                    log('--- Pass 3: Generating binary code ---');
                    this.generateCode(tokens);

                    // Pro version: Check output mode
                    if (this.outputMode === 'rel') {
                        // Generate .REL file instead of binary
                        log('Generating relocatable object file (.REL)...', 'info');
                        compiledBinary = this.generateRelFile();

                        log(`Relocatable object file generated: ${compiledBinary.length} bytes`, 'success');
                        log(`  Module: ${this.moduleName || 'MODULE'}`, 'info');
                        log(`  Public symbols: ${this.publicSymbols.size}`, 'info');
                        log(`  External references: ${this.externalRefs.length}`, 'info');
                        log(`  Code size: ${this.output.length} bytes`, 'info');
                        log(`  Relocations: ${this.relocations.length}`, 'info');

                        this.displaySymbolTable();
                        return compiledBinary;
                    }

                    // --- Packaging step: Platform-driven configuration ---
                    const platformConfig = getPlatformConfig();
                    const cfg = platformConfig.packager || { mode: null };

                    if (cfg.mode) {
                        compiledBinary = this.buildImage(cfg);
                        log(`Packaged for ${document.getElementById('target-platform').value}: ${platformConfig.description}`, 'info');
                    } else {
                        compiledBinary = this.buildImage();
                        log('Generated raw binary (no packaging)', 'info');
                    }

                    // Platform-specific validation
                    if (platformConfig.validateHeader === 'coleco') {
                        const headerInfo = validateColecoHeader(compiledBinary);
                        if (headerInfo.valid) {
                            log(`Valid ColecoVision ROM: ${headerInfo.usesDefaultScreen ? 'With' : 'Without'} default title screen`, 'success');
                        }
                    }

                    // --- Size metrics calculation ---
                    const src = new Uint8Array(this.output);
                    
                    if (cfg.mode) {
                        // Packaged binary metrics
                        const base = cfg.base || (this.firstOrg ?? 0);
                        const size = cfg.size || Math.max(0, src.length - base);
                        const end = Math.min(src.length, base + size);
                        const payloadUsed = Math.max(0, end - base);
                        const windowFree = Math.max(0, size - payloadUsed);
                        
                        this.compilationStats.totalSize = compiledBinary.length;
                        this.compilationStats.windowBase = base;
                        this.compilationStats.windowSize = size;
                        this.compilationStats.payloadUsed = payloadUsed;
                        this.compilationStats.windowFree = windowFree;
                        
                        log(
                            `Assembly successful! ROM window ${base.toString(16).toUpperCase()}..${(base+size-1).toString(16).toUpperCase()} | ` +
                            `payload used: ${payloadUsed} bytes | free: ${windowFree} bytes | packaged: ${compiledBinary.length} bytes.`,
                            'success'
                        );
                    } else {
                        // Raw binary metrics
                        this.compilationStats.totalSize = compiledBinary.length;
                        this.compilationStats.rawSize = compiledBinary.length;
                        
                        log(
                            `Assembly successful! Raw binary: ${compiledBinary.length} bytes | ` +
                            `Range: ${(this.firstOrg ?? 0).toString(16).toUpperCase()}-${(src.length-1).toString(16).toUpperCase()}`,
                            'success'
                        );
                    }

                    // Common stats
                    this.compilationStats.symbolCount = Object.keys(this.symbolInfo).length;
                    this.compilationStats.fileCount = this.fileMap.length;
                    
                    this.displaySymbolTable();
                    return compiledBinary;

                } catch (e) {
                    log(`Assembly failed on pass ${this.currentPass} in file '${this.currentFile}': ${e.message}`, 'error');
                    console.error(e);
                    return null;
                }
            }
            
            async expandMacrosAndConditionals(filename, visited = new Set()) {
                if (visited.has(filename)) throw new Error(`Circular include detected: ${filename}`);
                visited.add(filename);

                let source = this.files[filename];
                if (!source) throw new Error(`File not found: ${filename}`);
                if (source instanceof Uint8Array) source = new TextDecoder().decode(source);

                const lines = source.split('\n');
                let expandedSource = '';
                let inMacro = false;
                let currentMacro = null;
                let conditionalStack = [];
                let currentConditionState = true;

                for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
                    const line = lines[lineIdx];
                    const trimmed = line.trim();
                    const parts = trimmed.split(/\s+/);
                    const mnemonic = parts.length > 0 ? parts[0].toLowerCase() : '';

                    // Skip lines if we're in a false conditional branch
                    if (!currentConditionState && !['if', 'else', 'elif', 'endif'].includes(mnemonic)) {
                        continue;
                    }

                    if (inMacro) {
                        if (mnemonic === 'endm') {
                            inMacro = false;
                            this.macroTable[currentMacro.name] = currentMacro;
                            log(`Defined macro: ${currentMacro.name}`);
                            currentMacro = null;
                        } else {
                            currentMacro.body.push(line);
                        }
                    } else if (mnemonic === 'macro') {
                        inMacro = true;
                        currentMacro = { name: parts[1], params: parts.slice(2).join('').split(','), body: [] };
                    } else if (mnemonic === 'if') {
                        const condExpr = parts.slice(1).join(' ');
                        const condResult = this.evaluateCondition(condExpr);
                        conditionalStack.push({
                            condition: condResult,
                            hasElse: false,
                            line: lineIdx + 1
                        });
                        currentConditionState = this.calculateCurrentConditionState(conditionalStack);
                    } else if (mnemonic === 'else') {
                        if (conditionalStack.length === 0) {
                            throw new Error(`ELSE without matching IF at line ${lineIdx + 1}`);
                        }
                        const current = conditionalStack[conditionalStack.length - 1];
                        if (current.hasElse) {
                            throw new Error(`Multiple ELSE clauses for IF at line ${current.line}`);
                        }
                        current.hasElse = true;
                        current.condition = !current.condition;
                        currentConditionState = this.calculateCurrentConditionState(conditionalStack);
                    } else if (mnemonic === 'elif') {
                        if (conditionalStack.length === 0) {
                            throw new Error(`ELIF without matching IF at line ${lineIdx + 1}`);
                        }
                        const condExpr = parts.slice(1).join(' ');
                        const condResult = this.evaluateCondition(condExpr);
                        const current = conditionalStack[conditionalStack.length - 1];
                        current.condition = condResult;
                        currentConditionState = this.calculateCurrentConditionState(conditionalStack);
                    } else if (mnemonic === 'endif') {
                        if (conditionalStack.length === 0) {
                            throw new Error(`ENDIF without matching IF at line ${lineIdx + 1}`);
                        }
                        conditionalStack.pop();
                        currentConditionState = this.calculateCurrentConditionState(conditionalStack);
                    } else if (mnemonic === 'include') {
                        const includeFile = parts.slice(1).join(' ').replace(/"/g, '');
                        const includedContent = await this.expandMacrosAndConditionals(includeFile, new Set(visited));
                        expandedSource += `; === INCLUDED FILE: ${includeFile} ===\n`;
                        expandedSource += includedContent + '\n';
                        expandedSource += `; === END OF ${includeFile} ===\n`;
                    } else if (this.macroTable[mnemonic]) {
                        const macro = this.macroTable[mnemonic];
                        const args = trimmed.substring(mnemonic.length).split(',').map(s => s.trim());
                        let macroBody = macro.body.join('\n');
                        macro.params.forEach((param, index) => {
                            const regex = new RegExp(`\\b${param.trim()}\\b`, 'g');
                            macroBody = macroBody.replace(regex, args[index] || '');
                        });
                        expandedSource += `; === MACRO EXPANSION: ${mnemonic} ===\n`;
                        expandedSource += macroBody + '\n';
                        expandedSource += `; === END MACRO: ${mnemonic} ===\n`;
                    } else {
                        expandedSource += line + '\n';
                    }
                }
                
                if (inMacro) throw new Error(`Macro definition for ${currentMacro.name} was not closed with ENDM.`);
                if (conditionalStack.length > 0) {
                    throw new Error(`Unclosed IF directive at line ${conditionalStack[0].line}`);
                }
                
                return expandedSource;
            }

            calculateCurrentConditionState(conditionalStack) {
                return conditionalStack.length === 0 || conditionalStack.every(c => c.condition);
            }

            evaluateCondition(expr) {
                try {
                    // Simple condition evaluation
                    // Replace symbols with their values
                    let evalExpr = expr;
                    
                    // Handle defined() function
                    evalExpr = evalExpr.replace(/defined\s*\(\s*([^)]+)\s*\)/g, (match, symbol) => {
                        return (this.constantTable[symbol] !== undefined || this.symbolTable[symbol] !== undefined) ? '1' : '0';
                    });
                    
                    // Replace symbols with their constant values
                    for (const [symbol, value] of Object.entries(this.constantTable)) {
                        const regex = new RegExp(`\\b${symbol}\\b`, 'g');
                        evalExpr = evalExpr.replace(regex, value);
                    }
                    
                    // Try to parse numbers
                    evalExpr = evalExpr.replace(/\$[0-9a-fA-F]+/g, (match) => {
                        return parseInt(match.substring(1), 16).toString();
                    });
                    
                    // Basic expression evaluation
                    const result = new Function(`return ${evalExpr}`)();
                    return Boolean(result);
                } catch (e) {
                    log(`Warning: Could not evaluate condition '${expr}', assuming false`, 'warn');
                    return false;
                }
            }

            processTemporarySymbol(label) {
                if (label.startsWith('$')) {
                    // Named temporary symbol
                    return `__temp_named_${this.tempSymbolCounters.named}_${label.substring(2)}`;
                } else if (label === '+' || label === '-' || label === '/') {
                    // Nameless temporary symbol
                    if (label === '+') {
                        const newLabel = `__temp_plus_${this.tempSymbolCounters.plus}`;
                        this.tempSymbolCounters.plus++;
                        return newLabel;
                    } else if (label === '-') {
                        const newLabel = `__temp_minus_${this.tempSymbolCounters.minus}`;
                        this.tempSymbolCounters.minus++;
                        return newLabel;
                    } else if (label === '/') {
                        const newLabel = `__temp_slash_${this.tempSymbolCounters.slash}`;
                        this.tempSymbolCounters.slash++;
                        return newLabel;
                    }
                } else if (label.startsWith('.')) {
                    // Composed temporary symbol
                    return `${this.lastNonTempSymbol}${label}`;
                }
                return label;
            }

            resolveTemporarySymbolReference(symbol) {
                // Handle references to temporary symbols in expressions
                if (symbol === '+' || symbol === '++' || symbol === '+++') {
                    const lookAhead = symbol.length;
                    // Find the next plus symbol
                    for (let i = this.tempSymbolCounters.plus; i < this.tempSymbolCounters.plus + 10; i++) {
                        const candidate = `__temp_plus_${i}`;
                        if (this.symbolTable[candidate] !== undefined) {
                            return candidate;
                        }
                    }
                } else if (symbol === '-' || symbol === '--' || symbol === '---') {
                    const lookBack = symbol.length;
                    // Find the previous minus symbol
                    for (let i = this.tempSymbolCounters.minus - 1; i >= Math.max(0, this.tempSymbolCounters.minus - 10); i--) {
                        const candidate = `__temp_minus_${i}`;
                        if (this.symbolTable[candidate] !== undefined) {
                            return candidate;
                        }
                    }
                }
                return symbol;
            }

            trackFileStart(filename, address) {
                this.fileStartAddress = address;
                this.currentFile = filename;
            }

            trackFileEnd(filename, address, type = 'code') {
                const size = address - this.fileStartAddress;
                this.fileMap.push({
                    filename: filename,
                    startAddr: this.fileStartAddress,
                    endAddr: address,
                    size: size,
                    type: type
                });
                
                if (type === 'code') {
                    this.compilationStats.codeSize += size;
                } else {
                    this.compilationStats.dataSize += size;
                }
            }

            buildSymbolTable(tokens) {
                this.pc = 0;
                this.symbolTable = {};
                this.constantTable = {};
                this.symbolInfo = {};
                let currentSourceFile = 'main';
                
                for (const token of tokens) {
                    this.currentInstruction = token;
                    this.currentLine = token.lineNumber || 0;
                    
                    try {
                        if (token.label) {
                            const processedLabel = this.processTemporarySymbol(token.label);
                            
                            if (this.symbolTable[processedLabel] !== undefined) {
                               log(`Warning: Redefining label '${processedLabel}' at line ${this.currentLine}`, 'warn');
                            }
                            
                            this.symbolTable[processedLabel] = this.pc;
                            this.symbolInfo[processedLabel] = {
                                address: this.pc,
                                file: currentSourceFile,
                                lineNumber: this.currentLine,
                                type: token instanceof Directive ? 'constant' : 'label',
                                size: 0
                            };
                            
                            // Track last non-temporary symbol for composed temporary symbols
                            if (!token.label.startsWith('.') && !['+', '-', '/'].includes(token.label)) {
                                this.lastNonTempSymbol = processedLabel;
                            }
                        }

                        if (token instanceof Directive) {
                            switch (token.name) {
                                case 'ORG': 
                                    this.pc = this.evaluateExpression(token.operands[0]); 
                                    this.trackFileStart(currentSourceFile, this.pc);
                                    break;
                                case 'EQU':
                                    if (!token.label) throw new Error("EQU directive requires a label.");
                                    const equValue = this.evaluateExpression(token.operands[0]);
                                    const processedEquLabel = this.processTemporarySymbol(token.label);
                                    this.symbolTable[processedEquLabel] = equValue;
                                    this.constantTable[processedEquLabel] = equValue;
                                    this.symbolInfo[processedEquLabel] = {
                                        address: equValue,
                                        file: currentSourceFile,
                                        lineNumber: this.currentLine,
                                        type: 'constant',
                                        size: 0
                                    };
                                    break;
                                case 'EVAL':
                                    if (!token.label) throw new Error(`${token.name} directive requires a label.`);
                                    const setValue = this.evaluateExpression(token.operands[0]);
                                    const processedSetLabel = this.processTemporarySymbol(token.label);
                                    this.constantTable[processedSetLabel] = setValue;
                                    this.symbolInfo[processedSetLabel] = {
                                        address: setValue,
                                        file: currentSourceFile,
                                        lineNumber: this.currentLine,
                                        type: 'variable',
                                        size: 0
                                    };
                                    break;
                                case 'CONSTANT':
                                    // KCPSM-style constant definition
                                    if (token.operands.length < 2) throw new Error("CONSTANT directive requires name and value.");
                                    const constName = token.operands[0].value;
                                    const constValue = this.evaluateExpression(token.operands[1]);
                                    this.constantTable[constName] = constValue;
                                    this.symbolInfo[constName] = {
                                        address: constValue,
                                        file: currentSourceFile,
                                        lineNumber: this.currentLine,
                                        type: 'constant',
                                        size: 0
                                    };
                                    break;
                                case 'DB': case 'DEFB': case 'DEFM': case 'ASCII': case 'TEXT': case 'BYTE':
                                    const dbSize = token.operands.reduce((sum, op) =>
                                        sum + ((op.type === 'string') ? op.value.length : 1), 0);
                                    this.pc += dbSize;
                                    break;
                                case 'DW': case 'DEFW': case 'WORD':
                                    this.pc += token.operands.length * 2;
                                    break;
                                case 'DS': case 'DEFS': 
                                    this.pc += this.evaluateExpression(token.operands[0]); 
                                    break;
                                case 'INCBIN':
                                    const filename = token.operands[0].value;
                                    const fileData = this.findFile(filename);
                                    const incbinStartAddr = this.pc;
                                    this.pc += fileData.length;
                                    // Track binary file inclusion
                                    this.fileMap.push({
                                        filename: filename,
                                        startAddr: incbinStartAddr,
                                        endAddr: this.pc,
                                        size: fileData.length,
                                        type: 'binary'
                                    });
                                    break;
                                case 'RADIX':
                                    this.numberParser.defaultRadix = this.evaluateExpression(token.operands[0]);
                                    break;

                                // Pro version: Symbol visibility directives
                                case 'PUBLIC': case 'GLOBAL': case 'GLOBL': case 'ENTRY':
                                    // Mark symbols as public (exported)
                                    // SDCC uses .globl, traditional uses PUBLIC/GLOBAL
                                    for (const operand of token.operands) {
                                        const symbolName = operand.value;
                                        this.publicSymbols.add(symbolName);
                                    }
                                    break;

                                case 'EXTERN': case 'EXT': case 'EXTRN':
                                    // Mark symbols as external (imported)
                                    for (const operand of token.operands) {
                                        const symbolName = operand.value;
                                        this.externalSymbols.add(symbolName);
                                    }
                                    break;

                                // Pro version: Segment directives
                                case 'CSEG':
                                    this.currentSegment = 'code';
                                    break;

                                case 'DSEG':
                                    this.currentSegment = 'data';
                                    break;

                                case 'ASEG':
                                    this.currentSegment = 'absolute';
                                    break;

                                case 'COMMON':
                                    // COMMON /name/ directive
                                    if (token.operands.length > 0) {
                                        const blockName = token.operands[0].value;
                                        this.currentSegment = 'common';
                                        if (!this.segments.common.blocks[blockName]) {
                                            this.segments.common.blocks[blockName] = { size: 0, bytes: [] };
                                        }
                                    }
                                    break;

                                // SDCC-style directives
                                case 'AREA':
                                    // .area directive (SDCC syntax)
                                    if (token.operands.length > 0) {
                                        let areaName = token.operands[0].value.toString();

                                        // Handle area attributes like _CODE, _DATA, _HEADER(ABS)
                                        const isAbsolute = areaName.includes('(ABS)');
                                        areaName = areaName.replace(/\(ABS\)/i, '').trim();

                                        // Map SDCC area names to our segment types
                                        if (areaName === '_CODE' || areaName === 'CODE') {
                                            this.currentSegment = 'code';
                                        } else if (areaName === '_DATA' || areaName === 'DATA' || areaName === '_BSS' || areaName === 'BSS') {
                                            this.currentSegment = 'data';
                                        } else if (isAbsolute || areaName === '_HEADER' || areaName === 'HEADER') {
                                            this.currentSegment = 'absolute';
                                        } else {
                                            // Unknown area - default to code segment
                                            this.currentSegment = 'code';
                                            log(`Warning: Unknown area '${areaName}', defaulting to code segment`, 'warn');
                                        }
                                    }
                                    break;

                                case 'MODULE':
                                    // .module directive (SDCC module name)
                                    if (token.operands.length > 0) {
                                        this.moduleName = token.operands[0].value.toString();
                                    }
                                    break;
                            }
                        } else if (token instanceof Instruction) {
                            const key = this.getOpcodeKey(token);
                            const opcode = Z80_OPCODES[key];
                            if (opcode) {
                                this.pc += opcode.length;
                                if (key.includes('imm8') || key.includes('rel8')) this.pc += 1;
                                if (key.includes('imm16')) this.pc += 2;
                                if (key.includes('offset')) this.pc += 1; // IX/IY offset
                            } else {
                                // Fallback size estimation for unknown opcodes
                                let size = 1;
                                if (token.mnemonic.startsWith('ld')) size++;
                                if (token.operands.some(op => 
                                    op.type === 'immediate' && op.value > 255 ||
                                    op.type === 'symbol' ||
                                    (op.type === 'memory' && (typeof op.value === 'number' || (typeof op.value === 'string' && !['bc','de','hl','sp','c'].includes(op.value.toLowerCase()))))
                                )) size += 1;
                                this.pc += size;
                                log(`Using estimated size ${size} for opcode: ${token.mnemonic} ${token.operands.map(o=>o.value).join(',')} at line ${this.currentLine}`, 'warn');
                            }
                        }
                    } catch (error) {
                        // Add context to the error
                        const contextMsg = `Line ${this.currentLine}: ${token.mnemonic || token.name || 'directive'} - ${error.message}`;
                        throw new Error(contextMsg);
                    }
                }
                
                // Calculate symbol sizes (distance to next symbol)
                const sortedSymbols = Object.keys(this.symbolInfo)
                    .filter(name => this.symbolInfo[name].type === 'label')
                    .sort((a, b) => this.symbolInfo[a].address - this.symbolInfo[b].address);
                
                for (let i = 0; i < sortedSymbols.length - 1; i++) {
                    const currentSym = sortedSymbols[i];
                    const nextSym = sortedSymbols[i + 1];
                    this.symbolInfo[currentSym].size = this.symbolInfo[nextSym].address - this.symbolInfo[currentSym].address;
                }
                
                log('Symbol table built successfully.');
                console.log('Symbol Table:', this.symbolTable);
                console.log('Symbol Info:', this.symbolInfo);
                console.log('File Map:', this.fileMap);
            }

            findFile(filename) {
                if (this.files[filename]) return this.files[filename];
                
                // Try case-insensitive lookup
                const lowercaseFilename = filename.toLowerCase();
                const foundFile = Object.keys(this.files).find(f => f.toLowerCase() === lowercaseFilename);
                if (foundFile) {
                    return this.files[foundFile];
                }
                throw new Error(`File not found: "${filename}". Available files: ${Object.keys(this.files).join(', ')}`);
            }

            displaySymbolTable() {
                let output = '';
                output += '=== COMPILATION SUMMARY ===\n';
                output += `Total Size: ${this.compilationStats.totalSize} bytes\n`;
                output += `Code Size: ${this.compilationStats.codeSize} bytes\n`;
                output += `Data Size: ${this.compilationStats.dataSize} bytes\n`;
                output += `Symbol Count: ${this.compilationStats.symbolCount}\n`;
                output += `File Count: ${this.compilationStats.fileCount}\n\n`;
                
                // Show different info based on packaging mode
                if (this.compilationStats.windowBase !== undefined) {
                    output += `ROM Window Base: ${this.compilationStats.windowBase.toString(16).toUpperCase()}\n`;
                    output += `ROM Window Size: ${this.compilationStats.windowSize} bytes\n`;
                    output += `Payload Used:    ${this.compilationStats.payloadUsed} bytes\n`;
                    output += `Window Free:     ${this.compilationStats.windowFree} bytes\n\n`;
                } else if (this.compilationStats.rawSize !== undefined) {
                    output += `Raw Binary Size: ${this.compilationStats.rawSize} bytes\n`;
                    output += `Address Range: ${(this.firstOrg ?? 0).toString(16).toUpperCase()}-${(this.output.length-1).toString(16).toUpperCase()}\n\n`;
                }
                
                output += '=== FILE MAP ===\n';
                output += 'Filename                 Start    End      Size     Type\n';
                output += '--------------------------------------------------------\n';
                for (const file of this.fileMap) {
                    output += `${file.filename.padEnd(25)}${file.startAddr.toString(16).toUpperCase().padStart(4, '0')}   ${file.endAddr.toString(16).toUpperCase().padStart(4, '0')}   ${file.size.toString().padStart(6)}   ${file.type}\n`;
                }
                
                output += '\n=== SYMBOL TABLE ===\n';
                output += 'Symbol                   Address  File         Line Type      Size\n';
                output += '----------------------------------------------------------------\n';
                
                const sortedSymbols = Object.keys(this.symbolInfo).sort((a, b) => 
                    this.symbolInfo[a].address - this.symbolInfo[b].address);
                
                for (const symbol of sortedSymbols) {
                    const info = this.symbolInfo[symbol];
                    output += `${symbol.padEnd(25)}${info.address.toString(16).toUpperCase().padStart(4, '0')}   ${info.file.padEnd(12)} ${info.lineNumber.toString().padStart(4)} ${info.type.padEnd(9)} ${info.size}\n`;
                }
                
                symbolsOutput.innerHTML = output;
            }

            generateCode(tokens) {
                this.pc = 0;
                this.output = [];
                for (const token of tokens) {
                    this.currentInstruction = token;
                    this.currentLine = token.lineNumber || 0;

                    // Track state for listing generation
                    const startPC = this.pc;
                    let hasError = false;
                    let errorMsg = '';

                    try {
                        if (token.label) {
                            const processedLabel = this.processTemporarySymbol(token.label);
                            this.pc = this.symbolTable[processedLabel];

                            // Pro version: In .REL mode, don't fill with zeros - linker handles placement
                            if (this.outputMode !== 'rel') {
                                while(this.output.length < this.pc) this.output.push(0);
                            }
                        }

                        if (token instanceof Directive) {
                            switch (token.name) {
                                case 'ORG':
                                    this.pc = this.evaluateExpression(token.operands[0]);
                                    if (this.firstOrg === null) this.firstOrg = this.pc;   // remember first ORG

                                    // Pro version: In .REL mode, don't fill with zeros - linker handles placement
                                    if (this.outputMode !== 'rel') {
                                        while (this.output.length < this.pc) this.output.push(0);
                                    }
                                    break;
                                case 'DB': case 'DEFB': case 'DEFM': case 'ASCII': case 'TEXT': case 'BYTE':
                                    token.operands.forEach(op => {
                                        if (op.type === 'string') {
                                            for (let i = 0; i < op.value.length; i++) this.output.push(op.value.charCodeAt(i));
                                        } else {
                                            this.output.push(this.evaluateExpression(op) & 0xFF);
                                        }
                                    });
                                    break;
                                case 'DW': case 'DEFW': case 'WORD':
                                    token.operands.forEach(op => {
                                        const val = this.evaluateExpression(op);

                                        // Pro version: Track relocation for symbol references
                                        if (this.needsRelocation(op)) {
                                            // In .REL mode, use output buffer position; in binary mode, use PC
                                            const location = this.outputMode === 'rel' ? this.output.length : this.pc;
                                            this.trackRelocation(op.value, location, true);
                                        }

                                        this.output.push(val & 0xFF);
                                        this.output.push((val >> 8) & 0xFF);
                                    });
                                    break;
                                case 'DS': case 'DEFS':
                                    const size = this.evaluateExpression(token.operands[0]);
                                    const fill = token.operands.length > 1 ? this.evaluateExpression(token.operands[1]) : 0;
                                    for (let i = 0; i < size; i++) this.output.push(fill & 0xFF);
                                    break;
                                case 'INCBIN':
                                    const filename = token.operands[0].value;
                                    const fileData = this.findFile(filename);
                                    this.output.push(...fileData);
                                    break;
                            }
                        } else if (token instanceof Instruction) {
                            const key = this.getOpcodeKey(token);
                            const opcode = Z80_OPCODES[key];
                            if (!opcode) {
                                const errorMsg = `Unknown instruction: ${token.mnemonic} ${token.operands.map(o => {
                                    if (o.type === 'memory') return `(${o.value})`;
                                    return o.value;
                                }).join(', ')} [Generated key: ${key}]`;
                                throw new Error(errorMsg);
                            }
                            
                            this.output.push(...opcode);
                            
                            // Handle operands
                            if (key.includes('imm16')) {
                                 const operand = token.operands.find(o => o.type === 'symbol' || o.type === 'immediate' || (o.type === 'memory' && (typeof o.value === 'number' || (typeof o.value === 'string' && !['bc','de','hl','sp','c'].includes(o.value.toLowerCase())))));
                                 if (!operand) throw new Error(`No 16-bit operand found for instruction: ${token.mnemonic}`);

                                 let val;
                                 let symbolForRelocation = null;

                                 if (operand.type === 'memory') {
                                     if (typeof operand.value === 'number') {
                                         val = operand.value;
                                     } else {
                                         // Memory operand with symbol - evaluate the symbol inside the parentheses
                                         symbolForRelocation = {type: 'symbol', value: operand.value};
                                         val = this.evaluateExpression(symbolForRelocation);
                                     }
                                 } else {
                                     val = this.evaluateExpression(operand);
                                     if (operand.type === 'symbol') {
                                         symbolForRelocation = operand;
                                     }
                                 }

                                 // Pro version: Track relocation for symbol references
                                 if (symbolForRelocation && this.needsRelocation(symbolForRelocation)) {
                                     // In .REL mode, use output buffer position; in binary mode, use PC
                                     const location = this.outputMode === 'rel' ? this.output.length : (this.pc + opcode.length);
                                     this.trackRelocation(symbolForRelocation.value, location, true);
                                 }

                                 this.output.push(val & 0xFF);
                                 this.output.push((val >> 8) & 0xFF);
                            } else if (key.includes('imm8')) {
                                const operand = token.operands.find(o => 
                                    o.type === 'symbol' || 
                                    o.type === 'immediate' ||
                                    (o.type === 'memory' && (typeof o.value === 'number' || (typeof o.value === 'string' && !['bc','de','hl','sp','c'].includes(o.value.toLowerCase()))))
                                );
                                if (!operand) throw new Error(`No 8-bit operand found for instruction: ${token.mnemonic}`);
                                
                                let val;
                                if (operand.type === 'memory') {
                                    if (typeof operand.value === 'number') {
                                        val = operand.value;
                                    } else {
                                        // Memory operand with symbol - evaluate the symbol inside the parentheses
                                        val = this.evaluateExpression({type: 'symbol', value: operand.value});
                                    }
                                } else {
                                    val = this.evaluateExpression(operand);
                                }
                                this.output.push(val & 0xFF);
                            } else if (key.includes('rel8')) {
                                const operand = token.operands.find(o => o.type === 'symbol' || o.type === 'immediate');
                                const targetAddr = this.evaluateExpression(operand);
                                // Calculate current address: PC + instruction size (opcode bytes + 1 displacement byte)
                                const instrSize = opcode.length + 1;

                                // Pro version: In .REL mode, use output buffer position for relative jumps
                                // In binary mode, use absolute PC
                                let currentAddr, adjustedTargetAddr;
                                if (this.outputMode === 'rel') {
                                    // Use output buffer positions (0-based)
                                    currentAddr = this.output.length + instrSize;
                                    // Target is also relative to segment start
                                    adjustedTargetAddr = targetAddr - (this.firstOrg || 0);
                                } else {
                                    // Binary mode: use absolute addresses
                                    currentAddr = this.pc + instrSize;
                                    adjustedTargetAddr = targetAddr;
                                }

                                let offset = adjustedTargetAddr - currentAddr;
                                if (offset < -128 || offset > 127) throw new Error(`Relative jump out of range for ${token.mnemonic}: offset ${offset} (target: ${adjustedTargetAddr}, current: ${currentAddr})`);
                                if (offset < 0) offset += 256;
                                this.output.push(offset);
                            } else if (key.includes('offset')) {
                                // IX/IY displacement - improved parsing for all formats
                                const offsetOperand = token.operands.find(o => o.type === 'memory' && typeof o.value === 'string');
                                if (offsetOperand) {
                                    // Extract offset from formats like: IX+5, IY-10, IX+SYMBOL, IX (zero offset)
                                    const match = offsetOperand.value.match(/(?:IX|IY)\s*([+-])\s*(.+)/i) ||
                                                  offsetOperand.value.match(/(?:IX|IY)\s*$/i);
                                    if (match && match[1] && match[2]) {
                                        // Has explicit offset: IX+5 or IY-SYMBOL
                                        const sign = match[1] === '-' ? -1 : 1;
                                        const offsetValue = this.evaluateExpression({type: 'symbol', value: match[2]});
                                        const signedOffset = sign * offsetValue;
                                        this.output.push(signedOffset & 0xFF);
                                    } else {
                                        // No offset or just IX/IY - use 0
                                        this.output.push(0);
                                    }
                                }
                            }
                        }
                        this.pc = this.output.length;
                    } catch (error) {
                        // Capture error for listing
                        hasError = true;
                        errorMsg = error.message;
                        this.errorCount++;

                        // Add context to the error
                        const contextMsg = `Line ${this.currentLine}: ${token.mnemonic || 'directive'} ${(token.operands || []).map(o => o.value).join(', ')} - ${error.message}`;
                        throw new Error(contextMsg);
                    } finally {
                        // Create listing entry after processing token
                        const bytesGenerated = this.output.slice(startPC, this.pc);

                        // For ORG and other PC-changing directives, show the new PC, not the old one
                        let displayAddress = startPC;
                        if (token instanceof Directive && token.name === 'ORG') {
                            displayAddress = this.pc; // Show the ORG target address
                        }

                        const listingEntry = {
                            lineNum: token.lineNumber || 0,
                            address: displayAddress,
                            bytes: Array.from(bytesGenerated),
                            sourceLine: token.sourceLine || '',
                            label: token.label || '',
                            hasError: hasError,
                            errorMsg: errorMsg
                        };
                        this.listingLines.push(listingEntry);
                    }
                }
            }

            exportSymbolTable() {
                const data = {
                    compilationStats: this.compilationStats,
                    fileMap: this.fileMap,
                    symbolTable: this.symbolTable,
                    constantTable: this.constantTable,
                    symbolInfo: this.symbolInfo,
                    timestamp: new Date().toISOString()
                };
                return JSON.stringify(data, null, 2);
            }

            generateListingFile() {
                let output = '';

                console.log(`DEBUG: generateListingFile() called, sourceLines.length = ${this.sourceLines.length}, listingLines.length = ${this.listingLines.length}`);

                // Create a map of line numbers to listing entries
                const listingMap = {};
                for (const entry of this.listingLines) {
                    listingMap[entry.lineNum] = entry;
                }

                // Iterate through ALL source lines
                for (let i = 0; i < this.sourceLines.length; i++) {
                    const lineNum = String(i + 1).padStart(4, '0');
                    const sourceLine = this.sourceLines[i];
                    const entry = listingMap[i + 1];

                    // Check if this is a directive that doesn't generate code (ORG, EQU, SET, etc.)
                    const isNonCodeDirective = /^\s*\.?(org|equ|set|if|else|endif|macro|endm|include)\b/i.test(sourceLine);

                    // Check if line is blank or only whitespace/comment
                    const isBlankLine = sourceLine.trim() === '' || sourceLine.trim().startsWith(';');

                    if (isBlankLine) {
                        // Blank line: just line number and spaces
                        output += `${lineNum}   ${' '.repeat(4)}             ${sourceLine}\n`;
                    } else if (!entry || isNonCodeDirective || (entry && entry.bytes.length === 0)) {
                        // Non-code directive or no bytes: show address but no bytes
                        const address = entry ? entry.address.toString(16).toUpperCase().padStart(4, '0') : '    ';
                        output += `${lineNum}   ${address}             ${sourceLine}\n`;
                    } else {
                        // Has bytes: show address and bytes
                        const address = entry.address.toString(16).toUpperCase().padStart(4, '0');

                        // Format bytes WITHOUT spaces (like TASM: "000000000000" not "00 00 00 00")
                        const hexBytes = entry.bytes.map(b => b.toString(16).toUpperCase().padStart(2, '0')).join('');

                        // Pad bytes to 12 characters (fits 6 bytes)
                        const bytesStr = hexBytes.padEnd(12, ' ');

                        output += `${lineNum}   ${address} ${bytesStr} ${sourceLine}\n`;
                    }

                    // If there's an error, add error message on next line
                    if (entry && entry.hasError) {
                        const errorLine = `${sourceLine.split(/\s+/)[0]} line ${lineNum}: ${entry.errorMsg}`;
                        output += errorLine + '\n';
                    }
                }

                // Add final summary line
                output += `tasm: Number of errors = ${this.errorCount}\n`;

                return output;
            }

            getOpcodeKey(instruction) {
                const mnemonic = instruction.mnemonic.toLowerCase();

                // Handle EX AF,AF' specifically
                if (mnemonic === 'ex' && instruction.operands.length === 2 &&
                    instruction.operands[0].type === 'register_pair' && 
                    instruction.operands[0].value.toUpperCase() === 'AF' &&
                    instruction.operands[1].type === 'register_pair' && 
                    instruction.operands[1].value.toUpperCase() === "AF'") {
                    return 'ex_af,af\'';
                }

                // Handle IM instructions
                if (mnemonic === 'im' && instruction.operands.length === 1) {
                    return `im_${instruction.operands[0].value}`;
                }

                // Handle RST instructions
                if (mnemonic === 'rst' && instruction.operands.length === 1) {
                    const rstValue = this.evaluateExpression(instruction.operands[0]);
                    const rstMap = {0: '00h', 8: '08h', 16: '10h', 24: '18h', 32: '20h', 40: '28h', 48: '30h', 56: '38h'};
                    if (rstMap[rstValue]) {
                        return `rst_${rstMap[rstValue]}`;
                    }
                    return `rst_${rstValue}`;
                }

                if (instruction.operands.length === 0) return mnemonic;

                // Handle special undocumented IN (C) instruction  
                if (mnemonic === 'in' && instruction.operands.length === 1 && 
                    instruction.operands[0].type === 'memory' && 
                    typeof instruction.operands[0].value === 'string' &&
                    instruction.operands[0].value.toLowerCase() === 'c') {
                    return 'in_(c)';
                }

                // Handle OUT (C),0 instruction
                if (mnemonic === 'out' && instruction.operands.length === 2 &&
                    instruction.operands[0].type === 'memory' && 
                    typeof instruction.operands[0].value === 'string' &&
                    instruction.operands[0].value.toLowerCase() === 'c' &&
                    instruction.operands[1].type === 'immediate' &&
                    instruction.operands[1].value === 0) {
                    return 'out_(c),0';
                }

                // Handle JP (IX), JP (IY), JP (HL)
                if (mnemonic === 'jp' && instruction.operands.length === 1 && 
                    instruction.operands[0].type === 'memory') {
                    const memVal = instruction.operands[0].value;
                    if (typeof memVal === 'string') {
                        const reg = memVal.toLowerCase();
                        if (reg === 'ix') return 'jp_(ix)';
                        if (reg === 'iy') return 'jp_(iy)';
                        if (reg === 'hl') return 'jp_(hl)';
                    }
                }

                // Handle conditional jumps and calls
                if ((mnemonic === 'jp' || mnemonic === 'jr' || mnemonic === 'call' || mnemonic === 'ret') && 
                    instruction.operands.length > 0 && instruction.operands[0].type === 'condition') {
                    const condition = instruction.operands[0].value.toLowerCase();
                    if (instruction.operands.length === 1) {
                        return `${mnemonic}_${condition}`;
                    } else {
                        const addrType = (mnemonic === 'jr') ? 'rel8' : 'imm16';
                        return `${mnemonic}_${condition},${addrType}`;
                    }
                }

                const opTypes = instruction.operands.map(op => {
                    switch(op.type) {
                        case 'register': return op.value.toLowerCase();
                        case 'register_pair': 
                            // Handle AF' correctly
                            if (op.value.toUpperCase() === "AF'") return "af'";
                            return op.value.toLowerCase();
                        case 'condition': return op.value.toLowerCase();
                        case 'memory': 
                            // Handle memory operands - check if it's a known register or immediate address
                            if (typeof op.value === 'string') {
                                const memValue = op.value.toLowerCase();
                                // Handle IX/IY with displacement
                                if (memValue.includes('ix+') || memValue.includes('ix-')) {
                                    return '(ix+offset)';
                                }
                                if (memValue.includes('iy+') || memValue.includes('iy-')) {
                                    return '(iy+offset)';
                                }
                                if (['bc', 'de', 'hl', 'sp', 'c', 'ix', 'iy'].includes(memValue)) {
                                    return `(${memValue})`;
                                } else {
                                    // Special case for IN/OUT instructions - ports are 8-bit
                                    if (['in', 'out'].includes(mnemonic)) {
                                        return '(imm8)';
                                    }
                                    // Memory operand with symbol/address - treat as (imm16) for opcode lookup
                                    return '(imm16)';
                                }
                            } else {
                                // Numeric memory operand
                                if (['in', 'out'].includes(mnemonic)) {
                                    return '(imm8)';
                                }
                                return '(imm16)';
                            }
                        case 'immediate':
                        case 'symbol':
                            // Special handling for the first operand of bit/res/set
                            if (['bit', 'res', 'set'].includes(mnemonic) && instruction.operands.indexOf(op) === 0) {
                                const val = this.evaluateExpression(op);
                                if (val < 0 || val > 7) {
                                    throw new Error(`Bit position must be 0-7 for ${mnemonic}, got ${val}`);
                                }
                                return String(val);
                            }                          
                            if (mnemonic.startsWith('jr') || mnemonic === 'djnz') return 'rel8';
                            if (mnemonic === 'jp' || mnemonic === 'call') {
                                if (instruction.operands[0].type === 'memory') {
                                    const memVal = instruction.operands[0].value;
                                    if (typeof memVal === 'string') {
                                        return `(${memVal.toLowerCase()})`;
                                    } else {
                                        return '(imm16)';
                                    }
                                }
                                return 'imm16';
                            }
                            if (mnemonic === 'ld') {
                                const dest = instruction.operands[0];
                                if (dest.type === 'register_pair') return 'imm16';
                                if (dest.type === 'memory') {
                                    if (typeof dest.value === 'string') {
                                        if (!['bc','de','hl','ix','iy'].includes(dest.value.toLowerCase())) return 'imm16';
                                    } else {
                                        return 'imm16'; // Numeric memory operand
                                    }
                                }
                                return 'imm8';
                            }
                            if (['add', 'adc', 'sub', 'sbc', 'and', 'or', 'xor', 'cp', 'out', 'in'].includes(mnemonic)) {
                                return 'imm8';
                            }
                            if (['rst'].includes(mnemonic)) {
                                // RST is special - it's actually encoded in the opcode itself
                                return op.value.toString(16).padStart(2, '0') + 'h';
                            }
                            return 'imm16';
                        default: return 'unknown';
                    }
                }).join(',');
                
                return `${mnemonic}_${opTypes}`;
            }

            evaluateExpression(operand) {
                try {
                    if (operand.type === 'immediate') return operand.value;
                    if (operand.type !== 'symbol') {
                        if (this.currentPass < 3) return 0;
                        throw new Error(`Cannot evaluate expression for operand type: ${operand.type}`);
                    }

                    let expr = String(operand.value);
                    const originalExpr = expr; // Keep original for error reporting

                    // Handle temporary symbol references
                    expr = this.resolveTemporarySymbolReference(expr);
                
                    // Check if it's a direct opcode reference
                    const opcode = Z80_OPCODES[expr.toLowerCase()];
                    if (opcode) {
                        return opcode[opcode.length - 1];
                    }

                    // IMPORTANT: Parse hex/bin/oct numbers FIRST, before replacing $ with PC
                    // This allows $702b to be treated as hex, not $ (PC) followed by 702b
                    let parsedExpr = expr;
                    parsedExpr = parsedExpr.replace(/0x([0-9a-fA-F]+)/gi, (match, hex) => parseInt(hex, 16));
                    parsedExpr = parsedExpr.replace(/\$([0-9a-fA-F]+)/g, (match, hex) => parseInt(hex, 16));
                    parsedExpr = parsedExpr.replace(/([0-9a-fA-F]+)h\b/gi, (match, hex) => parseInt(hex, 16));
                    parsedExpr = parsedExpr.replace(/%([01]+)/g, (match, bin) => parseInt(bin, 2));
                    parsedExpr = parsedExpr.replace(/([01]+)b\b/gi, (match, bin) => parseInt(bin, 2));
                    parsedExpr = parsedExpr.replace(/@([0-7]+)/g, (match, oct) => parseInt(oct, 8));

                    // NOW replace $ with PC (for expressions like $ or $+5 where $ is alone)
                    parsedExpr = parsedExpr.replace(/\$/g, this.pc);
                    parsedExpr = parsedExpr.replace(/\*/g, this.pc); // Alternative PC symbol

                    // Replace constants first (higher priority than symbols)
                    const sortedConstants = Object.keys(this.constantTable).sort((a, b) => b.length - a.length);
                    for (const constant of sortedConstants) {
                        const regex = new RegExp(`\\b${constant}\\b`, 'g');
                        parsedExpr = parsedExpr.replace(regex, this.constantTable[constant]);
                    }

                    // Replace symbols
                    const sortedSymbols = Object.keys(this.symbolTable).sort((a, b) => b.length - a.length);

                    for (const symbol of sortedSymbols) {
                        const regex = new RegExp(`\\b${symbol}\\b`, 'g');
                        parsedExpr = parsedExpr.replace(regex, this.symbolTable[symbol]);
                    }

                    // Replace character constants with their ASCII values (supports both ' and ")
                    // Matches: 'X' or "X" where X is any single character
                    parsedExpr = parsedExpr.replace(/['"](.)['"]/g, (match, char) => {
                        return char.charCodeAt(0).toString();
                    });

                    // Pro version: Check if remaining symbol is EXTERN (after symbol table replacement)
                    // If the expression still contains letters and it's an EXTERN symbol, return 0
                    const trimmedExpr = parsedExpr.trim();
                    if (this.outputMode === 'rel' && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(trimmedExpr)) {
                        // Check all external symbols (case-insensitive for safety)
                        for (const extSym of this.externalSymbols) {
                            if (extSym.toUpperCase() === trimmedExpr.toUpperCase()) {
                                // External symbol - return 0 as placeholder
                                return 0;
                            }
                        }
                    }

                    // Parse numbers with different bases (for simple number values)
                    const numValue = this.numberParser.parseNumber(parsedExpr);
                    if (numValue !== null) {
                        return numValue;
                    }

                    try {

                        // Now check for undefined symbols (after hex parsing)
                        if (/[a-zA-Z_]/.test(parsedExpr)) {
                            if (this.currentPass < 3) return 0;
                            throw new Error(`Undefined symbol in expression: ${originalExpr} (evaluated to: ${parsedExpr})`);
                        }

                        const sanitizedExpr = parsedExpr.replace(/[^\d\+\-\*\/\(\)\s\.]/g, '');
                        if (sanitizedExpr.trim() !== parsedExpr.trim()) {
                             if (this.currentPass < 3) return 0;
                             throw new Error(`Invalid characters in expression: ${originalExpr} (cleaned: ${sanitizedExpr})`);
                        }
                        return Math.floor(new Function(`return ${sanitizedExpr}`)());
                    } catch (e) {
                        if (this.currentPass < 3) return 0;
                        throw new Error(`Invalid expression: ${originalExpr} (sanitized: ${expr})`);
                    }
                } catch (error) {
                    // Add context about current instruction if available
                    if (this.currentInstruction) {
                        const instStr = this.currentInstruction.mnemonic || this.currentInstruction.name || 'unknown';
                        throw new Error(`${error.message} in instruction '${instStr}' at line ${this.currentLine}`);
                    }
                    throw error;
                }
            }

            // Pro version: Track relocation for a symbol reference
            trackRelocation(symbolName, location, isWord = true) {
                if (this.outputMode !== 'rel') return; // Only track in .REL mode

                // Determine address type based on symbol
                let addressType;
                if (this.externalSymbols.has(symbolName)) {
                    // External symbol - will be resolved at link time
                    this.externalRefs.push({
                        symbol: symbolName,
                        location: location,
                        addressType: this.getSegmentAddressType()
                    });
                    // Don't add to relocations - linker will patch this directly
                    return;
                } else if (this.symbolTable[symbolName] !== undefined) {
                    // Local symbol - needs relocation
                    addressType = this.getSegmentAddressType();
                } else {
                    // Symbol not yet defined (forward reference)
                    // Will be resolved in later pass
                    return;
                }

                this.relocations.push({
                    location: location,
                    addressType: addressType,
                    segment: this.currentSegment,
                    isWord: isWord
                });
            }

            // Pro version: Get address type for current segment
            getSegmentAddressType() {
                switch (this.currentSegment) {
                    case 'code': return 0x01;
                    case 'data': return 0x02;
                    case 'common': return 0x03;
                    case 'absolute': return 0x00;
                    default: return 0x01; // Default to CODE
                }
            }

            // Pro version: Check if an operand contains a symbol that needs relocation
            needsRelocation(operand) {
                if (this.outputMode !== 'rel') return false;
                if (operand.type !== 'symbol') return false;

                const expr = String(operand.value);

                // Check if expression contains any symbols (not just numbers/operators)
                // Simple heuristic: if it contains letters, it likely has a symbol
                return /[a-zA-Z_]/.test(expr);
            }

            // Pro version: Generate .REL file from assembled code
            generateRelFile() {
                const writer = new BitStreamWriter();

                // Add extended format header if using extended format
                if (this.useExtendedRelFormat) {
                    // Linkstor80 extended format header: "LNKSTOR" signature
                    // This is a special 16-byte sequence that LINK-80 ignores
                    const extendedHeader = [
                        0x85, 0xD3, 0x13, 0x92, 0xD4, 0xD5, 0x13, 0xD4,
                        0xA5, 0x00, 0x00, 0x13, 0x8F, 0xFF, 0xF0, 0x9E
                    ];
                    for (const byte of extendedHeader) {
                        writer.writeBits(byte, 8);
                    }
                    log('‚ÑπÔ∏è  Generated extended format .REL file (Linkstor80-compatible)', 'info');
                }

                // Control code 2: Program Name
                this.writeSpecialItem(writer, 0x02, null, null, this.moduleName || 'MODULE');

                // Control code 0: Entry Symbol declarations (PUBLIC symbols)
                for (const symbolName of this.publicSymbols) {
                    this.writeSpecialItem(writer, 0x00, null, null, symbolName);
                }

                // Control code 11: Set Location Counter to CODE segment
                this.writeSpecialItem(writer, 0x0B, 0x01, 0x0000, null);

                // Write CODE segment bytes with relocations
                let codePos = 0;
                while (codePos < this.output.length) {
                    // Check if there's a relocation at this position
                    const relocation = this.relocations.find(r => r.location === codePos);

                    if (relocation && relocation.isWord) {
                        // Write relocatable word
                        const value = this.output[codePos] | (this.output[codePos + 1] << 8);
                        writer.writeBit(1); // Relocatable
                        writer.writeBits(relocation.addressType, 2);
                        writer.writeBits(value, 16);
                        codePos += 2;
                    } else {
                        // Write absolute byte
                        writer.writeBit(0); // Absolute
                        writer.writeBits(this.output[codePos], 8);
                        codePos++;
                    }
                }

                // Control code 13: Define Program Size
                this.writeSpecialItem(writer, 0x0D, 0x01, this.output.length, null);

                // Control code 7: Define Entry Points (PUBLIC symbol values)
                for (const symbolName of this.publicSymbols) {
                    if (this.symbolTable[symbolName] !== undefined) {
                        const value = this.symbolTable[symbolName];
                        this.writeSpecialItem(writer, 0x07, 0x01, value, symbolName);
                    }
                }

                // Control code 6: Chain External references
                for (const extRef of this.externalRefs) {
                    this.writeSpecialItem(writer, 0x06, extRef.addressType, extRef.location, extRef.symbol);
                }

                // Control code 14: End Program
                writer.writeBit(1);
                writer.writeBits(0x00, 2); // Special item
                writer.writeBits(0x0E, 4); // Control code 14

                // Control code 15: End File
                writer.writeBit(1);
                writer.writeBits(0x00, 2); // Special item
                writer.writeBits(0x0F, 4); // Control code 15

                return writer.getBytes();
            }

            // Pro version: Write a special LINK item to .REL file
            writeSpecialItem(writer, controlCode, addressType, value, symbolName) {
                writer.writeBit(1); // Relocatable item
                writer.writeBits(0x00, 2); // Special LINK item
                writer.writeBits(controlCode, 4);

                if (addressType !== null && addressType !== undefined) {
                    writer.writeBits(addressType, 2);
                }

                if (value !== null && value !== undefined) {
                    writer.writeBits(value, 16);
                }

                if (symbolName !== null && symbolName !== undefined) {
                    this.writeSymbolName(writer, symbolName);
                }
            }

            // Write symbol name in either standard (6-char max) or extended format
            writeSymbolName(writer, symbolName) {
                const useExtended = this.useExtendedRelFormat || false;

                if (!useExtended) {
                    // Standard LINK-80 format: Max 6 characters, 3-bit length
                    if (symbolName.length > 6) {
                        const truncated = symbolName.substring(0, 6);
                        log(`‚ö†Ô∏è  Warning: Symbol "${symbolName}" truncated to "${truncated}" (LINK-80 format)`, 'warn');
                        symbolName = truncated;
                    }
                    const len = symbolName.length;
                    writer.writeBits(len, 3);
                    for (let i = 0; i < len; i++) {
                        writer.writeBits(symbolName.charCodeAt(i), 8);
                    }
                } else {
                    // Extended format (Linkstor80-compatible)
                    const len = symbolName.length;

                    if (len <= 7) {
                        // Use standard 3-bit length for short symbols (0-7 chars)
                        writer.writeBits(len, 3);
                        for (let i = 0; i < len; i++) {
                            writer.writeBits(symbolName.charCodeAt(i), 8);
                        }
                    } else {
                        // Use extended format: 3-bit marker (111) + FFh + length bytes + symbol
                        writer.writeBits(0x07, 3); // 111 = signals extended format follows
                        writer.writeBits(0xFF, 8); // Escape marker

                        // Write length in minimal bytes (little-endian)
                        if (len <= 255) {
                            writer.writeBits(len, 8);
                        } else if (len <= 65535) {
                            writer.writeBits(len & 0xFF, 8);
                            writer.writeBits((len >> 8) & 0xFF, 8);
                        } else {
                            // Limit to 65535 characters
                            writer.writeBits(0xFF, 8);
                            writer.writeBits(0xFF, 8);
                        }

                        // Write symbol characters
                        const maxLen = Math.min(len, 65535);
                        for (let i = 0; i < maxLen; i++) {
                            writer.writeBits(symbolName.charCodeAt(i), 8);
                        }

                        log(`‚ÑπÔ∏è  Extended symbol: "${symbolName}" (${len} chars)`, 'info');
                    }
                }
            }
        }

        // --- Event Listeners ---
        compileBtn.addEventListener('click', async () => {
            consoleOutput.innerHTML = '';
            symbolsOutput.innerHTML = '';
            log('Starting enhanced compilation...');
            downloadBtn.classList.add('hidden');
            exportSymbolsBtn.classList.add('hidden');
            compiledBinary = null;
            assemblerInstance = null;
            updateAdaptiveMenu(); // Clear test buttons from adaptive menu

            let mainFile = currentFile;
            if (!mainFile) {
                const content = editor.getValue();
                if (!content.trim()) {
                    log('Editor is empty. Nothing to compile.', 'warn');
                    return;
                }

                // Generate unique untitled filename
                let untitledCount = 1;
                mainFile = 'untitled.asm';
                while (projectFiles[mainFile]) {
                    mainFile = `untitled${untitledCount}.asm`;
                    untitledCount++;
                }

                projectFiles[mainFile] = new TextEncoder().encode(content);
                currentFile = mainFile; // Set as current file so it appears selected
                document.getElementById('current-file-name').textContent = mainFile; // Update file header
                updateManifest(); // Update manifest with new file
                renderFileTree(); // Update file tree to show new file
            }

            // BBC Micro/Amstrad syntax detection and auto-conversion
            const mainFileContent = new TextDecoder().decode(projectFiles[mainFile]);
            const bbcMicroPattern = /^\s*\.?org\s+&[0-9a-f]+/im;

            if (bbcMicroPattern.test(mainFileContent)) {
                const hexCount = (mainFileContent.match(/&[0-9a-f]+/gi) || []).length;
                const userConfirm = confirm(
                    `‚ö†Ô∏è BBC Micro/Amstrad CPC syntax detected!\n\n` +
                    `Found ${hexCount} hex value(s) using & prefix (e.g., &8000).\n\n` +
                    `This assembler uses standard Z80 syntax with $ for hex (e.g., $8000).\n\n` +
                    `Would you like to auto-convert all & hex values to $ now?\n\n` +
                    `Before: ORG &8000, LD A,&FF\n` +
                    `After:  ORG $8000, LD A,$FF`
                );

                if (userConfirm) {
                    // Convert & hex prefix to $
                    const convertedContent = mainFileContent.replace(/&([0-9a-f]+)/gi, '$$$1');
                    projectFiles[mainFile] = new TextEncoder().encode(convertedContent);

                    // Update editor if this is the current file
                    if (currentFile === mainFile) {
                        editor.setValue(convertedContent);
                    }

                    log(`‚úì Converted ${hexCount} hex value(s) from & to $ prefix`, 'success');
                    log('Your code has been updated. Continuing compilation...', 'info');
                } else {
                    log('Compilation cancelled. Please manually convert & to $ for hex values.', 'warn');
                    return;
                }
            }

            const assembler = new Assembler(projectFiles);

            // Pro version: Set output mode from dropdown
            const outputMode = document.getElementById('output-mode').value;

            // Map extended format to 'rel' for assembler, but track extended flag
            const isExtendedFormat = (outputMode === 'rel-extended');
            assembler.outputMode = (outputMode === 'rel' || outputMode === 'rel-extended') ? 'rel' : outputMode;
            assembler.useExtendedRelFormat = isExtendedFormat;

            // Extract module name from filename
            const moduleName = mainFile.replace(/\.(asm|z80|s)$/i, '').replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
            assembler.moduleName = moduleName;

            // Set output filename based on source file and mode
            // Auto-organize: compiled outputs go to build/ folder
            const sourceBaseName = extractFilename(mainFile).replace(/\.(asm|z80|s)$/i, '');
            if (outputMode === 'rel' || outputMode === 'rel-extended') {
                outputFilename = `build/${sourceBaseName}.rel`;
            } else {
                outputFilename = `build/${sourceBaseName}.bin`;
            }

            const binary = await assembler.assemble(mainFile);

            if (binary) {
                assemblerInstance = assembler;
                compiledBinary = binary;

                // Update download button text based on output mode
                if (outputMode === 'rel' || outputMode === 'rel-extended') {
                    downloadBtn.textContent = outputMode === 'rel-extended'
                        ? 'Download .REL (Extended)'
                        : 'Download .REL (LINK-80)';

                    // Auto-add .REL file to project for easier workflow
                    // Create a proper deep copy to avoid any reference or mutation issues
                    projectFiles[outputFilename] = binary.slice(0);
                    const formatType = outputMode === 'rel-extended' ? 'Extended format' : 'LINK-80 format';
                    log(`Added ${outputFilename} to project files (${formatType})`, 'success');
                    console.log(`[DEBUG] Saved .REL to project: ${outputFilename}, size: ${binary.length} bytes`);

                    // Verify the file was added correctly by trying to read it back
                    if (projectFiles[outputFilename]) {
                        console.log(`[DEBUG] Verification: File ${outputFilename} exists in project, size: ${projectFiles[outputFilename].length}`);

                        // Verify the data is intact by checking first few bytes
                        const first10 = Array.from(projectFiles[outputFilename].slice(0, 10));
                        console.log(`[DEBUG] First 10 bytes:`, first10);
                    } else {
                        console.error(`[DEBUG] ERROR: File ${outputFilename} was not added to project!`);
                    }

                    renderFileTree();
                    updateLinkButtonVisibility();
                } else {
                    downloadBtn.textContent = 'Download Binary';
                }

                downloadBtn.classList.remove('hidden');
                exportSymbolsBtn.classList.remove('hidden');

                // Generate .LST file
                const lstContent = assembler.generateListingFile();
                const lstFilename = `${sourceBaseName}.lst`;
                projectFiles[lstFilename] = new TextEncoder().encode(lstContent);
                log(`Generated listing file: ${lstFilename}`, 'success');

                // Refresh file tree to show the new .LST file
                renderFileTree();

                // Show clean button when temporary files exist
                cleanProjectBtn.classList.remove('hidden');

                switchTab('symbols'); // Automatically switch to symbols tab to show results
                updateAdaptiveMenu(); // Update adaptive menu with new available actions
            }
        });

        // Function to download any file from the project
        function downloadProjectFile(filename) {
            const fileData = projectFiles[filename];
            if (!fileData) {
                log(`File not found: ${filename}`, 'error');
                return;
            }

            const blob = new Blob([fileData], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            log(`Downloaded: ${filename}`, 'success');
        }

        // Function to delete a file from the project
        // Rename file via icon button (simpler version without folder support)
        function renameFileIcon(oldFilename) {
            if (!projectFiles[oldFilename]) {
                log(`File not found: ${oldFilename}`, 'error');
                return;
            }

            const currentFolder = extractFolder(oldFilename);
            const currentName = extractFilename(oldFilename);
            const newName = prompt('Enter new filename:', currentName);

            if (newName && newName !== currentName) {
                const newPath = currentFolder ? `${currentFolder}/${newName}` : newName;

                // Check if new filename already exists
                if (projectFiles[newPath]) {
                    log(`File ${newPath} already exists!`, 'error');
                    return;
                }

                projectFiles[newPath] = projectFiles[oldFilename];
                delete projectFiles[oldFilename];

                if (projectManifest.mainFile === oldFilename) {
                    projectManifest.mainFile = newPath;
                }
                if (currentFile === oldFilename) {
                    currentFile = newPath;
                }

                updateManifest();
                renderFileTree();
                log(`Renamed to ${newName}`, 'success');
            }
        }

        function deleteProjectFile(filename) {
            if (!projectFiles[filename]) {
                log(`File not found: ${filename}`, 'error');
                return;
            }

            if (confirm(`Delete ${filename} from project?`)) {
                delete projectFiles[filename];
                log(`Deleted: ${filename}`, 'info');

                // If the deleted file was the current file, close the editor
                if (currentFile === filename) {
                    currentFile = null;
                    editor.setValue('');
                }

                renderFileTree();
                updateLinkButtonVisibility();
            }
        }

        // Download entire project as ZIP with manifest
        async function downloadProject() {
            if (Object.keys(projectFiles).length === 0) {
                log('No files to download', 'warn');
                return;
            }

            // Update manifest before download
            updateManifest();

            // Create ZIP
            const zip = new JSZip();

            // Add project.json manifest
            const manifestJson = JSON.stringify(projectManifest, null, 2);
            zip.file('project.json', manifestJson);
            log('Added project.json manifest', 'info');

            // Add all project files preserving folder structure
            for (const [filepath, content] of Object.entries(projectFiles)) {
                if (filepath !== 'project.json') {  // Don't duplicate manifest
                    zip.file(filepath, content);
                }
            }

            // Generate ZIP
            const zipBlob = await zip.generateAsync({ type: 'blob' });

            // Download
            const projectName = projectManifest.name || 'untitled-project';
            const filename = `${projectName}.zip`;
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            log(`üì¶ Downloaded project: ${filename}`, 'success');
            log(`  Files: ${Object.keys(projectFiles).length}`, 'info');
            log(`  Main file: ${projectManifest.mainFile || 'not set'}`, 'info');
        }

        // Download project button handler (header icon)
        document.getElementById('download-project-btn').addEventListener('click', downloadProject);

        // New File button handler
        document.getElementById('new-file-btn').addEventListener('click', () => {
            // Generate unique untitled filename
            let untitledCount = 1;
            let newFileName = 'untitled.asm';
            while (projectFiles[newFileName]) {
                newFileName = `untitled${untitledCount}.asm`;
                untitledCount++;
            }

            // Create empty file
            projectFiles[newFileName] = new TextEncoder().encode('');

            // Switch to new file in editor
            currentFile = newFileName;
            editor.setValue('');
            editor.focus();

            // Update file header display
            document.getElementById('current-file-name').textContent = newFileName;

            // Update file tree and manifest
            updateManifest();
            renderFileTree();

            log(`Created new file: ${newFileName}`, 'success');
        });

        // Close file button handler
        document.getElementById('close-file-btn').addEventListener('click', () => {
            // Generate unique untitled filename
            let untitledCount = 1;
            let newFileName = 'untitled.asm';
            while (projectFiles[newFileName]) {
                newFileName = `untitled${untitledCount}.asm`;
                untitledCount++;
            }

            // Create empty file
            projectFiles[newFileName] = new TextEncoder().encode('');

            // Switch to new file in editor
            currentFile = newFileName;
            editor.setValue('');
            editor.focus();

            // Update file header display
            document.getElementById('current-file-name').textContent = newFileName;

            // Update file tree and manifest
            updateManifest();
            renderFileTree();

            log(`Created new file: ${newFileName}`, 'success');
        });

        downloadBtn.addEventListener('click', () => {
            if (!compiledBinary) return;

            // Pro version: Determine filename based on output mode
            const outputMode = document.getElementById('output-mode').value;
            let filename = outputFilename;

            if (outputMode === 'rel') {
                // Replace extension with .rel
                filename = outputFilename.replace(/\.[^/.]+$/, '') + '.rel';
            }

            const blob = new Blob([compiledBinary], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            log(`Downloaded ${filename}.`);
        });

        exportSymbolsBtn.addEventListener('click', () => {
            if (!assemblerInstance) return;
            const symbolData = assemblerInstance.exportSymbolTable();
            const blob = new Blob([symbolData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = outputFilename.replace(/\.[^/.]+$/, '') + '_symbols.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            log(`Exported symbol table to ${outputFilename.replace(/\.[^/.]+$/, '') + '_symbols.json'}.`);
        });

        // Clean Project button - removes temporary files (.lst)
        cleanProjectBtn.addEventListener('click', () => {
            // Define temporary file extensions to remove
            const tempExtensions = ['.lst'];
            let removedCount = 0;

            // Find and remove temporary files
            const filesToRemove = [];
            for (const filename in projectFiles) {
                const lowerFilename = filename.toLowerCase();
                if (tempExtensions.some(ext => lowerFilename.endsWith(ext))) {
                    filesToRemove.push(filename);
                }
            }

            if (filesToRemove.length === 0) {
                log('No temporary files to clean.', 'info');
                return;
            }

            // Confirm deletion
            if (confirm(`Remove ${filesToRemove.length} temporary file(s)?\n\n${filesToRemove.join('\n')}`)) {
                filesToRemove.forEach(filename => {
                    delete projectFiles[filename];
                    removedCount++;
                });

                // Refresh the file tree display
                renderFileTree();

                // If current file was removed, clear the editor
                if (filesToRemove.includes(currentFile)) {
                    currentFile = null;
                    editor.setValue('');
                }

                // Hide clean button after cleaning
                cleanProjectBtn.classList.add('hidden');

                log(`Removed ${removedCount} temporary file(s).`, 'success');
            }
        });

        // Pro version: Link Modules button
        const linkBtn = document.getElementById('link-btn');
        linkBtn.addEventListener('click', async () => {
            consoleOutput.innerHTML = '';
            log('Starting module linking...', 'info');

            try {
                // Find all .REL files in project
                const relFiles = Object.keys(projectFiles).filter(f => f.toLowerCase().endsWith('.rel'));

                if (relFiles.length === 0) {
                    log('No .REL files found to link', 'warn');
                    return;
                }

                // Sort .REL files to ensure main/header modules come first
                // Priority order: files with 'main', 'header', 'crtcv', '00' prefix, then alphabetical
                relFiles.sort((a, b) => {
                    const aLower = a.toLowerCase();
                    const bLower = b.toLowerCase();

                    const aIsMain = aLower.includes('main') || aLower.includes('header') ||
                                   aLower.includes('crtcv') || aLower.startsWith('00') ||
                                   aLower.startsWith('cv_');
                    const bIsMain = bLower.includes('main') || bLower.includes('header') ||
                                   bLower.includes('crtcv') || bLower.startsWith('00') ||
                                   bLower.startsWith('cv_');

                    if (aIsMain && !bIsMain) return -1;
                    if (!aIsMain && bIsMain) return 1;
                    return a.localeCompare(b);
                });

                log(`Found ${relFiles.length} .REL file(s) to link`, 'info');

                // Parse all .REL files and .LIB files (libraries)
                const linker = new SmartLinker({ codeBase: 0x8000, dataBase: 0x7000 });

                // First, load .LIB files (libraries) - these are used selectively
                const libFiles = Object.keys(projectFiles).filter(f => f.toLowerCase().endsWith('.lib'));
                for (const libFile of libFiles) {
                    try {
                        log(`Loading library: ${libFile}`, 'info');
                        const zip = await JSZip.loadAsync(projectFiles[libFile]);
                        const libraryModules = [];

                        for (const [filename, file] of Object.entries(zip.files)) {
                            if (!file.dir && filename.toLowerCase().endsWith('.rel')) {
                                const relData = await file.async('uint8array');
                                const parser = new RelFileParser(relData);
                                const module = parser.parse();
                                libraryModules.push(module);
                            }
                        }

                        linker.addLibrary(libFile, libraryModules);
                    } catch (e) {
                        log(`Warning: Failed to load library ${libFile}: ${e.message}`, 'warn');
                    }
                }

                // Then, load explicit .REL files - these are always included
                for (const relFile of relFiles) {
                    const relData = projectFiles[relFile];
                    console.log(`[DEBUG] Loading ${relFile}, type: ${relData.constructor.name}, length: ${relData.length}`);
                    console.log(`[DEBUG] First 20 bytes:`, Array.from(relData.slice(0, 20)));

                    // Create a copy to avoid parser modifying the original data
                    const parser = new RelFileParser(relData.slice(0));
                    const module = parser.parse();
                    linker.addModule(module);
                    log(`  Loaded: ${relFile} (${module.name})`, 'info');
                }

                // Link all modules (SmartLinker will pull in library modules as needed)
                const linkedBinary = linker.link();

                // Store linked binary
                compiledBinary = linkedBinary;
                assemblerInstance = null; // Clear assembler instance

                // Set output filename for linked binary
                outputFilename = 'linked.bin';

                // Enable download
                downloadBtn.textContent = 'Download Linked Binary';
                downloadBtn.classList.remove('hidden');
                updateAdaptiveMenu(); // Update adaptive menu with test buttons

                log('Linking complete! Binary ready for download.', 'success');
            } catch (e) {
                log(`Linking failed: ${e.message}`, 'error');
                console.error(e);
            }
        });

        // Pro version: Build Library (ASM‚ÜíLIB) button - One-click compilation and packaging
        const buildLibBtn = document.getElementById('build-lib-btn');
        buildLibBtn.addEventListener('click', async () => {
            try {
                consoleOutput.innerHTML = '';
                log('Building library from .asm files...', 'info');

                // Get all .asm files
                const asmFiles = Object.keys(projectFiles).filter(f =>
                    /\.(asm|z80|s)$/i.test(f) && !f.toLowerCase().includes('main') &&
                    !f.toLowerCase().includes('header') && !f.toLowerCase().includes('cv_')
                );

                if (asmFiles.length === 0) {
                    log('No library .asm files found (excluding main/header files)', 'error');
                    log('Tip: Library modules should not contain "main", "header", or "cv_" in their names', 'info');
                    return;
                }

                log(`Found ${asmFiles.length} module(s) to compile`, 'info');

                // Temporarily store compiled .REL files
                const compiledModules = {};
                let successCount = 0;
                let failCount = 0;

                // Get current output mode to determine REL format
                const outputMode = document.getElementById('output-mode').value;
                const isExtendedFormat = (outputMode === 'rel-extended');

                // Show which format is being used
                const formatName = isExtendedFormat ? 'Extended (Linkstor80)' : 'Standard (LINK-80)';
                log(`Using ${formatName} format for library modules`, 'info');

                // Compile each .asm file to .REL
                for (const asmFile of asmFiles) {
                    try {
                        log(`  Compiling: ${asmFile}`, 'info');

                        const assembler = new Assembler(projectFiles);

                        // Set output mode to .REL
                        assembler.outputMode = 'rel';
                        assembler.useExtendedRelFormat = isExtendedFormat;

                        // Set module name from filename
                        const moduleName = asmFile.replace(/\.(asm|z80|s)$/i, '').replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
                        assembler.moduleName = moduleName;

                        const binary = assembler.assemble(asmFile);
                        const relFilename = asmFile.replace(/\.(asm|z80|s)$/i, '.rel');
                        compiledModules[relFilename] = binary;

                        successCount++;
                        log(`    ‚úì ${asmFile} ‚Üí ${relFilename}`, 'success');

                    } catch (e) {
                        failCount++;
                        log(`    ‚úó ${asmFile}: ${e.message}`, 'error');
                    }
                }

                if (successCount === 0) {
                    log('No modules compiled successfully', 'error');
                    return;
                }

                log(`Compilation complete: ${successCount} succeeded, ${failCount} failed`, 'info');

                // Create .LIB file from compiled .REL modules
                log('Packaging modules into library...', 'info');
                const zip = new JSZip();

                for (const [relFile, relData] of Object.entries(compiledModules)) {
                    zip.file(relFile, relData);
                    log(`  Added: ${relFile}`, 'info');
                }

                // Generate the .LIB file
                const libData = await zip.generateAsync({type: 'uint8array'});

                // Prompt for library name
                const libName = prompt('Enter library name (without extension):', 'mylib');
                if (!libName) return;

                // Auto-organize: save library to lib/ folder
                const libFilename = `lib/${libName}.lib`;

                // Add the library to the project files automatically
                projectFiles[libFilename] = libData;
                const formatInfo = isExtendedFormat ? ' (Extended format - unlimited symbols)' : ' (LINK-80 format - 6-char symbols)';

                // Update file tree
                renderFileTree();
                updateLinkButtonVisibility();

                // Also offer to download it for external use
                const shouldDownload = confirm(
                    `‚úÖ Library saved to ${libFilename}!\n\n` +
                    `Download a copy for use in other projects?`
                );
                if (shouldDownload) {
                    const blob = new Blob([libData], {type: 'application/zip'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${libName}.lib`;  // Download without path
                    a.click();
                    URL.revokeObjectURL(url);
                }

                log(`‚úÖ Library built: ${libFilename} (${successCount} modules)${formatInfo}`, 'success');
                log('Library is now available in your project - ready to link!', 'info');

            } catch (e) {
                log(`Library build failed: ${e.message}`, 'error');
                console.error(e);
            }
        });

        // Pro version: Create Library (.LIB) button - From existing .REL files
        const createLibBtn = document.getElementById('create-lib-btn');
        createLibBtn.addEventListener('click', async () => {
            try {
                consoleOutput.innerHTML = '';
                log('Creating library from .REL files...', 'info');

                // Get all .REL files
                const relFiles = Object.keys(projectFiles).filter(f => f.toLowerCase().endsWith('.rel'));

                if (relFiles.length === 0) {
                    log('No .REL files found to package into library', 'error');
                    return;
                }

                log(`Packaging ${relFiles.length} module(s) into library`, 'info');

                // Create a ZIP file containing all .REL files
                const zip = new JSZip();

                for (const relFile of relFiles) {
                    zip.file(relFile, projectFiles[relFile]);
                    log(`  Added: ${relFile}`, 'info');
                }

                // Generate the .LIB file (as ZIP)
                const libData = await zip.generateAsync({type: 'uint8array'});

                // Prompt for library name
                const libName = prompt('Enter library name (without extension):', 'mylib');
                if (!libName) return;

                // Auto-organize: save library to lib/ folder
                const libFilename = `lib/${libName}.lib`;

                // Add the library to the project files automatically
                projectFiles[libFilename] = libData;
                log(`Added ${libFilename} to project files`, 'success');

                // Update file tree
                renderFileTree();
                updateLinkButtonVisibility();

                // Also offer to download it
                const shouldDownload = confirm(
                    `‚úÖ Library saved to ${libFilename}!\n\n` +
                    `Download a copy for use in other projects?`
                );
                if (shouldDownload) {
                    const blob = new Blob([libData], {type: 'application/zip'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${libName}.lib`;  // Download without path
                    a.click();
                    URL.revokeObjectURL(url);
                }

                log(`Library created: ${libFilename}`, 'success');
                log('Library is now available in your project - ready to link!', 'info');

            } catch (e) {
                log(`Library creation failed: ${e.message}`, 'error');
                console.error(e);
            }
        });

        // Pro version: Update Link and Create Library button visibility based on loaded files
        // Adaptive menu system - intelligently shows/hides actions
        function updateAdaptiveMenu() {
            const hasRelFiles = Object.keys(projectFiles).some(f => f.toLowerCase().endsWith('.rel'));
            const hasAsmFiles = Object.keys(projectFiles).some(f => /\.(asm|z80|s)$/i.test(f));
            const hasLibraryAsmFiles = Object.keys(projectFiles).some(f =>
                /\.(asm|z80|s)$/i.test(f) && !f.toLowerCase().includes('main') &&
                !f.toLowerCase().includes('header') && !f.toLowerCase().includes('cv_')
            );
            const outputMode = document.getElementById('output-mode').value;
            const hasBinary = compiledBinary !== null;

            // Define all possible actions with their availability
            const actions = [
                {
                    id: 'link',
                    label: 'Link Modules',
                    available: hasRelFiles && outputMode === 'binary',
                    color: 'purple',
                    handler: () => document.getElementById('link-btn').click()
                },
                {
                    id: 'build-lib',
                    label: 'Build Library (ASM‚ÜíLIB)',
                    available: hasLibraryAsmFiles,
                    color: 'orange',
                    handler: () => document.getElementById('build-lib-btn').click()
                },
                {
                    id: 'create-lib',
                    label: 'Create Library from REL',
                    available: hasRelFiles,
                    color: 'orange',
                    handler: () => document.getElementById('create-lib-btn').click()
                },
                {
                    id: 'export-symbols',
                    label: 'Export Symbols',
                    available: hasRelFiles,
                    color: 'blue',
                    handler: () => document.getElementById('export-symbols-btn').click()
                },
                {
                    id: 'test-cv',
                    label: 'Test CV Screen',
                    available: hasBinary,
                    color: 'purple',
                    handler: () => document.getElementById('test-cv-screen').click()
                },
                {
                    id: 'test-dina',
                    label: 'Test DINA Screen',
                    available: hasBinary,
                    color: 'green',
                    handler: () => document.getElementById('test-dina-screen').click()
                },
                {
                    id: 'download-project',
                    label: 'Download Project',
                    available: Object.keys(projectFiles).length > 0,
                    color: 'blue',
                    handler: downloadProject
                }
            ];

            // Filter to only available actions
            const availableActions = actions.filter(a => a.available);

            const adaptiveContainer = document.getElementById('adaptive-actions');
            const moreDropdown = document.getElementById('more-dropdown');
            const moreContent = document.getElementById('more-content');

            // Clear current state
            adaptiveContainer.innerHTML = '';
            moreContent.innerHTML = '';

            if (availableActions.length === 0) {
                // No actions available - hide everything
                moreDropdown.classList.add('hidden');
            } else if (availableActions.length === 1) {
                // 1 action - show directly as button
                moreDropdown.classList.add('hidden');
                const action = availableActions[0];
                const btn = createActionButton(action);
                adaptiveContainer.appendChild(btn);
            } else if (availableActions.length === 2) {
                // 2 actions - show both as buttons
                moreDropdown.classList.add('hidden');
                availableActions.forEach(action => {
                    const btn = createActionButton(action);
                    adaptiveContainer.appendChild(btn);
                });
            } else {
                // 3+ actions - show first 2 as buttons, rest in dropdown
                availableActions.slice(0, 2).forEach(action => {
                    const btn = createActionButton(action);
                    adaptiveContainer.appendChild(btn);
                });

                // Add remaining to dropdown
                availableActions.slice(2).forEach(action => {
                    const item = document.createElement('div');
                    item.className = 'dropdown-item';
                    item.textContent = action.label;
                    item.onclick = action.handler;
                    moreContent.appendChild(item);
                });

                moreDropdown.classList.remove('hidden');
            }
        }

        // Helper function to create action button
        function createActionButton(action) {
            const btn = document.createElement('button');
            const colorMap = {
                'purple': 'bg-purple-600 hover:bg-purple-700',
                'orange': 'bg-orange-600 hover:bg-orange-700',
                'blue': 'bg-blue-600 hover:bg-blue-700',
                'green': 'bg-green-600 hover:bg-green-700'
            };
            btn.className = `${colorMap[action.color]} text-white font-bold py-2 px-4 rounded-lg transition-colors`;
            btn.textContent = action.label;
            btn.onclick = action.handler;
            return btn;
        }

        // Legacy function name for compatibility
        function updateLinkButtonVisibility() {
            updateAdaptiveMenu();
        }

        // Update link button visibility when output mode changes
        document.getElementById('output-mode').addEventListener('change', () => {
            updateLinkButtonVisibility();
        });

        // Platform selection handler
        const targetPlatformSelect = document.getElementById('target-platform');
        targetPlatformSelect.addEventListener('change', () => {
            const config = getPlatformConfig();
            if (config.description) {
                log(`Target platform changed to: ${config.description}`, 'info');
            }
        });

        // COLECOVISION RENDERING
        document.getElementById('test-cv-screen').addEventListener('click', () => {
            if (compiledBinary) {
                const gameInfo = parseGameTitle(compiledBinary);
                emulateColecoBootScreen(gameInfo);
                log('Manual ColecoVision title screen test triggered', 'info');
            }
        });

        document.getElementById('test-dina-screen').addEventListener('click', () => {
            if (compiledBinary) {
                const gameInfo = parseGameTitle(compiledBinary);
                emulateDinaBoot(gameInfo);
            }
            log('Manual DINA 2-in-1 title screen test triggered', 'info');
        });        

        // Initial state
        updateCompileButtonState();
        log('AmysCVAssemblerPro ready (zmac-compatible, multi-syntax Z80 with .REL support).', 'success');
        log('Target: ColecoVision ROM (also compatible with DINA 2-in-1)', 'info');
        log('Syntax: zmac, TASM, MACRO-80, MRAS, Intel, Motorola styles supported', 'info');
        log('Features: Binary output OR relocatable object files (.REL) with linker', 'info');
        log('Supported files: .asm, .z80, .s, .rel (also .zip, .gz archives)', 'info');

        /*
         * ============================================================================
         * ZMAC COMPATIBILITY TEST EXAMPLES
         * ============================================================================
         *
         * Example 1: Basic Z80 Assembly with Labels and Jumps
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   START:
         *       ld a, $FF          ; Load immediate hex
         *       ld hl, BUFFER      ; Load address of buffer
         *       call CLEAR         ; Call subroutine
         *       jp START           ; Infinite loop
         *
         *   CLEAR:
         *       xor a              ; A = 0
         *       ld (hl), a         ; Clear byte
         *       ret
         *
         *   BUFFER: ds 256         ; Reserve 256 bytes
         *
         * Example 2: Using zmac Directives (DEFM, DEFB, DEFW)
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   HEADER:
         *       defb $AA, $55               ; Header bytes
         *       defm "GAME TITLE", 0        ; String with null terminator
         *       defw START                  ; 16-bit address
         *
         *   START:
         *       ld hl, MESSAGE
         *       call PRINT
         *       ret
         *
         *   MESSAGE:
         *       ascii "HELLO WORLD!"        ; ASCII string (synonym for DB)
         *       db 13, 10, 0                ; CR, LF, null
         *
         * Example 3: Macros and Conditionals
         * ----------------------------------------------------------------------------
         *   DEBUG equ 1
         *
         *   ; Macro definition
         *   DELAY macro count
         *       ld b, count
         *   .loop:
         *       djnz .loop
         *   endm
         *
         *   org $8000
         *
         *   START:
         *       DELAY 100                   ; Expand macro with parameter
         *
         *       if DEBUG
         *           ld a, $FF               ; Debug code
         *       else
         *           xor a                   ; Release code
         *       endif
         *
         *       ret
         *
         * Example 4: IX/IY Indexed Addressing
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   OFFSET equ 5
         *
         *   START:
         *       ld ix, BUFFER
         *       ld a, (ix+0)               ; Read from IX+0
         *       ld (ix+OFFSET), a          ; Write to IX+OFFSET
         *       ld b, (iy-10)              ; Read from IY-10
         *       ret
         *
         *   BUFFER: ds 256
         *
         * Example 5: Number Formats (All Supported)
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   HEX_STYLES:
         *       db $FF                      ; Dollar prefix
         *       db 0xFF                     ; 0x prefix
         *       db 0FFh                     ; Suffix h
         *
         *   BINARY_STYLES:
         *       db %11111111                ; Percent prefix
         *       db 0b11111111               ; 0b prefix
         *       db 11111111b                ; Suffix b
         *
         *   OCTAL_STYLES:
         *       db @377                     ; At sign prefix
         *       db 0377                     ; Leading zero
         *       db 377o                     ; Suffix o
         *
         *   DECIMAL:
         *       db 255                      ; Plain decimal
         *       db 255d                     ; Suffix d (optional)
         *
         * Example 6: ColecoVision ROM Header
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   ; ColecoVision header
         *   db $AA, $55                     ; Cart header (bypasses title screen)
         *   ; or: db $55, $AA               ; (shows default CV title screen)
         *
         *   dw 0, 0, 0, 0, 0, 0, 0          ; Reserved
         *   dw START                        ; Start address
         *   dw 0, 0, 0, 0, 0                ; RST handlers
         *
         *   ; Game title at $8024 (format: "LINE3/LINE2/YEAR")
         *   org $8024
         *   defm "MY GAME/BY ME/2024", 0
         *
         *   org $8100
         *   START:
         *       di                          ; Disable interrupts
         *       ld sp, $7400                ; Set stack
         *       jp MAIN
         *
         *   MAIN:
         *       ; Your game code here
         *       jp MAIN
         *
         * Example 7: Relative Jumps and DJNZ
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   START:
         *       ld b, 10
         *   LOOP:
         *       nop
         *       djnz LOOP                   ; Decrement B and jump if not zero
         *
         *       ld a, 5
         *       cp 10
         *       jr z, EQUAL                 ; Jump if zero (relative)
         *       jr nc, GREATER              ; Jump if no carry
         *       jr LESS
         *
         *   EQUAL:
         *       xor a
         *       ret
         *
         *   GREATER:
         *       ld a, 1
         *       ret
         *
         *   LESS:
         *       ld a, $FF
         *       ret
         *
         * Example 8: BIT/RES/SET Instructions
         * ----------------------------------------------------------------------------
         *   org $8000
         *
         *   START:
         *       ld a, %10101010
         *
         *       bit 0, a                    ; Test bit 0
         *       jr z, BIT_CLEAR
         *
         *       set 1, a                    ; Set bit 1
         *       res 7, a                    ; Reset bit 7
         *
         *       ret
         *
         *   BIT_CLEAR:
         *       set 0, a
         *       ret
         *
         * ============================================================================
         */

    </script>

    <!-- Context Menu for File Operations -->
    <div id="file-context-menu" class="hidden fixed bg-gray-800 border border-gray-600 rounded-lg shadow-2xl z-50" style="min-width: 200px;">
        <div class="py-1">
            <div id="ctx-set-main" class="px-4 py-2 text-sm text-gray-200 hover:bg-blue-600 cursor-pointer flex items-center gap-2">
                <span>‚≠ê</span>
                <span>Set as Main File</span>
            </div>
            <div id="ctx-move-to-folder" class="px-4 py-2 text-sm text-gray-200 hover:bg-blue-600 cursor-pointer flex items-center gap-2">
                <span>üìÅ</span>
                <span>Move to Folder...</span>
            </div>
            <div id="ctx-rename" class="px-4 py-2 text-sm text-gray-200 hover:bg-blue-600 cursor-pointer flex items-center gap-2">
                <span>‚úèÔ∏è</span>
                <span>Rename...</span>
            </div>
            <div class="border-t border-gray-600 my-1"></div>
            <div id="ctx-download" class="px-4 py-2 text-sm text-gray-200 hover:bg-blue-600 cursor-pointer flex items-center gap-2">
                <span>üíæ</span>
                <span>Download</span>
            </div>
            <div id="ctx-delete" class="px-4 py-2 text-sm text-red-400 hover:bg-red-600 hover:text-white cursor-pointer flex items-center gap-2">
                <span>üóëÔ∏è</span>
                <span>Delete</span>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
            <!-- Modal Header -->
            <div class="bg-gray-900 p-4 flex justify-between items-center border-b border-gray-700">
                <h2 class="text-2xl font-bold text-white">‚ùì Help & Documentation</h2>
                <button type="button" id="close-help" class="text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
            </div>

            <!-- Tabs -->
            <div class="bg-gray-900 px-4 border-b border-gray-700 flex gap-2">
                <button type="button" class="help-tab active px-4 py-2 text-sm font-semibold rounded-t-lg transition-colors" data-panel="help-formats">
                    üìã Formats REL
                </button>
                <button type="button" class="help-tab px-4 py-2 text-sm font-semibold rounded-t-lg transition-colors" data-panel="help-workflow">
                    üîÑ Workflow
                </button>
                <button type="button" class="help-tab px-4 py-2 text-sm font-semibold rounded-t-lg transition-colors" data-panel="help-tutorials">
                    üéì Quick Start
                </button>
                <button type="button" class="help-tab px-4 py-2 text-sm font-semibold rounded-t-lg transition-colors" data-panel="help-projects">
                    üì¶ Projects
                </button>
            </div>

            <!-- Tab Content -->
            <div class="flex-1 overflow-y-auto p-6">
                <!-- Formats Panel -->
                <div id="help-formats" class="help-panel">
                    <h3 class="text-xl font-bold text-blue-400 mb-4">üìã REL Format Guide</h3>

                    <div class="space-y-4">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-green-400 mb-2">üü¢ LINK-80 .REL (Standard)</h4>
                            <ul class="list-disc list-inside space-y-1 text-gray-300 text-sm">
                                <li>Classic Microsoft LINK-80 format</li>
                                <li>‚ö†Ô∏è Symbol names limited to 6 characters</li>
                                <li>‚úÖ Compatible with all vintage tools</li>
                                <li>‚úÖ Ideal for retro development</li>
                            </ul>
                            <div class="mt-2 text-xs text-gray-400">
                                Example: "INIT_SOUND" becomes "INIT_S"
                            </div>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-purple-400 mb-2">üü£ Extended .REL (Linkstor80)</h4>
                            <ul class="list-disc list-inside space-y-1 text-gray-300 text-sm">
                                <li>Modern Linkstor80 extended format</li>
                                <li>‚úÖ Unlimited symbol name length</li>
                                <li>‚úÖ UTF-8 support for international characters</li>
                                <li>‚úÖ Backwards compatible (auto-detected)</li>
                                <li>üìö Perfect for complex projects</li>
                            </ul>
                            <div class="mt-2 text-xs text-gray-400">
                                Example: "INIT_SOUND" stays "INIT_SOUND"
                            </div>
                        </div>

                        <div class="bg-blue-900 bg-opacity-30 p-4 rounded-lg border border-blue-700">
                            <h4 class="text-sm font-semibold text-blue-300 mb-2">üí° How to Choose?</h4>
                            <p class="text-xs text-gray-300">
                                Use <strong>LINK-80</strong> for maximum compatibility with vintage tools.<br>
                                Use <strong>Extended</strong> for modern projects with descriptive symbol names.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Workflow Panel -->
                <div id="help-workflow" class="help-panel hidden">
                    <h3 class="text-xl font-bold text-blue-400 mb-4">üîÑ Library Build Workflow</h3>

                    <div class="space-y-6">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <div class="flex items-center gap-3 mb-3">
                                <div class="bg-blue-600 text-white w-8 h-8 rounded-full flex items-center justify-center font-bold">1</div>
                                <h4 class="text-lg font-semibold text-white">Load Library Source Files</h4>
                            </div>
                            <p class="text-sm text-gray-300 ml-11">
                                Drag and drop your <code class="bg-gray-800 px-2 py-1 rounded">.asm</code> files into the project.<br>
                                Files with "main", "header", or "cv_" are auto-excluded from libraries.
                            </p>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <div class="flex items-center gap-3 mb-3">
                                <div class="bg-green-600 text-white w-8 h-8 rounded-full flex items-center justify-center font-bold">2</div>
                                <h4 class="text-lg font-semibold text-white">Select Format & Build</h4>
                            </div>
                            <p class="text-sm text-gray-300 ml-11">
                                Choose your format from the <strong>Output</strong> dropdown.<br>
                                Click <strong class="text-orange-400">"Build Library (ASM‚ÜíLIB)"</strong> button.<br>
                                All modules are compiled and packaged automatically!
                            </p>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <div class="flex items-center gap-3 mb-3">
                                <div class="bg-purple-600 text-white w-8 h-8 rounded-full flex items-center justify-center font-bold">3</div>
                                <h4 class="text-lg font-semibold text-white">Use in Your Project</h4>
                            </div>
                            <p class="text-sm text-gray-300 ml-11">
                                Load your main program and the <code class="bg-gray-800 px-2 py-1 rounded">.lib</code> file.<br>
                                Compile main to <code class="bg-gray-800 px-2 py-1 rounded">.REL</code> (using any format).<br>
                                <strong class="text-yellow-400">Switch Output to "Binary (.bin)"</strong> for linking.<br>
                                Click <strong class="text-purple-400">"Link Modules"</strong> button.<br>
                                Only used functions are included! üéØ
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Tutorials Panel -->
                <div id="help-tutorials" class="help-panel hidden">
                    <h3 class="text-xl font-bold text-blue-400 mb-4">üéì Quick Start Tutorials</h3>

                    <div class="space-y-4">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-yellow-400 mb-2">‚ö° Simple Binary Compilation</h4>
                            <ol class="list-decimal list-inside space-y-1 text-sm text-gray-300">
                                <li>Drop your <code class="bg-gray-800 px-1 rounded">.asm</code> file</li>
                                <li>Select <strong>Binary (.bin)</strong> output</li>
                                <li>Click <strong class="text-indigo-400">Compile</strong></li>
                                <li>Click <strong class="text-green-400">Download</strong></li>
                            </ol>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-orange-400 mb-2">üìö Building a Library</h4>
                            <ol class="list-decimal list-inside space-y-1 text-sm text-gray-300">
                                <li>Drop multiple <code class="bg-gray-800 px-1 rounded">.asm</code> files (one function per file)</li>
                                <li>Select your preferred <strong>REL format</strong></li>
                                <li>Click <strong class="text-orange-400">Build Library (ASM‚ÜíLIB)</strong></li>
                                <li>Enter library name</li>
                                <li>Done! Library is ready to use</li>
                            </ol>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-purple-400 mb-2">üîó Linking with Libraries</h4>
                            <ol class="list-decimal list-inside space-y-1 text-sm text-gray-300">
                                <li>Load your main <code class="bg-gray-800 px-1 rounded">.asm</code> file</li>
                                <li>Load your <code class="bg-gray-800 px-1 rounded">.lib</code> file</li>
                                <li>Select <strong>LINK-80 .REL</strong> or <strong>Extended .REL</strong></li>
                                <li>Compile main file to <code class="bg-gray-800 px-1 rounded">.REL</code></li>
                                <li><strong class="text-yellow-400">IMPORTANT:</strong> Switch Output to <strong>Binary (.bin)</strong></li>
                                <li>Click <strong class="text-purple-400">Link Modules</strong> button</li>
                                <li>Download your optimized binary!</li>
                            </ol>
                        </div>

                        <div class="bg-green-900 bg-opacity-30 p-4 rounded-lg border border-green-700">
                            <h4 class="text-sm font-semibold text-green-300 mb-2">üí° Pro Tips</h4>
                            <ul class="list-disc list-inside space-y-1 text-xs text-gray-300">
                                <li>Use Extended format for better symbol names visibility</li>
                                <li>Watch console warnings for symbol truncation</li>
                                <li>One function per file = better selective linking</li>
                                <li>Download icons (üíæ) let you save any file anytime</li>
                                <li>Delete icons (üóëÔ∏è) help keep your project clean</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Projects Panel -->
                <div id="help-projects" class="help-panel hidden">
                    <h3 class="text-xl font-bold text-blue-400 mb-4">üì¶ Project Management</h3>

                    <div class="space-y-4">
                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-green-400 mb-2">üíæ Download Project</h4>
                            <p class="text-sm text-gray-300 mb-2">
                                Save your entire project as a ZIP file with all files and settings preserved.
                            </p>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-300">
                                <li>Click <strong class="text-blue-400">"Download Project"</strong> button (in More menu)</li>
                                <li>All files saved with folder structure intact</li>
                                <li>Includes <code class="bg-gray-800 px-1 rounded">project.json</code> manifest with settings</li>
                                <li>Main file marked with ‚≠ê is remembered</li>
                                <li>Output format preference saved</li>
                            </ul>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-purple-400 mb-2">üìÇ Upload Project</h4>
                            <p class="text-sm text-gray-300 mb-2">
                                Resume work by dragging your project ZIP back into the tool.
                            </p>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-300">
                                <li>Drag and drop the project ZIP file</li>
                                <li>All files automatically restored with folders</li>
                                <li>Settings applied from <code class="bg-gray-800 px-1 rounded">project.json</code></li>
                                <li>Main file auto-opens</li>
                                <li>Output format restored</li>
                            </ul>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-yellow-400 mb-2">‚≠ê Main File</h4>
                            <p class="text-sm text-gray-300 mb-2">
                                The main file is your project's entry point - marked with a gold star.
                            </p>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-300">
                                <li>Auto-detected from filename (main, start, header)</li>
                                <li>Shows ‚≠ê icon in file tree</li>
                                <li>Auto-opens when loading project</li>
                                <li>Saved in project manifest</li>
                            </ul>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-cyan-400 mb-2">üìÅ File Organization</h4>
                            <p class="text-sm text-gray-300 mb-2">
                                Files can have folder paths for better organization.
                            </p>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-300">
                                <li>Upload ZIPs with folder structure (e.g., <code class="bg-gray-800 px-1 rounded">src/main.asm</code>)</li>
                                <li>Folder paths preserved in downloads</li>
                                <li>Shown as hints next to filenames</li>
                                <li>Recommended: <code class="bg-gray-800 px-1 rounded">src/</code> for source, <code class="bg-gray-800 px-1 rounded">assets/</code> for data, <code class="bg-gray-800 px-1 rounded">build/</code> for outputs</li>
                            </ul>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg border-2 border-green-600">
                            <h4 class="text-lg font-semibold text-green-400 mb-2">üéØ Smart Auto-Organization</h4>
                            <p class="text-sm text-gray-300 mb-2">
                                The tool automatically organizes compiled outputs with zero configuration needed!
                            </p>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-300">
                                <li><strong class="text-blue-400">Compiled Files:</strong> .REL and .BIN files automatically saved to <code class="bg-gray-800 px-1 rounded">build/</code> folder</li>
                                <li><strong class="text-purple-400">Built Libraries:</strong> .LIB files automatically saved to <code class="bg-gray-800 px-1 rounded">lib/</code> folder</li>
                                <li><strong class="text-yellow-400">Optional Download:</strong> After building libraries, you can download a copy for use in other projects</li>
                                <li><strong class="text-cyan-400">Convention over Configuration:</strong> Works immediately without any setup</li>
                            </ul>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-pink-400 mb-2">üñ±Ô∏è File Management Tools</h4>
                            <p class="text-sm text-gray-300 mb-2">
                                Easily reorganize your project files with intuitive controls.
                            </p>
                            <div class="space-y-2 text-sm text-gray-300">
                                <div>
                                    <strong class="text-blue-400">Right-Click Context Menu:</strong>
                                    <ul class="list-disc list-inside ml-4 mt-1">
                                        <li>‚≠ê Set as Main File</li>
                                        <li>üìÅ Move to Folder...</li>
                                        <li>‚úèÔ∏è Rename...</li>
                                        <li>üíæ Download</li>
                                        <li>üóëÔ∏è Delete</li>
                                    </ul>
                                </div>
                                <div class="mt-2">
                                    <strong class="text-green-400">Drag & Drop Reorganization:</strong>
                                    <ul class="list-disc list-inside ml-4 mt-1">
                                        <li>Drag a file onto another file to move it to the same folder</li>
                                        <li>Drag a file to the drop zone to move it to root folder</li>
                                        <li>Visual feedback shows where the file will go</li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <div class="bg-gray-900 p-4 rounded-lg">
                            <h4 class="text-lg font-semibold text-orange-400 mb-2">üé® File Types</h4>
                            <p class="text-sm text-gray-300 mb-2">
                                Different file types are shown with unique icons and colors.
                            </p>
                            <div class="grid grid-cols-2 gap-2 text-xs text-gray-300">
                                <div>‚öôÔ∏è Source (.asm, .z80)</div>
                                <div>üìã Include (.inc, .h)</div>
                                <div>üì¶ Object (.rel, .o)</div>
                                <div>üìö Library (.lib)</div>
                                <div>üíæ Binary (.bin, .rom)</div>
                                <div>üóúÔ∏è Compressed (.zx0, .pletter)</div>
                                <div>üé® Graphics (.gfx, .chr)</div>
                                <div>üìä Data (.dat, .map)</div>
                                <div>‚öôÔ∏è Config (.json, .cfg)</div>
                                <div>üìÑ Docs (.md, .txt)</div>
                            </div>
                        </div>

                        <div class="bg-blue-900 bg-opacity-30 p-4 rounded-lg border border-blue-700">
                            <h4 class="text-sm font-semibold text-blue-300 mb-2">üí° Workflow Example</h4>
                            <ol class="list-decimal list-inside space-y-1 text-xs text-gray-300">
                                <li>Start new project - load your .asm files</li>
                                <li>Main file auto-detected (gets ‚≠ê)</li>
                                <li>Work on your code, compile as needed</li>
                                <li>Compiled outputs automatically go to <code class="bg-gray-800 px-1 rounded">build/</code></li>
                                <li>Build libraries - they auto-save to <code class="bg-gray-800 px-1 rounded">lib/</code></li>
                                <li>Right-click files to reorganize or rename</li>
                                <li>Click "Download Project" to save everything</li>
                                <li>Later: drag project ZIP back to resume</li>
                                <li>All settings, files, and folders restored instantly!</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Modal Footer -->
            <div class="bg-gray-900 p-4 border-t border-gray-700 flex justify-end">
                <button type="button" id="close-help-footer" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg font-semibold transition-colors">
                    Got it! üëç
                </button>
            </div>
        </div>
    </div>

    <script>
    // Help modal functionality
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const closeHelpBtn = document.getElementById('close-help');
    const closeHelpFooterBtn = document.getElementById('close-help-footer');
    const helpTabs = document.querySelectorAll('.help-tab');
    const helpPanels = document.querySelectorAll('.help-panel');

    helpBtn.addEventListener('click', () => {
        helpModal.classList.remove('hidden');
    });

    closeHelpBtn.addEventListener('click', () => {
        helpModal.classList.add('hidden');
    });

    closeHelpFooterBtn.addEventListener('click', () => {
        helpModal.classList.add('hidden');
    });

    // Close on ESC key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !helpModal.classList.contains('hidden')) {
            helpModal.classList.add('hidden');
        }
    });

    // Close on backdrop click
    helpModal.addEventListener('click', (e) => {
        if (e.target === helpModal) {
            helpModal.classList.add('hidden');
        }
    });

    // Tab switching
    helpTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const targetPanel = tab.dataset.panel;
            helpTabs.forEach(t => t.classList.remove('active'));
            helpPanels.forEach(p => p.classList.add('hidden'));
            tab.classList.add('active');
            document.getElementById(targetPanel).classList.remove('hidden');
        });
    });

    // More dropdown functionality
    const moreBtn = document.getElementById('more-btn');
    const moreContent = document.getElementById('more-content');

    if (moreBtn) {
        moreBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            moreContent.classList.toggle('show');
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.matches('#more-btn') && !e.target.closest('#more-content')) {
                moreContent.classList.remove('show');
            }
        });
    }

    // Context menu functionality
    const contextMenu = document.getElementById('file-context-menu');
    let contextMenuTarget = null;

    // Show context menu on right-click
    function showContextMenu(e, filename) {
        e.preventDefault();
        contextMenuTarget = filename;

        contextMenu.style.left = e.pageX + 'px';
        contextMenu.style.top = e.pageY + 'px';
        contextMenu.classList.remove('hidden');
    }

    // Hide context menu
    function hideContextMenu() {
        contextMenu.classList.add('hidden');
        contextMenuTarget = null;
    }

    // Close context menu when clicking outside
    document.addEventListener('click', (e) => {
        if (!contextMenu.contains(e.target)) {
            hideContextMenu();
        }
    });

    // Context menu actions
    document.getElementById('ctx-set-main').addEventListener('click', () => {
        if (contextMenuTarget) {
            projectManifest.mainFile = contextMenuTarget;
            updateManifest();
            renderFileTree();
            log(`Set ${contextMenuTarget} as main file`, 'success');
        }
        hideContextMenu();
    });

    document.getElementById('ctx-move-to-folder').addEventListener('click', () => {
        if (contextMenuTarget) {
            const currentFolder = extractFolder(contextMenuTarget) || '';
            const currentName = extractFilename(contextMenuTarget);
            const newFolder = prompt(`Move to folder (leave empty for root):\nCurrent: ${currentFolder || '(root)'}`, currentFolder);

            if (newFolder !== null) {
                const newPath = newFolder ? `${newFolder}/${currentName}` : currentName;
                if (newPath !== contextMenuTarget) {
                    projectFiles[newPath] = projectFiles[contextMenuTarget];
                    delete projectFiles[contextMenuTarget];

                    if (projectManifest.mainFile === contextMenuTarget) {
                        projectManifest.mainFile = newPath;
                    }
                    if (currentFile === contextMenuTarget) {
                        currentFile = newPath;
                    }

                    updateManifest();
                    renderFileTree();
                    log(`Moved ${currentName} to ${newFolder || 'root'}`, 'success');
                }
            }
        }
        hideContextMenu();
    });

    document.getElementById('ctx-rename').addEventListener('click', () => {
        if (contextMenuTarget) {
            const currentFolder = extractFolder(contextMenuTarget);
            const currentName = extractFilename(contextMenuTarget);
            const newName = prompt('Enter new filename:', currentName);

            if (newName && newName !== currentName) {
                const newPath = currentFolder ? `${currentFolder}/${newName}` : newName;
                projectFiles[newPath] = projectFiles[contextMenuTarget];
                delete projectFiles[contextMenuTarget];

                if (projectManifest.mainFile === contextMenuTarget) {
                    projectManifest.mainFile = newPath;
                }
                if (currentFile === contextMenuTarget) {
                    currentFile = newPath;
                }

                updateManifest();
                renderFileTree();
                log(`Renamed to ${newName}`, 'success');
            }
        }
        hideContextMenu();
    });

    document.getElementById('ctx-download').addEventListener('click', () => {
        if (contextMenuTarget) {
            downloadProjectFile(contextMenuTarget);
        }
        hideContextMenu();
    });

    document.getElementById('ctx-delete').addEventListener('click', () => {
        if (contextMenuTarget) {
            deleteProjectFile(contextMenuTarget);
        }
        hideContextMenu();
    });
    </script>

</body>
</html>
